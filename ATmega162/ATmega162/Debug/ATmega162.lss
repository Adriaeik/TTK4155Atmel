
ATmega162.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000001ba  00800100  00001424  000014b8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001424  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000001f  008002ba  008002ba  00001672  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001672  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000016a4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000288  00000000  00000000  000016e0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00003093  00000000  00000000  00001968  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001204  00000000  00000000  000049fb  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001601  00000000  00000000  00005bff  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000724  00000000  00000000  00007200  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000aac  00000000  00000000  00007924  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001c83  00000000  00000000  000083d0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000208  00000000  00000000  0000a053  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 9c 02 	jmp	0x538	; 0x538 <__ctors_end>
       4:	0c 94 b9 02 	jmp	0x572	; 0x572 <__bad_interrupt>
       8:	0c 94 b9 02 	jmp	0x572	; 0x572 <__bad_interrupt>
       c:	0c 94 b9 02 	jmp	0x572	; 0x572 <__bad_interrupt>
      10:	0c 94 b9 02 	jmp	0x572	; 0x572 <__bad_interrupt>
      14:	0c 94 b9 02 	jmp	0x572	; 0x572 <__bad_interrupt>
      18:	0c 94 b9 02 	jmp	0x572	; 0x572 <__bad_interrupt>
      1c:	0c 94 b9 02 	jmp	0x572	; 0x572 <__bad_interrupt>
      20:	0c 94 b9 02 	jmp	0x572	; 0x572 <__bad_interrupt>
      24:	0c 94 b9 02 	jmp	0x572	; 0x572 <__bad_interrupt>
      28:	0c 94 b9 02 	jmp	0x572	; 0x572 <__bad_interrupt>
      2c:	0c 94 b9 02 	jmp	0x572	; 0x572 <__bad_interrupt>
      30:	0c 94 b9 02 	jmp	0x572	; 0x572 <__bad_interrupt>
      34:	0c 94 b9 02 	jmp	0x572	; 0x572 <__bad_interrupt>
      38:	0c 94 b9 02 	jmp	0x572	; 0x572 <__bad_interrupt>
      3c:	0c 94 02 09 	jmp	0x1204	; 0x1204 <__vector_15>
      40:	0c 94 b9 02 	jmp	0x572	; 0x572 <__bad_interrupt>
      44:	0c 94 b9 02 	jmp	0x572	; 0x572 <__bad_interrupt>
      48:	0c 94 b9 02 	jmp	0x572	; 0x572 <__bad_interrupt>
      4c:	0c 94 e6 02 	jmp	0x5cc	; 0x5cc <__vector_19>
      50:	0c 94 b9 02 	jmp	0x572	; 0x572 <__bad_interrupt>
      54:	0c 94 b9 02 	jmp	0x572	; 0x572 <__bad_interrupt>
      58:	0c 94 b9 02 	jmp	0x572	; 0x572 <__bad_interrupt>
      5c:	0c 94 b9 02 	jmp	0x572	; 0x572 <__bad_interrupt>
      60:	0c 94 b9 02 	jmp	0x572	; 0x572 <__bad_interrupt>
      64:	0c 94 b9 02 	jmp	0x572	; 0x572 <__bad_interrupt>
      68:	0c 94 b9 02 	jmp	0x572	; 0x572 <__bad_interrupt>
      6c:	0c 94 b9 02 	jmp	0x572	; 0x572 <__bad_interrupt>

00000070 <__trampolines_end>:
	...
      78:	00 00       	nop
      7a:	5f 00       	.word	0x005f	; ????
      7c:	00 00       	nop
      7e:	00 00       	nop
      80:	00 07       	cpc	r16, r16
      82:	00 07       	cpc	r16, r16
      84:	00 00       	nop
      86:	00 00       	nop
      88:	14 7f       	andi	r17, 0xF4	; 244
      8a:	14 7f       	andi	r17, 0xF4	; 244
      8c:	14 00       	.word	0x0014	; ????
      8e:	00 00       	nop
      90:	24 2a       	or	r2, r20
      92:	7f 2a       	or	r7, r31
      94:	12 00       	.word	0x0012	; ????
      96:	00 00       	nop
      98:	23 13       	cpse	r18, r19
      9a:	08 64       	ori	r16, 0x48	; 72
      9c:	62 00       	.word	0x0062	; ????
      9e:	00 00       	nop
      a0:	36 49       	sbci	r19, 0x96	; 150
      a2:	56 20       	and	r5, r6
      a4:	50 00       	.word	0x0050	; ????
      a6:	00 00       	nop
      a8:	00 08       	sbc	r0, r0
      aa:	07 03       	mulsu	r16, r23
      ac:	00 00       	nop
      ae:	00 00       	nop
      b0:	00 1c       	adc	r0, r0
      b2:	22 41       	sbci	r18, 0x12	; 18
      b4:	00 00       	nop
      b6:	00 00       	nop
      b8:	00 41       	sbci	r16, 0x10	; 16
      ba:	22 1c       	adc	r2, r2
      bc:	00 00       	nop
      be:	00 00       	nop
      c0:	14 08       	sbc	r1, r4
      c2:	3e 08       	sbc	r3, r14
      c4:	14 00       	.word	0x0014	; ????
      c6:	00 00       	nop
      c8:	08 08       	sbc	r0, r8
      ca:	3e 08       	sbc	r3, r14
      cc:	08 00       	.word	0x0008	; ????
      ce:	00 00       	nop
      d0:	00 50       	subi	r16, 0x00	; 0
      d2:	30 00       	.word	0x0030	; ????
      d4:	00 00       	nop
      d6:	00 00       	nop
      d8:	08 08       	sbc	r0, r8
      da:	08 08       	sbc	r0, r8
      dc:	08 00       	.word	0x0008	; ????
      de:	00 00       	nop
      e0:	00 60       	ori	r16, 0x00	; 0
      e2:	60 00       	.word	0x0060	; ????
      e4:	00 00       	nop
      e6:	00 00       	nop
      e8:	20 10       	cpse	r2, r0
      ea:	08 04       	cpc	r0, r8
      ec:	02 00       	.word	0x0002	; ????
      ee:	00 00       	nop
      f0:	3e 51       	subi	r19, 0x1E	; 30
      f2:	49 45       	sbci	r20, 0x59	; 89
      f4:	3e 00       	.word	0x003e	; ????
      f6:	00 00       	nop
      f8:	00 42       	sbci	r16, 0x20	; 32
      fa:	7f 40       	sbci	r23, 0x0F	; 15
      fc:	00 00       	nop
      fe:	00 00       	nop
     100:	42 61       	ori	r20, 0x12	; 18
     102:	51 49       	sbci	r21, 0x91	; 145
     104:	46 00       	.word	0x0046	; ????
     106:	00 00       	nop
     108:	21 41       	sbci	r18, 0x11	; 17
     10a:	45 4b       	sbci	r20, 0xB5	; 181
     10c:	31 00       	.word	0x0031	; ????
     10e:	00 00       	nop
     110:	18 14       	cp	r1, r8
     112:	12 7f       	andi	r17, 0xF2	; 242
     114:	10 00       	.word	0x0010	; ????
     116:	00 00       	nop
     118:	27 45       	sbci	r18, 0x57	; 87
     11a:	45 45       	sbci	r20, 0x55	; 85
     11c:	39 00       	.word	0x0039	; ????
     11e:	00 00       	nop
     120:	3c 4a       	sbci	r19, 0xAC	; 172
     122:	49 49       	sbci	r20, 0x99	; 153
     124:	30 00       	.word	0x0030	; ????
     126:	00 00       	nop
     128:	01 71       	andi	r16, 0x11	; 17
     12a:	09 05       	cpc	r16, r9
     12c:	03 00       	.word	0x0003	; ????
     12e:	00 00       	nop
     130:	36 49       	sbci	r19, 0x96	; 150
     132:	49 49       	sbci	r20, 0x99	; 153
     134:	36 00       	.word	0x0036	; ????
     136:	00 00       	nop
     138:	06 49       	sbci	r16, 0x96	; 150
     13a:	49 29       	or	r20, r9
     13c:	1e 00       	.word	0x001e	; ????
     13e:	00 00       	nop
     140:	00 36       	cpi	r16, 0x60	; 96
     142:	36 00       	.word	0x0036	; ????
     144:	00 00       	nop
     146:	00 00       	nop
     148:	00 56       	subi	r16, 0x60	; 96
     14a:	36 00       	.word	0x0036	; ????
     14c:	00 00       	nop
     14e:	00 00       	nop
     150:	08 14       	cp	r0, r8
     152:	22 41       	sbci	r18, 0x12	; 18
     154:	00 00       	nop
     156:	00 00       	nop
     158:	14 14       	cp	r1, r4
     15a:	14 14       	cp	r1, r4
     15c:	14 14       	cp	r1, r4
     15e:	00 00       	nop
     160:	41 22       	and	r4, r17
     162:	14 08       	sbc	r1, r4
     164:	00 00       	nop
     166:	00 00       	nop
     168:	02 01       	movw	r0, r4
     16a:	51 09       	sbc	r21, r1
     16c:	06 00       	.word	0x0006	; ????
     16e:	00 00       	nop
     170:	3e 41       	sbci	r19, 0x1E	; 30
     172:	5d 5d       	subi	r21, 0xDD	; 221
     174:	1e 00       	.word	0x001e	; ????
     176:	00 00       	nop
     178:	7e 11       	cpse	r23, r14
     17a:	11 11       	cpse	r17, r1
     17c:	7e 00       	.word	0x007e	; ????
     17e:	00 00       	nop
     180:	7f 49       	sbci	r23, 0x9F	; 159
     182:	49 49       	sbci	r20, 0x99	; 153
     184:	36 00       	.word	0x0036	; ????
     186:	00 00       	nop
     188:	3e 41       	sbci	r19, 0x1E	; 30
     18a:	41 41       	sbci	r20, 0x11	; 17
     18c:	22 00       	.word	0x0022	; ????
     18e:	00 00       	nop
     190:	7f 41       	sbci	r23, 0x1F	; 31
     192:	41 22       	and	r4, r17
     194:	1c 00       	.word	0x001c	; ????
     196:	00 00       	nop
     198:	7f 49       	sbci	r23, 0x9F	; 159
     19a:	49 49       	sbci	r20, 0x99	; 153
     19c:	41 00       	.word	0x0041	; ????
     19e:	00 00       	nop
     1a0:	7f 09       	sbc	r23, r15
     1a2:	09 09       	sbc	r16, r9
     1a4:	01 00       	.word	0x0001	; ????
     1a6:	00 00       	nop
     1a8:	3e 41       	sbci	r19, 0x1E	; 30
     1aa:	49 49       	sbci	r20, 0x99	; 153
     1ac:	7a 00       	.word	0x007a	; ????
     1ae:	00 00       	nop
     1b0:	7f 08       	sbc	r7, r15
     1b2:	08 08       	sbc	r0, r8
     1b4:	7f 00       	.word	0x007f	; ????
     1b6:	00 00       	nop
     1b8:	00 41       	sbci	r16, 0x10	; 16
     1ba:	7f 41       	sbci	r23, 0x1F	; 31
     1bc:	00 00       	nop
     1be:	00 00       	nop
     1c0:	20 40       	sbci	r18, 0x00	; 0
     1c2:	41 3f       	cpi	r20, 0xF1	; 241
     1c4:	01 00       	.word	0x0001	; ????
     1c6:	00 00       	nop
     1c8:	7f 08       	sbc	r7, r15
     1ca:	14 22       	and	r1, r20
     1cc:	41 00       	.word	0x0041	; ????
     1ce:	00 00       	nop
     1d0:	7f 40       	sbci	r23, 0x0F	; 15
     1d2:	40 40       	sbci	r20, 0x00	; 0
     1d4:	40 00       	.word	0x0040	; ????
     1d6:	00 00       	nop
     1d8:	7f 02       	muls	r23, r31
     1da:	04 02       	muls	r16, r20
     1dc:	7f 00       	.word	0x007f	; ????
     1de:	00 00       	nop
     1e0:	7f 02       	muls	r23, r31
     1e2:	04 08       	sbc	r0, r4
     1e4:	7f 00       	.word	0x007f	; ????
     1e6:	00 00       	nop
     1e8:	3e 41       	sbci	r19, 0x1E	; 30
     1ea:	41 41       	sbci	r20, 0x11	; 17
     1ec:	3e 00       	.word	0x003e	; ????
     1ee:	00 00       	nop
     1f0:	7f 09       	sbc	r23, r15
     1f2:	09 09       	sbc	r16, r9
     1f4:	06 00       	.word	0x0006	; ????
     1f6:	00 00       	nop
     1f8:	3e 41       	sbci	r19, 0x1E	; 30
     1fa:	51 21       	and	r21, r1
     1fc:	5e 00       	.word	0x005e	; ????
     1fe:	00 00       	nop
     200:	7f 09       	sbc	r23, r15
     202:	19 29       	or	r17, r9
     204:	46 00       	.word	0x0046	; ????
     206:	00 00       	nop
     208:	46 49       	sbci	r20, 0x96	; 150
     20a:	49 49       	sbci	r20, 0x99	; 153
     20c:	31 00       	.word	0x0031	; ????
     20e:	00 00       	nop
     210:	01 01       	movw	r0, r2
     212:	7f 01       	movw	r14, r30
     214:	01 00       	.word	0x0001	; ????
     216:	00 00       	nop
     218:	3f 40       	sbci	r19, 0x0F	; 15
     21a:	40 40       	sbci	r20, 0x00	; 0
     21c:	3f 00       	.word	0x003f	; ????
     21e:	00 00       	nop
     220:	1f 20       	and	r1, r15
     222:	40 20       	and	r4, r0
     224:	1f 00       	.word	0x001f	; ????
     226:	00 00       	nop
     228:	7f 20       	and	r7, r15
     22a:	18 20       	and	r1, r8
     22c:	7f 00       	.word	0x007f	; ????
     22e:	00 00       	nop
     230:	63 14       	cp	r6, r3
     232:	08 14       	cp	r0, r8
     234:	63 00       	.word	0x0063	; ????
     236:	00 00       	nop
     238:	03 04       	cpc	r0, r3
     23a:	78 04       	cpc	r7, r8
     23c:	03 00       	.word	0x0003	; ????
     23e:	00 00       	nop
     240:	61 51       	subi	r22, 0x11	; 17
     242:	49 45       	sbci	r20, 0x59	; 89
     244:	43 00       	.word	0x0043	; ????
     246:	00 00       	nop
     248:	00 3e       	cpi	r16, 0xE0	; 224
     24a:	41 41       	sbci	r20, 0x11	; 17
     24c:	00 00       	nop
     24e:	00 00       	nop
     250:	02 04       	cpc	r0, r2
     252:	08 10       	cpse	r0, r8
     254:	20 00       	.word	0x0020	; ????
     256:	00 00       	nop
     258:	00 41       	sbci	r16, 0x10	; 16
     25a:	41 3e       	cpi	r20, 0xE1	; 225
     25c:	00 00       	nop
     25e:	00 00       	nop
     260:	04 02       	muls	r16, r20
     262:	01 02       	muls	r16, r17
     264:	04 00       	.word	0x0004	; ????
     266:	00 00       	nop
     268:	40 40       	sbci	r20, 0x00	; 0
     26a:	40 40       	sbci	r20, 0x00	; 0
     26c:	40 40       	sbci	r20, 0x00	; 0
     26e:	00 00       	nop
     270:	00 00       	nop
     272:	03 07       	cpc	r16, r19
     274:	00 00       	nop
     276:	00 00       	nop
     278:	20 54       	subi	r18, 0x40	; 64
     27a:	54 54       	subi	r21, 0x44	; 68
     27c:	78 00       	.word	0x0078	; ????
     27e:	00 00       	nop
     280:	7f 48       	sbci	r23, 0x8F	; 143
     282:	44 44       	sbci	r20, 0x44	; 68
     284:	38 00       	.word	0x0038	; ????
     286:	00 00       	nop
     288:	38 44       	sbci	r19, 0x48	; 72
     28a:	44 44       	sbci	r20, 0x44	; 68
     28c:	20 00       	.word	0x0020	; ????
     28e:	00 00       	nop
     290:	38 44       	sbci	r19, 0x48	; 72
     292:	44 48       	sbci	r20, 0x84	; 132
     294:	7f 00       	.word	0x007f	; ????
     296:	00 00       	nop
     298:	38 54       	subi	r19, 0x48	; 72
     29a:	54 54       	subi	r21, 0x44	; 68
     29c:	18 00       	.word	0x0018	; ????
     29e:	00 00       	nop
     2a0:	08 7e       	andi	r16, 0xE8	; 232
     2a2:	09 01       	movw	r0, r18
     2a4:	02 00       	.word	0x0002	; ????
     2a6:	00 00       	nop
     2a8:	08 14       	cp	r0, r8
     2aa:	54 54       	subi	r21, 0x44	; 68
     2ac:	3c 00       	.word	0x003c	; ????
     2ae:	00 00       	nop
     2b0:	7f 08       	sbc	r7, r15
     2b2:	04 04       	cpc	r0, r4
     2b4:	78 00       	.word	0x0078	; ????
     2b6:	00 00       	nop
     2b8:	00 44       	sbci	r16, 0x40	; 64
     2ba:	7d 40       	sbci	r23, 0x0D	; 13
     2bc:	00 00       	nop
     2be:	00 00       	nop
     2c0:	20 40       	sbci	r18, 0x00	; 0
     2c2:	44 3d       	cpi	r20, 0xD4	; 212
     2c4:	00 00       	nop
     2c6:	00 00       	nop
     2c8:	00 7f       	andi	r16, 0xF0	; 240
     2ca:	10 28       	or	r1, r0
     2cc:	44 00       	.word	0x0044	; ????
     2ce:	00 00       	nop
     2d0:	00 41       	sbci	r16, 0x10	; 16
     2d2:	7f 40       	sbci	r23, 0x0F	; 15
     2d4:	00 00       	nop
     2d6:	00 00       	nop
     2d8:	7c 04       	cpc	r7, r12
     2da:	18 04       	cpc	r1, r8
     2dc:	78 00       	.word	0x0078	; ????
     2de:	00 00       	nop
     2e0:	7c 08       	sbc	r7, r12
     2e2:	04 04       	cpc	r0, r4
     2e4:	78 00       	.word	0x0078	; ????
     2e6:	00 00       	nop
     2e8:	38 44       	sbci	r19, 0x48	; 72
     2ea:	44 44       	sbci	r20, 0x44	; 68
     2ec:	38 00       	.word	0x0038	; ????
     2ee:	00 00       	nop
     2f0:	7c 14       	cp	r7, r12
     2f2:	14 14       	cp	r1, r4
     2f4:	08 00       	.word	0x0008	; ????
     2f6:	00 00       	nop
     2f8:	08 14       	cp	r0, r8
     2fa:	14 18       	sub	r1, r4
     2fc:	7c 00       	.word	0x007c	; ????
     2fe:	00 00       	nop
     300:	7c 08       	sbc	r7, r12
     302:	04 04       	cpc	r0, r4
     304:	08 00       	.word	0x0008	; ????
     306:	00 00       	nop
     308:	48 54       	subi	r20, 0x48	; 72
     30a:	54 54       	subi	r21, 0x44	; 68
     30c:	20 00       	.word	0x0020	; ????
     30e:	00 00       	nop
     310:	04 3f       	cpi	r16, 0xF4	; 244
     312:	44 40       	sbci	r20, 0x04	; 4
     314:	20 00       	.word	0x0020	; ????
     316:	00 00       	nop
     318:	3c 40       	sbci	r19, 0x0C	; 12
     31a:	40 20       	and	r4, r0
     31c:	7c 00       	.word	0x007c	; ????
     31e:	00 00       	nop
     320:	1c 20       	and	r1, r12
     322:	40 20       	and	r4, r0
     324:	1c 00       	.word	0x001c	; ????
     326:	00 00       	nop
     328:	3c 40       	sbci	r19, 0x0C	; 12
     32a:	30 40       	sbci	r19, 0x00	; 0
     32c:	3c 00       	.word	0x003c	; ????
     32e:	00 00       	nop
     330:	44 28       	or	r4, r4
     332:	10 28       	or	r1, r0
     334:	44 00       	.word	0x0044	; ????
     336:	00 00       	nop
     338:	0c 50       	subi	r16, 0x0C	; 12
     33a:	50 50       	subi	r21, 0x00	; 0
     33c:	3c 00       	.word	0x003c	; ????
     33e:	00 00       	nop
     340:	44 64       	ori	r20, 0x44	; 68
     342:	54 4c       	sbci	r21, 0xC4	; 196
     344:	44 00       	.word	0x0044	; ????
     346:	00 00       	nop
     348:	00 08       	sbc	r0, r0
     34a:	36 41       	sbci	r19, 0x16	; 22
     34c:	00 00       	nop
     34e:	00 00       	nop
     350:	00 00       	nop
     352:	7f 00       	.word	0x007f	; ????
     354:	00 00       	nop
     356:	00 00       	nop
     358:	00 41       	sbci	r16, 0x10	; 16
     35a:	36 08       	sbc	r3, r6
     35c:	00 00       	nop
     35e:	00 00       	nop
     360:	08 04       	cpc	r0, r8
     362:	08 10       	cpse	r0, r8
     364:	08 00       	.word	0x0008	; ????
	...

00000368 <settingsMenuItems>:
     368:	20 53 6f 75 6e 64 20 20 20 20 20 20 20 20 00 00      Sound        ..
     378:	20 42 72 69 67 68 74 6e 65 73 73 20 20 20 00 00      Brightness   ..
     388:	20 43 6f 6e 74 72 6f 6c 73 20 20 20 20 20 00 00      Controls     ..
     398:	20 42 61 63 6b 20 20 20 20 20 20 20 20 20 00 00      Back         ..

000003a8 <scrollMenuItems>:
     3a8:	20 49 74 65 6d 20 31 20 20 42 41 43 4b 20 00 00      Item 1  BACK ..
     3b8:	20 49 74 65 6d 20 32 20 20 20 20 20 20 20 00 00      Item 2       ..
     3c8:	20 49 74 65 6d 20 33 20 20 20 20 20 20 20 00 00      Item 3       ..
     3d8:	20 49 74 65 6d 20 34 20 20 20 20 20 20 20 00 00      Item 4       ..
     3e8:	20 49 74 65 6d 20 35 20 20 20 20 20 20 20 00 00      Item 5       ..
     3f8:	20 49 74 65 6d 20 36 20 20 20 20 20 20 20 00 00      Item 6       ..
     408:	20 49 74 65 6d 20 37 20 20 20 20 20 20 20 00 00      Item 7       ..
     418:	20 49 74 65 6d 20 38 20 20 20 20 20 20 20 00 00      Item 8       ..
     428:	20 49 74 65 6d 20 39 20 20 20 20 20 20 20 00 00      Item 9       ..
     438:	20 49 74 65 6d 20 31 30 20 20 20 20 20 20 00 00      Item 10      ..
     448:	20 49 74 65 6d 20 31 31 20 20 20 20 20 20 00 00      Item 11      ..
     458:	20 49 74 65 6d 20 31 32 20 20 20 20 20 20 00 00      Item 12      ..
     468:	20 49 74 65 6d 20 31 33 20 20 20 20 20 20 00 00      Item 13      ..
     478:	20 49 74 65 6d 20 31 34 20 20 20 20 20 20 00 00      Item 14      ..
     488:	20 49 74 65 6d 20 31 35 20 20 20 20 20 20 00 00      Item 15      ..
     498:	20 49 74 65 6d 20 31 36 20 20 20 20 20 20 00 00      Item 16      ..
     4a8:	20 49 74 65 6d 20 31 37 20 20 20 20 20 20 00 00      Item 17      ..
     4b8:	20 49 74 65 6d 20 31 38 20 20 20 20 20 20 00 00      Item 18      ..
     4c8:	20 49 74 65 6d 20 31 39 20 20 20 20 20 20 00 00      Item 19      ..
     4d8:	20 49 74 65 6d 20 32 30 20 20 20 20 20 20 00 00      Item 20      ..

000004e8 <mainMenuItems>:
     4e8:	20 53 74 61 72 74 20 47 61 6d 65 20 20 20 00 00      Start Game   ..
     4f8:	20 53 65 74 74 69 6e 67 73 20 20 20 20 20 00 00      Settings     ..
     508:	20 48 69 67 68 20 53 63 6f 72 65 73 20 20 00 00      High Scores  ..
     518:	20 43 72 65 64 69 74 73 20 20 20 20 20 20 00 00      Credits      ..
     528:	20 45 78 69 74 20 20 20 20 20 20 20 20 20 00 00      Exit         ..

00000538 <__ctors_end>:
     538:	11 24       	eor	r1, r1
     53a:	1f be       	out	0x3f, r1	; 63
     53c:	cf ef       	ldi	r28, 0xFF	; 255
     53e:	d4 e0       	ldi	r29, 0x04	; 4
     540:	de bf       	out	0x3e, r29	; 62
     542:	cd bf       	out	0x3d, r28	; 61

00000544 <__do_copy_data>:
     544:	12 e0       	ldi	r17, 0x02	; 2
     546:	a0 e0       	ldi	r26, 0x00	; 0
     548:	b1 e0       	ldi	r27, 0x01	; 1
     54a:	e4 e2       	ldi	r30, 0x24	; 36
     54c:	f4 e1       	ldi	r31, 0x14	; 20
     54e:	02 c0       	rjmp	.+4      	; 0x554 <__do_copy_data+0x10>
     550:	05 90       	lpm	r0, Z+
     552:	0d 92       	st	X+, r0
     554:	aa 3b       	cpi	r26, 0xBA	; 186
     556:	b1 07       	cpc	r27, r17
     558:	d9 f7       	brne	.-10     	; 0x550 <__do_copy_data+0xc>

0000055a <__do_clear_bss>:
     55a:	22 e0       	ldi	r18, 0x02	; 2
     55c:	aa eb       	ldi	r26, 0xBA	; 186
     55e:	b2 e0       	ldi	r27, 0x02	; 2
     560:	01 c0       	rjmp	.+2      	; 0x564 <.do_clear_bss_start>

00000562 <.do_clear_bss_loop>:
     562:	1d 92       	st	X+, r1

00000564 <.do_clear_bss_start>:
     564:	a9 3d       	cpi	r26, 0xD9	; 217
     566:	b2 07       	cpc	r27, r18
     568:	e1 f7       	brne	.-8      	; 0x562 <.do_clear_bss_loop>
     56a:	0e 94 f3 02 	call	0x5e6	; 0x5e6 <main>
     56e:	0c 94 10 0a 	jmp	0x1420	; 0x1420 <_exit>

00000572 <__bad_interrupt>:
     572:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000576 <UART_Init>:
	setBit(UCSR0B, RXCIE0);
}

// Deaktiver avbrot for når data blir mottatt
void UART_DisableReceiveInterrupt(void) {
	clearBit(UCSR0B, RXCIE0);
     576:	90 bd       	out	0x20, r25	; 32
     578:	89 b9       	out	0x09, r24	; 9
     57a:	54 9a       	sbi	0x0a, 4	; 10
     57c:	53 9a       	sbi	0x0a, 3	; 10
     57e:	8e e8       	ldi	r24, 0x8E	; 142
     580:	80 bd       	out	0x20, r24	; 32
     582:	08 95       	ret

00000584 <UART_SendChar>:
     584:	5d 9b       	sbis	0x0b, 5	; 11
     586:	fe cf       	rjmp	.-4      	; 0x584 <UART_SendChar>
     588:	8c b9       	out	0x0c, r24	; 12
     58a:	08 95       	ret

0000058c <UART_putChar>:
     58c:	0e 94 c2 02 	call	0x584	; 0x584 <UART_SendChar>
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	08 95       	ret

00000596 <UART_ReceiveChar>:
     596:	5f 9b       	sbis	0x0b, 7	; 11
     598:	fe cf       	rjmp	.-4      	; 0x596 <UART_ReceiveChar>
     59a:	8c b1       	in	r24, 0x0c	; 12
     59c:	08 95       	ret

0000059e <UART_getChar>:
     59e:	cf 93       	push	r28
     5a0:	0e 94 cb 02 	call	0x596	; 0x596 <UART_ReceiveChar>
     5a4:	c8 2f       	mov	r28, r24
     5a6:	0e 94 c2 02 	call	0x584	; 0x584 <UART_SendChar>
     5aa:	8c 2f       	mov	r24, r28
     5ac:	90 e0       	ldi	r25, 0x00	; 0
     5ae:	cf 91       	pop	r28
     5b0:	08 95       	ret

000005b2 <URAT_initStudio>:
     5b2:	e3 ed       	ldi	r30, 0xD3	; 211
     5b4:	f2 e0       	ldi	r31, 0x02	; 2
     5b6:	8e e0       	ldi	r24, 0x0E	; 14
     5b8:	91 e0       	ldi	r25, 0x01	; 1
     5ba:	93 83       	std	Z+3, r25	; 0x03
     5bc:	82 83       	std	Z+2, r24	; 0x02
     5be:	80 e0       	ldi	r24, 0x00	; 0
     5c0:	91 e0       	ldi	r25, 0x01	; 1
     5c2:	91 83       	std	Z+1, r25	; 0x01
     5c4:	80 83       	st	Z, r24
     5c6:	08 95       	ret

000005c8 <UART_EnableReceiveInterrupt>:
     5c8:	57 9a       	sbi	0x0a, 7	; 10
     5ca:	08 95       	ret

000005cc <__vector_19>:
}

// UART mottaksavbrotvektor USART0_RX_vect
ISR(USART0_RXC_vect) {
     5cc:	1f 92       	push	r1
     5ce:	0f 92       	push	r0
     5d0:	0f b6       	in	r0, 0x3f	; 63
     5d2:	0f 92       	push	r0
     5d4:	11 24       	eor	r1, r1
     5d6:	8f 93       	push	r24
	// Handter mottatt data
	char received = UDR0;
     5d8:	8c b1       	in	r24, 0x0c	; 12
}
     5da:	8f 91       	pop	r24
     5dc:	0f 90       	pop	r0
     5de:	0f be       	out	0x3f, r0	; 63
     5e0:	0f 90       	pop	r0
     5e2:	1f 90       	pop	r1
     5e4:	18 95       	reti

000005e6 <main>:

#include "DriverUART.h"
#include "SRAM.h"
#include "Menu_init.h"

int main(void) {
     5e6:	cf 93       	push	r28
     5e8:	df 93       	push	r29
     5ea:	cd b7       	in	r28, 0x3d	; 61
     5ec:	de b7       	in	r29, 0x3e	; 62
     5ee:	2f 97       	sbiw	r28, 0x0f	; 15
     5f0:	0f b6       	in	r0, 0x3f	; 63
     5f2:	f8 94       	cli
     5f4:	de bf       	out	0x3e, r29	; 62
     5f6:	0f be       	out	0x3f, r0	; 63
     5f8:	cd bf       	out	0x3d, r28	; 61
	/*_________________INITIALISERINGER START______________________*/
	// Initialiser UART med baudrate 9600
	UART_Init(MYUBBR);
     5fa:	8f e1       	ldi	r24, 0x1F	; 31
     5fc:	90 e0       	ldi	r25, 0x00	; 0
     5fe:	0e 94 bb 02 	call	0x576	; 0x576 <UART_Init>
	URAT_initStudio();
     602:	0e 94 d9 02 	call	0x5b2	; 0x5b2 <URAT_initStudio>
	UART_EnableReceiveInterrupt();
     606:	0e 94 e4 02 	call	0x5c8	; 0x5c8 <UART_EnableReceiveInterrupt>
    setup_timer();						// Start millisekundteljinga
     60a:	0e 94 46 09 	call	0x128c	; 0x128c <setup_timer>
	sei();								// Aktiver globale avbrot
     60e:	78 94       	sei
	externalMemoryInit();				// Initialiser eksternt minne må vere etter sei
     610:	0e 94 59 09 	call	0x12b2	; 0x12b2 <externalMemoryInit>
	initialize_menus();
     614:	0e 94 40 04 	call	0x880	; 0x880 <initialize_menus>
	MultiBoard board;
	MultiBoard_Init(&board);			// Initialiser MultiBoard og kalibrer joystickens origo
     618:	ce 01       	movw	r24, r28
     61a:	01 96       	adiw	r24, 0x01	; 1
     61c:	0e 94 f7 04 	call	0x9ee	; 0x9ee <MultiBoard_Init>
	oled_init();						// Initialiser OLED-skjermen
     620:	0e 94 0a 06 	call	0xc14	; 0xc14 <oled_init>
	//setup_printf_for_oled();			// Optional
	//SRAM_test();
	
	/*______MENY______*/
	current_menu = &mainMenu;
     624:	87 ec       	ldi	r24, 0xC7	; 199
     626:	92 e0       	ldi	r25, 0x02	; 2
     628:	90 93 bb 02 	sts	0x02BB, r25	; 0x8002bb <__data_end+0x1>
     62c:	80 93 ba 02 	sts	0x02BA, r24	; 0x8002ba <__data_end>
	

	/*_______TEST OLED______________________*/
	
	oled_home();
     630:	0e 94 03 06 	call	0xc06	; 0xc06 <oled_home>
	oled_write_screen_to_SRAM(smiley);
     634:	8d e1       	ldi	r24, 0x1D	; 29
     636:	91 e0       	ldi	r25, 0x01	; 1
     638:	0e 94 9f 06 	call	0xd3e	; 0xd3e <oled_write_screen_to_SRAM>
	oled_data_from_SRAM();
     63c:	0e 94 4d 06 	call	0xc9a	; 0xc9a <oled_data_from_SRAM>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     640:	2f ef       	ldi	r18, 0xFF	; 255
     642:	8f ef       	ldi	r24, 0xFF	; 255
     644:	9e e0       	ldi	r25, 0x0E	; 14
     646:	21 50       	subi	r18, 0x01	; 1
     648:	80 40       	sbci	r24, 0x00	; 0
     64a:	90 40       	sbci	r25, 0x00	; 0
     64c:	e1 f7       	brne	.-8      	; 0x646 <main+0x60>
     64e:	00 c0       	rjmp	.+0      	; 0x650 <main+0x6a>
     650:	00 00       	nop
	_delay_ms(1000); //smile litt før start
	
	//linje og slikt
	oled_clear_screen();
     652:	0e 94 ec 07 	call	0xfd8	; 0xfd8 <oled_clear_screen>
	oled_draw_line(10, 10, 100, 50);
     656:	22 e3       	ldi	r18, 0x32	; 50
     658:	44 e6       	ldi	r20, 0x64	; 100
     65a:	6a e0       	ldi	r22, 0x0A	; 10
     65c:	8a e0       	ldi	r24, 0x0A	; 10
     65e:	0e 94 0a 08 	call	0x1014	; 0x1014 <oled_draw_line>
	oled_draw_circle(64, 32, 20);
     662:	44 e1       	ldi	r20, 0x14	; 20
     664:	50 e0       	ldi	r21, 0x00	; 0
     666:	60 e2       	ldi	r22, 0x20	; 32
     668:	70 e0       	ldi	r23, 0x00	; 0
     66a:	80 e4       	ldi	r24, 0x40	; 64
     66c:	90 e0       	ldi	r25, 0x00	; 0
     66e:	0e 94 6d 08 	call	0x10da	; 0x10da <oled_draw_circle>
	oled_draw_square(20, 20, 40, 30);
     672:	2e e1       	ldi	r18, 0x1E	; 30
     674:	48 e2       	ldi	r20, 0x28	; 40
     676:	64 e1       	ldi	r22, 0x14	; 20
     678:	84 e1       	ldi	r24, 0x14	; 20
     67a:	0e 94 dd 08 	call	0x11ba	; 0x11ba <oled_draw_square>
	oled_data_from_SRAM();
     67e:	0e 94 4d 06 	call	0xc9a	; 0xc9a <oled_data_from_SRAM>
     682:	2f ef       	ldi	r18, 0xFF	; 255
     684:	8f ef       	ldi	r24, 0xFF	; 255
     686:	95 e9       	ldi	r25, 0x95	; 149
     688:	21 50       	subi	r18, 0x01	; 1
     68a:	80 40       	sbci	r24, 0x00	; 0
     68c:	90 40       	sbci	r25, 0x00	; 0
     68e:	e1 f7       	brne	.-8      	; 0x688 <main+0xa2>
     690:	00 c0       	rjmp	.+0      	; 0x692 <main+0xac>
     692:	00 00       	nop
	_delay_ms(10000);
	
	/*_______HOVUDLØKKE______*/
	 while (1) {

        menu_navigate(&board, &current_menu);  // Kallar `menu_navigate` med referanse til gjeldande meny
     694:	6a eb       	ldi	r22, 0xBA	; 186
     696:	72 e0       	ldi	r23, 0x02	; 2
     698:	ce 01       	movw	r24, r28
     69a:	01 96       	adiw	r24, 0x01	; 1
     69c:	0e 94 16 04 	call	0x82c	; 0x82c <menu_navigate>
		
		/*Så lenge vi ikkje har noko delay gåandes og ditta står her tenker eg 
		at den oppdateres automatisk med det minnet vi har skreve til sramen?
		Det kunne vert fornuftig med eit flag her då
		*/
		if (get_time_in_ms() >= 16) {
     6a0:	0e 94 3b 09 	call	0x1276	; 0x1276 <get_time_in_ms>
     6a4:	60 31       	cpi	r22, 0x10	; 16
     6a6:	71 05       	cpc	r23, r1
     6a8:	81 05       	cpc	r24, r1
     6aa:	91 05       	cpc	r25, r1
     6ac:	98 f3       	brcs	.-26     	; 0x694 <main+0xae>
			restart_timer();
     6ae:	0e 94 4e 09 	call	0x129c	; 0x129c <restart_timer>
			oled_data_from_SRAM();
     6b2:	0e 94 4d 06 	call	0xc9a	; 0xc9a <oled_data_from_SRAM>
     6b6:	ee cf       	rjmp	.-36     	; 0x694 <main+0xae>

000006b8 <oled_display_menu>:
}

// Sjekker om joystick-knappen er trykt
uint8_t is_joystick_button_pressed(MultiBoard* board) {
	return (board->JoyBtn != 0);  // Anta at knappen er aktiv-høg (1 betyr trykt)
}
     6b8:	cf 92       	push	r12
     6ba:	df 92       	push	r13
     6bc:	ef 92       	push	r14
     6be:	ff 92       	push	r15
     6c0:	1f 93       	push	r17
     6c2:	cf 93       	push	r28
     6c4:	df 93       	push	r29
     6c6:	cd b7       	in	r28, 0x3d	; 61
     6c8:	de b7       	in	r29, 0x3e	; 62
     6ca:	c0 59       	subi	r28, 0x90	; 144
     6cc:	d1 09       	sbc	r29, r1
     6ce:	0f b6       	in	r0, 0x3f	; 63
     6d0:	f8 94       	cli
     6d2:	de bf       	out	0x3e, r29	; 62
     6d4:	0f be       	out	0x3f, r0	; 63
     6d6:	cd bf       	out	0x3d, r28	; 61
     6d8:	6c 01       	movw	r12, r24
     6da:	fe 01       	movw	r30, r28
     6dc:	71 96       	adiw	r30, 0x11	; 17
     6de:	80 e8       	ldi	r24, 0x80	; 128
     6e0:	df 01       	movw	r26, r30
     6e2:	1d 92       	st	X+, r1
     6e4:	8a 95       	dec	r24
     6e6:	e9 f7       	brne	.-6      	; 0x6e2 <oled_display_menu+0x2a>
     6e8:	7f 01       	movw	r14, r30
     6ea:	10 e0       	ldi	r17, 0x00	; 0
     6ec:	f6 01       	movw	r30, r12
     6ee:	84 81       	ldd	r24, Z+4	; 0x04
     6f0:	81 0f       	add	r24, r17
     6f2:	95 81       	ldd	r25, Z+5	; 0x05
     6f4:	89 17       	cp	r24, r25
     6f6:	a8 f4       	brcc	.+42     	; 0x722 <oled_display_menu+0x6a>
     6f8:	60 81       	ld	r22, Z
     6fa:	71 81       	ldd	r23, Z+1	; 0x01
     6fc:	f0 e1       	ldi	r31, 0x10	; 16
     6fe:	8f 9f       	mul	r24, r31
     700:	60 0d       	add	r22, r0
     702:	71 1d       	adc	r23, r1
     704:	11 24       	eor	r1, r1
     706:	40 e1       	ldi	r20, 0x10	; 16
     708:	50 e0       	ldi	r21, 0x00	; 0
     70a:	ce 01       	movw	r24, r28
     70c:	01 96       	adiw	r24, 0x01	; 1
     70e:	0e 94 f2 09 	call	0x13e4	; 0x13e4 <strncpy_P>
     712:	40 e1       	ldi	r20, 0x10	; 16
     714:	50 e0       	ldi	r21, 0x00	; 0
     716:	be 01       	movw	r22, r28
     718:	6f 5f       	subi	r22, 0xFF	; 255
     71a:	7f 4f       	sbci	r23, 0xFF	; 255
     71c:	c7 01       	movw	r24, r14
     71e:	0e 94 01 0a 	call	0x1402	; 0x1402 <strncpy>
     722:	1f 5f       	subi	r17, 0xFF	; 255
     724:	80 e1       	ldi	r24, 0x10	; 16
     726:	e8 0e       	add	r14, r24
     728:	f1 1c       	adc	r15, r1
     72a:	18 30       	cpi	r17, 0x08	; 8
     72c:	f9 f6       	brne	.-66     	; 0x6ec <oled_display_menu+0x34>
     72e:	ce 01       	movw	r24, r28
     730:	41 96       	adiw	r24, 0x11	; 17
     732:	0e 94 9f 06 	call	0xd3e	; 0xd3e <oled_write_screen_to_SRAM>
     736:	d6 01       	movw	r26, r12
     738:	12 96       	adiw	r26, 0x02	; 2
     73a:	8c 91       	ld	r24, X
     73c:	12 97       	sbiw	r26, 0x02	; 2
     73e:	14 96       	adiw	r26, 0x04	; 4
     740:	9c 91       	ld	r25, X
     742:	4e e3       	ldi	r20, 0x3E	; 62
     744:	60 e0       	ldi	r22, 0x00	; 0
     746:	89 1b       	sub	r24, r25
     748:	0e 94 7b 07 	call	0xef6	; 0xef6 <oled_write_char_to_SRAM>
     74c:	c0 57       	subi	r28, 0x70	; 112
     74e:	df 4f       	sbci	r29, 0xFF	; 255
     750:	0f b6       	in	r0, 0x3f	; 63
     752:	f8 94       	cli
     754:	de bf       	out	0x3e, r29	; 62
     756:	0f be       	out	0x3f, r0	; 63
     758:	cd bf       	out	0x3d, r28	; 61
     75a:	df 91       	pop	r29
     75c:	cf 91       	pop	r28
     75e:	1f 91       	pop	r17
     760:	ff 90       	pop	r15
     762:	ef 90       	pop	r14
     764:	df 90       	pop	r13
     766:	cf 90       	pop	r12
     768:	08 95       	ret

0000076a <update_menu_arrows>:
     76a:	cf 93       	push	r28
     76c:	c8 2f       	mov	r28, r24
     76e:	86 2f       	mov	r24, r22
     770:	40 e2       	ldi	r20, 0x20	; 32
     772:	60 e0       	ldi	r22, 0x00	; 0
     774:	0e 94 7b 07 	call	0xef6	; 0xef6 <oled_write_char_to_SRAM>
     778:	4e e3       	ldi	r20, 0x3E	; 62
     77a:	60 e0       	ldi	r22, 0x00	; 0
     77c:	8c 2f       	mov	r24, r28
     77e:	0e 94 7b 07 	call	0xef6	; 0xef6 <oled_write_char_to_SRAM>
     782:	cf 91       	pop	r28
     784:	08 95       	ret

00000786 <update_menu_position_from_joystick>:
     786:	fb 01       	movw	r30, r22
     788:	dc 01       	movw	r26, r24
     78a:	1b 96       	adiw	r26, 0x0b	; 11
     78c:	8d 91       	ld	r24, X+
     78e:	9c 91       	ld	r25, X
     790:	1c 97       	sbiw	r26, 0x0c	; 12
     792:	83 33       	cpi	r24, 0x33	; 51
     794:	91 05       	cpc	r25, r1
     796:	fc f0       	brlt	.+62     	; 0x7d6 <update_menu_position_from_joystick+0x50>
     798:	62 81       	ldd	r22, Z+2	; 0x02
     79a:	66 23       	and	r22, r22
     79c:	09 f4       	brne	.+2      	; 0x7a0 <update_menu_position_from_joystick+0x1a>
     79e:	45 c0       	rjmp	.+138    	; 0x82a <update_menu_position_from_joystick+0xa4>
     7a0:	63 83       	std	Z+3, r22	; 0x03
     7a2:	8f ef       	ldi	r24, 0xFF	; 255
     7a4:	86 0f       	add	r24, r22
     7a6:	82 83       	std	Z+2, r24	; 0x02
     7a8:	94 81       	ldd	r25, Z+4	; 0x04
     7aa:	89 17       	cp	r24, r25
     7ac:	30 f4       	brcc	.+12     	; 0x7ba <update_menu_position_from_joystick+0x34>
     7ae:	91 50       	subi	r25, 0x01	; 1
     7b0:	94 83       	std	Z+4, r25	; 0x04
     7b2:	cf 01       	movw	r24, r30
     7b4:	0e 94 5c 03 	call	0x6b8	; 0x6b8 <oled_display_menu>
     7b8:	04 c0       	rjmp	.+8      	; 0x7c2 <update_menu_position_from_joystick+0x3c>
     7ba:	69 1b       	sub	r22, r25
     7bc:	89 1b       	sub	r24, r25
     7be:	0e 94 b5 03 	call	0x76a	; 0x76a <update_menu_arrows>
     7c2:	bf ef       	ldi	r27, 0xFF	; 255
     7c4:	2f ef       	ldi	r18, 0xFF	; 255
     7c6:	82 e0       	ldi	r24, 0x02	; 2
     7c8:	b1 50       	subi	r27, 0x01	; 1
     7ca:	20 40       	sbci	r18, 0x00	; 0
     7cc:	80 40       	sbci	r24, 0x00	; 0
     7ce:	e1 f7       	brne	.-8      	; 0x7c8 <update_menu_position_from_joystick+0x42>
     7d0:	00 c0       	rjmp	.+0      	; 0x7d2 <update_menu_position_from_joystick+0x4c>
     7d2:	00 c0       	rjmp	.+0      	; 0x7d4 <update_menu_position_from_joystick+0x4e>
     7d4:	08 95       	ret
     7d6:	8e 3c       	cpi	r24, 0xCE	; 206
     7d8:	9f 4f       	sbci	r25, 0xFF	; 255
     7da:	3c f5       	brge	.+78     	; 0x82a <update_menu_position_from_joystick+0xa4>
     7dc:	62 81       	ldd	r22, Z+2	; 0x02
     7de:	26 2f       	mov	r18, r22
     7e0:	30 e0       	ldi	r19, 0x00	; 0
     7e2:	85 81       	ldd	r24, Z+5	; 0x05
     7e4:	90 e0       	ldi	r25, 0x00	; 0
     7e6:	01 97       	sbiw	r24, 0x01	; 1
     7e8:	28 17       	cp	r18, r24
     7ea:	39 07       	cpc	r19, r25
     7ec:	f4 f4       	brge	.+60     	; 0x82a <update_menu_position_from_joystick+0xa4>
     7ee:	63 83       	std	Z+3, r22	; 0x03
     7f0:	81 e0       	ldi	r24, 0x01	; 1
     7f2:	86 0f       	add	r24, r22
     7f4:	82 83       	std	Z+2, r24	; 0x02
     7f6:	94 81       	ldd	r25, Z+4	; 0x04
     7f8:	48 2f       	mov	r20, r24
     7fa:	50 e0       	ldi	r21, 0x00	; 0
     7fc:	29 2f       	mov	r18, r25
     7fe:	30 e0       	ldi	r19, 0x00	; 0
     800:	28 5f       	subi	r18, 0xF8	; 248
     802:	3f 4f       	sbci	r19, 0xFF	; 255
     804:	42 17       	cp	r20, r18
     806:	53 07       	cpc	r21, r19
     808:	1c f0       	brlt	.+6      	; 0x810 <update_menu_position_from_joystick+0x8a>
     80a:	9f 5f       	subi	r25, 0xFF	; 255
     80c:	94 83       	std	Z+4, r25	; 0x04
     80e:	04 c0       	rjmp	.+8      	; 0x818 <update_menu_position_from_joystick+0x92>
     810:	69 1b       	sub	r22, r25
     812:	89 1b       	sub	r24, r25
     814:	0e 94 b5 03 	call	0x76a	; 0x76a <update_menu_arrows>
     818:	bf ef       	ldi	r27, 0xFF	; 255
     81a:	2f ef       	ldi	r18, 0xFF	; 255
     81c:	82 e0       	ldi	r24, 0x02	; 2
     81e:	b1 50       	subi	r27, 0x01	; 1
     820:	20 40       	sbci	r18, 0x00	; 0
     822:	80 40       	sbci	r24, 0x00	; 0
     824:	e1 f7       	brne	.-8      	; 0x81e <update_menu_position_from_joystick+0x98>
     826:	00 c0       	rjmp	.+0      	; 0x828 <update_menu_position_from_joystick+0xa2>
     828:	00 c0       	rjmp	.+0      	; 0x82a <update_menu_position_from_joystick+0xa4>
     82a:	08 95       	ret

0000082c <menu_navigate>:

static uint8_t menu_changed = 1;  // Flag for å spore endringar i menyen
// Funksjon for å navigere i menyen uten blokkering
void menu_navigate(MultiBoard* board, Menu** menu) {
     82c:	0f 93       	push	r16
     82e:	1f 93       	push	r17
     830:	cf 93       	push	r28
     832:	df 93       	push	r29
     834:	ec 01       	movw	r28, r24
     836:	8b 01       	movw	r16, r22

	// Oppdater joystick- og menyposisjon
	MultiBoard_Update(board);
     838:	0e 94 8d 05 	call	0xb1a	; 0xb1a <MultiBoard_Update>
	update_menu_position_from_joystick(board, *menu);
     83c:	f8 01       	movw	r30, r16
     83e:	60 81       	ld	r22, Z
     840:	71 81       	ldd	r23, Z+1	; 0x01
     842:	ce 01       	movw	r24, r28
     844:	0e 94 c3 03 	call	0x786	; 0x786 <update_menu_position_from_joystick>

	// Sjekk om menyen har endra seg
	if (menu_changed) {
     848:	80 91 1c 01 	lds	r24, 0x011C	; 0x80011c <menu_changed>
     84c:	88 23       	and	r24, r24
     84e:	39 f0       	breq	.+14     	; 0x85e <menu_navigate+0x32>
		oled_display_menu(*menu);  // Oppdater OLED med den nye menyen
     850:	f8 01       	movw	r30, r16
     852:	80 81       	ld	r24, Z
     854:	91 81       	ldd	r25, Z+1	; 0x01
     856:	0e 94 5c 03 	call	0x6b8	; 0x6b8 <oled_display_menu>
		menu_changed = 0;  // Nullstill flagget etter oppdatering
     85a:	10 92 1c 01 	sts	0x011C, r1	; 0x80011c <menu_changed>
	}

	// Sjekk om knappen er trykt for å bekrefte menyval
	if (is_joystick_button_pressed(board)) {
     85e:	8e 81       	ldd	r24, Y+6	; 0x06
     860:	88 23       	and	r24, r24
     862:	49 f0       	breq	.+18     	; 0x876 <menu_navigate+0x4a>
		oled_clear_screen();
     864:	0e 94 ec 07 	call	0xfd8	; 0xfd8 <oled_clear_screen>
		handleMenuSelection(board, menu);  // Behandlar menyvalet
     868:	b8 01       	movw	r22, r16
     86a:	ce 01       	movw	r24, r28
     86c:	0e 94 62 04 	call	0x8c4	; 0x8c4 <handleMenuSelection>
		menu_changed = 1;  // Menyen vil endre seg etter valet
     870:	81 e0       	ldi	r24, 0x01	; 1
     872:	80 93 1c 01 	sts	0x011C, r24	; 0x80011c <menu_changed>
	}
}
     876:	df 91       	pop	r29
     878:	cf 91       	pop	r28
     87a:	1f 91       	pop	r17
     87c:	0f 91       	pop	r16
     87e:	08 95       	ret

00000880 <initialize_menus>:
Menu mainMenu;
Menu scrollMenu;
Menu settingsMenu;

void initialize_menus() {
	mainMenu.items = mainMenuItems;
     880:	e7 ec       	ldi	r30, 0xC7	; 199
     882:	f2 e0       	ldi	r31, 0x02	; 2
     884:	88 ee       	ldi	r24, 0xE8	; 232
     886:	94 e0       	ldi	r25, 0x04	; 4
     888:	91 83       	std	Z+1, r25	; 0x01
     88a:	80 83       	st	Z, r24
	mainMenu.num_items = 5;
     88c:	85 e0       	ldi	r24, 0x05	; 5
     88e:	85 83       	std	Z+5, r24	; 0x05
	mainMenu.current_position = 0;
     890:	12 82       	std	Z+2, r1	; 0x02
	mainMenu.prev_position = 0;
     892:	13 82       	std	Z+3, r1	; 0x03
	mainMenu.scroll_offset = 0;
     894:	14 82       	std	Z+4, r1	; 0x04

	scrollMenu.items = scrollMenuItems;
     896:	ed ec       	ldi	r30, 0xCD	; 205
     898:	f2 e0       	ldi	r31, 0x02	; 2
     89a:	88 ea       	ldi	r24, 0xA8	; 168
     89c:	93 e0       	ldi	r25, 0x03	; 3
     89e:	91 83       	std	Z+1, r25	; 0x01
     8a0:	80 83       	st	Z, r24
	scrollMenu.num_items = 20;
     8a2:	84 e1       	ldi	r24, 0x14	; 20
     8a4:	85 83       	std	Z+5, r24	; 0x05
	scrollMenu.current_position = 0;
     8a6:	12 82       	std	Z+2, r1	; 0x02
	scrollMenu.prev_position = 0;
     8a8:	13 82       	std	Z+3, r1	; 0x03
	scrollMenu.scroll_offset = 0;
     8aa:	14 82       	std	Z+4, r1	; 0x04

	settingsMenu.items = settingsMenuItems;
     8ac:	e1 ec       	ldi	r30, 0xC1	; 193
     8ae:	f2 e0       	ldi	r31, 0x02	; 2
     8b0:	88 e6       	ldi	r24, 0x68	; 104
     8b2:	93 e0       	ldi	r25, 0x03	; 3
     8b4:	91 83       	std	Z+1, r25	; 0x01
     8b6:	80 83       	st	Z, r24
	settingsMenu.num_items = 4;
     8b8:	84 e0       	ldi	r24, 0x04	; 4
     8ba:	85 83       	std	Z+5, r24	; 0x05
	settingsMenu.current_position = 0;
     8bc:	12 82       	std	Z+2, r1	; 0x02
	settingsMenu.prev_position = 0;
     8be:	13 82       	std	Z+3, r1	; 0x03
	settingsMenu.scroll_offset = 0;
     8c0:	14 82       	std	Z+4, r1	; 0x04
     8c2:	08 95       	ret

000008c4 <handleMenuSelection>:
}

void handleMenuSelection(MultiBoard* board, Menu* menu) {
	switch (currentMenuState) {
     8c4:	80 91 bc 02 	lds	r24, 0x02BC	; 0x8002bc <currentMenuState>
     8c8:	81 30       	cpi	r24, 0x01	; 1
     8ca:	09 f4       	brne	.+2      	; 0x8ce <handleMenuSelection+0xa>
     8cc:	6f c0       	rjmp	.+222    	; 0x9ac <handleMenuSelection+0xe8>
     8ce:	20 f0       	brcs	.+8      	; 0x8d8 <handleMenuSelection+0x14>
     8d0:	82 30       	cpi	r24, 0x02	; 2
     8d2:	09 f4       	brne	.+2      	; 0x8d6 <handleMenuSelection+0x12>
     8d4:	40 c0       	rjmp	.+128    	; 0x956 <handleMenuSelection+0x92>
     8d6:	08 95       	ret
		case MAIN_MENU:
		switch (menu->current_position) {
     8d8:	fb 01       	movw	r30, r22
     8da:	82 81       	ldd	r24, Z+2	; 0x02
     8dc:	82 30       	cpi	r24, 0x02	; 2
     8de:	d9 f0       	breq	.+54     	; 0x916 <handleMenuSelection+0x52>
     8e0:	28 f4       	brcc	.+10     	; 0x8ec <handleMenuSelection+0x28>
     8e2:	88 23       	and	r24, r24
     8e4:	41 f0       	breq	.+16     	; 0x8f6 <handleMenuSelection+0x32>
     8e6:	81 30       	cpi	r24, 0x01	; 1
     8e8:	61 f0       	breq	.+24     	; 0x902 <handleMenuSelection+0x3e>
     8ea:	2f c0       	rjmp	.+94     	; 0x94a <handleMenuSelection+0x86>
     8ec:	83 30       	cpi	r24, 0x03	; 3
     8ee:	e9 f0       	breq	.+58     	; 0x92a <handleMenuSelection+0x66>
     8f0:	84 30       	cpi	r24, 0x04	; 4
     8f2:	29 f1       	breq	.+74     	; 0x93e <handleMenuSelection+0x7a>
     8f4:	2a c0       	rjmp	.+84     	; 0x94a <handleMenuSelection+0x86>
			case 0:
			oled_write_line_to_SRAM(0, "Startar spelet...");
     8f6:	6d e1       	ldi	r22, 0x1D	; 29
     8f8:	72 e0       	ldi	r23, 0x02	; 2
     8fa:	80 e0       	ldi	r24, 0x00	; 0
     8fc:	0e 94 03 07 	call	0xe06	; 0xe06 <oled_write_line_to_SRAM>
			break;
     900:	08 95       	ret
			case 1:
			// Gå til innstillingar
			currentMenuState = SETTINGS_MENU;
     902:	82 e0       	ldi	r24, 0x02	; 2
     904:	80 93 bc 02 	sts	0x02BC, r24	; 0x8002bc <currentMenuState>
			current_menu = &settingsMenu;  // Oppdater til innstillingsmeny
     908:	81 ec       	ldi	r24, 0xC1	; 193
     90a:	92 e0       	ldi	r25, 0x02	; 2
     90c:	90 93 bb 02 	sts	0x02BB, r25	; 0x8002bb <__data_end+0x1>
     910:	80 93 ba 02 	sts	0x02BA, r24	; 0x8002ba <__data_end>
			break;
     914:	08 95       	ret
			case 2:
			// Gå til scrollemeny
			currentMenuState = SCROLL_MENU;
     916:	81 e0       	ldi	r24, 0x01	; 1
     918:	80 93 bc 02 	sts	0x02BC, r24	; 0x8002bc <currentMenuState>
			current_menu = &scrollMenu;  // Oppdater til scrollemeny
     91c:	8d ec       	ldi	r24, 0xCD	; 205
     91e:	92 e0       	ldi	r25, 0x02	; 2
     920:	90 93 bb 02 	sts	0x02BB, r25	; 0x8002bb <__data_end+0x1>
     924:	80 93 ba 02 	sts	0x02BA, r24	; 0x8002ba <__data_end>
			break;
     928:	08 95       	ret
			case 3:
			oled_write_line_to_SRAM(0, "Viser kredittar...");
     92a:	6f e2       	ldi	r22, 0x2F	; 47
     92c:	72 e0       	ldi	r23, 0x02	; 2
     92e:	80 e0       	ldi	r24, 0x00	; 0
     930:	0e 94 03 07 	call	0xe06	; 0xe06 <oled_write_line_to_SRAM>
			oled_write_screen_to_SRAM(solkors);  // Vis kredittar på skjermen
     934:	8d e9       	ldi	r24, 0x9D	; 157
     936:	91 e0       	ldi	r25, 0x01	; 1
     938:	0e 94 9f 06 	call	0xd3e	; 0xd3e <oled_write_screen_to_SRAM>
			break;
     93c:	08 95       	ret
			case 4:
			oled_write_line_to_SRAM(0, "Avsluttar...");
     93e:	62 e4       	ldi	r22, 0x42	; 66
     940:	72 e0       	ldi	r23, 0x02	; 2
     942:	80 e0       	ldi	r24, 0x00	; 0
     944:	0e 94 03 07 	call	0xe06	; 0xe06 <oled_write_line_to_SRAM>
			// Legg eventuelt til funksjonalitet for å avslutte
			break;
     948:	08 95       	ret
			default:
			oled_write_line_to_SRAM(0, "Ugyldig valg");
     94a:	6f e4       	ldi	r22, 0x4F	; 79
     94c:	72 e0       	ldi	r23, 0x02	; 2
     94e:	80 e0       	ldi	r24, 0x00	; 0
     950:	0e 94 03 07 	call	0xe06	; 0xe06 <oled_write_line_to_SRAM>
			break;
     954:	08 95       	ret
		}
		break;

		case SETTINGS_MENU:
		// Håndter valg i innstillingsmenyen
		switch (menu->current_position) {
     956:	fb 01       	movw	r30, r22
     958:	82 81       	ldd	r24, Z+2	; 0x02
     95a:	81 30       	cpi	r24, 0x01	; 1
     95c:	61 f0       	breq	.+24     	; 0x976 <handleMenuSelection+0xb2>
     95e:	28 f0       	brcs	.+10     	; 0x96a <handleMenuSelection+0xa6>
     960:	82 30       	cpi	r24, 0x02	; 2
     962:	79 f0       	breq	.+30     	; 0x982 <handleMenuSelection+0xbe>
     964:	83 30       	cpi	r24, 0x03	; 3
     966:	99 f0       	breq	.+38     	; 0x98e <handleMenuSelection+0xca>
     968:	1b c0       	rjmp	.+54     	; 0x9a0 <handleMenuSelection+0xdc>
			case 0:
			oled_write_line_to_SRAM(0, "Endrer lydinnstillingar...");
     96a:	6c e5       	ldi	r22, 0x5C	; 92
     96c:	72 e0       	ldi	r23, 0x02	; 2
     96e:	80 e0       	ldi	r24, 0x00	; 0
     970:	0e 94 03 07 	call	0xe06	; 0xe06 <oled_write_line_to_SRAM>
			break;
     974:	08 95       	ret
			case 1:
			oled_write_line_to_SRAM(0, "Endrer lysstyrke...");
     976:	67 e7       	ldi	r22, 0x77	; 119
     978:	72 e0       	ldi	r23, 0x02	; 2
     97a:	80 e0       	ldi	r24, 0x00	; 0
     97c:	0e 94 03 07 	call	0xe06	; 0xe06 <oled_write_line_to_SRAM>
			break;
     980:	08 95       	ret
			case 2:
			oled_write_line_to_SRAM(0, "Endrer kontrollar...");
     982:	6b e8       	ldi	r22, 0x8B	; 139
     984:	72 e0       	ldi	r23, 0x02	; 2
     986:	80 e0       	ldi	r24, 0x00	; 0
     988:	0e 94 03 07 	call	0xe06	; 0xe06 <oled_write_line_to_SRAM>
			break;
     98c:	08 95       	ret
			case 3:
			// Gå tilbake til hovudmenyen
			currentMenuState = MAIN_MENU;
     98e:	10 92 bc 02 	sts	0x02BC, r1	; 0x8002bc <currentMenuState>
			current_menu = &mainMenu;
     992:	87 ec       	ldi	r24, 0xC7	; 199
     994:	92 e0       	ldi	r25, 0x02	; 2
     996:	90 93 bb 02 	sts	0x02BB, r25	; 0x8002bb <__data_end+0x1>
     99a:	80 93 ba 02 	sts	0x02BA, r24	; 0x8002ba <__data_end>
			break;
     99e:	08 95       	ret
			default:
			oled_write_line_to_SRAM(0, "Ugyldig valg");
     9a0:	6f e4       	ldi	r22, 0x4F	; 79
     9a2:	72 e0       	ldi	r23, 0x02	; 2
     9a4:	80 e0       	ldi	r24, 0x00	; 0
     9a6:	0e 94 03 07 	call	0xe06	; 0xe06 <oled_write_line_to_SRAM>
			break;
     9aa:	08 95       	ret
		}
		break;

		case SCROLL_MENU:
		// Håndter valg i scrollemenyen
		switch (menu->current_position) {
     9ac:	fb 01       	movw	r30, r22
     9ae:	82 81       	ldd	r24, Z+2	; 0x02
     9b0:	88 23       	and	r24, r24
     9b2:	19 f0       	breq	.+6      	; 0x9ba <handleMenuSelection+0xf6>
     9b4:	81 30       	cpi	r24, 0x01	; 1
     9b6:	79 f0       	breq	.+30     	; 0x9d6 <handleMenuSelection+0x112>
     9b8:	14 c0       	rjmp	.+40     	; 0x9e2 <handleMenuSelection+0x11e>
			case 0:
			oled_write_line_to_SRAM(0, "Item 1 valgt");
     9ba:	60 ea       	ldi	r22, 0xA0	; 160
     9bc:	72 e0       	ldi	r23, 0x02	; 2
     9be:	80 e0       	ldi	r24, 0x00	; 0
     9c0:	0e 94 03 07 	call	0xe06	; 0xe06 <oled_write_line_to_SRAM>
			currentMenuState = MAIN_MENU;
     9c4:	10 92 bc 02 	sts	0x02BC, r1	; 0x8002bc <currentMenuState>
			current_menu = &mainMenu;
     9c8:	87 ec       	ldi	r24, 0xC7	; 199
     9ca:	92 e0       	ldi	r25, 0x02	; 2
     9cc:	90 93 bb 02 	sts	0x02BB, r25	; 0x8002bb <__data_end+0x1>
     9d0:	80 93 ba 02 	sts	0x02BA, r24	; 0x8002ba <__data_end>
			break;
     9d4:	08 95       	ret
			case 1:
			oled_write_line_to_SRAM(0, "Item 2 valgt");
     9d6:	6d ea       	ldi	r22, 0xAD	; 173
     9d8:	72 e0       	ldi	r23, 0x02	; 2
     9da:	80 e0       	ldi	r24, 0x00	; 0
     9dc:	0e 94 03 07 	call	0xe06	; 0xe06 <oled_write_line_to_SRAM>
			break;
     9e0:	08 95       	ret
			default:
			oled_write_line_to_SRAM(0, "Ugyldig valg");
     9e2:	6f e4       	ldi	r22, 0x4F	; 79
     9e4:	72 e0       	ldi	r23, 0x02	; 2
     9e6:	80 e0       	ldi	r24, 0x00	; 0
     9e8:	0e 94 03 07 	call	0xe06	; 0xe06 <oled_write_line_to_SRAM>
     9ec:	08 95       	ret

000009ee <MultiBoard_Init>:
 * Created: 14.09.2024 11:00:59
 *  Author: ravneb
 */ 
#include "MultiBoard.h"

void MultiBoard_Init(MultiBoard* board) {
     9ee:	cf 93       	push	r28
     9f0:	df 93       	push	r29
     9f2:	ec 01       	movw	r28, r24
	// Set pinner for knapper som input
	clearBit(DDRB, LEFT_BUTTON_PIN);  // Set Left button pin as input
     9f4:	bc 98       	cbi	0x17, 4	; 23
	clearBit(DDRB, RIGHT_BUTTON_PIN); // Set Right button pin as input
     9f6:	bb 98       	cbi	0x17, 3	; 23
	clearBit(DDRB, JOY_BUTTON_PIN);   // Set Joystick button pin as input
     9f8:	ba 98       	cbi	0x17, 2	; 23
	clearBit(DDRB, BUSY_PIN);         // Set BUSY pin as input
     9fa:	b9 98       	cbi	0x17, 1	; 23
	
	// Aktiver pullup
	setBit(PORTB, JOY_BUTTON_PIN);
     9fc:	c2 9a       	sbi	0x18, 2	; 24
	

	// Kalibrer joysticken (finn origo)
	Universal_write(ADC_START, 0x80); // For Chip Enable til ADC, (data her er irrelevant)
     9fe:	60 e8       	ldi	r22, 0x80	; 128
     a00:	80 e0       	ldi	r24, 0x00	; 0
     a02:	94 e1       	ldi	r25, 0x14	; 20
     a04:	0e 94 88 09 	call	0x1310	; 0x1310 <Universal_write>
	loopUntilBitIsClear(PINB, BUSY_PIN);    // Vent til BUSY gï¿½r lav
     a08:	b1 99       	sbic	0x16, 1	; 22
     a0a:	fe cf       	rjmp	.-4      	; 0xa08 <MultiBoard_Init+0x1a>
	board->JoyYOrigo = Universal_read(ADC_START); //CH0
     a0c:	80 e0       	ldi	r24, 0x00	; 0
     a0e:	94 e1       	ldi	r25, 0x14	; 20
     a10:	0e 94 98 09 	call	0x1330	; 0x1330 <Universal_read>
     a14:	88 87       	std	Y+8, r24	; 0x08
	board->JoyXOrigo = Universal_read(ADC_START); //CH1
     a16:	80 e0       	ldi	r24, 0x00	; 0
     a18:	94 e1       	ldi	r25, 0x14	; 20
     a1a:	0e 94 98 09 	call	0x1330	; 0x1330 <Universal_read>
     a1e:	8f 83       	std	Y+7, r24	; 0x07
	
	// Initialiser alle andre verdier
	board->LSpos = 0;
     a20:	1a 82       	std	Y+2, r1	; 0x02
	board->RSpos = 0;
     a22:	1b 82       	std	Y+3, r1	; 0x03
	board->LBtn = 0;
     a24:	1c 82       	std	Y+4, r1	; 0x04
	board->RBtn = 0;
     a26:	1d 82       	std	Y+5, r1	; 0x05
	board->JoyXpos = 0;
     a28:	19 82       	std	Y+1, r1	; 0x01
	board->JoyYpos = 0;
     a2a:	18 82       	st	Y, r1
	board->JoyXposCal = 0;
     a2c:	1a 86       	std	Y+10, r1	; 0x0a
     a2e:	19 86       	std	Y+9, r1	; 0x09
	board->JoyYposCal = 0;
     a30:	1c 86       	std	Y+12, r1	; 0x0c
     a32:	1b 86       	std	Y+11, r1	; 0x0b
	board->JoyAngle = 0;
     a34:	1e 86       	std	Y+14, r1	; 0x0e
     a36:	1d 86       	std	Y+13, r1	; 0x0d
	board->JoyBtn = 0;  // Endra fra en, vi bruker fortsatt 0 for av basert pÃ¥ logikk i MB_Update()
     a38:	1e 82       	std	Y+6, r1	; 0x06
}
     a3a:	df 91       	pop	r29
     a3c:	cf 91       	pop	r28
     a3e:	08 95       	ret

00000a40 <MultiBoard_UpdateJoystickAngle>:
	///IKKJE TESTA
	MultiBoard_UpdateJoystickAngle(board);
}

/// IKKJE TESTA 
void MultiBoard_UpdateJoystickAngle(MultiBoard* board) {
     a40:	fc 01       	movw	r30, r24
	int16_t x = board->JoyXposCal;
     a42:	61 85       	ldd	r22, Z+9	; 0x09
     a44:	72 85       	ldd	r23, Z+10	; 0x0a
	int16_t y = board->JoyYposCal;
     a46:	43 85       	ldd	r20, Z+11	; 0x0b
     a48:	54 85       	ldd	r21, Z+12	; 0x0c

	// Unngï¿½ divisjon med 0 (nï¿½r senterpunkt) + hysterese
	if (!(abs(x) > JOY_ANGLE_HYSTERESIS || abs(y) >  JOY_ANGLE_HYSTERESIS)) {
     a4a:	cb 01       	movw	r24, r22
     a4c:	05 96       	adiw	r24, 0x05	; 5
     a4e:	0b 97       	sbiw	r24, 0x0b	; 11
     a50:	38 f4       	brcc	.+14     	; 0xa60 <MultiBoard_UpdateJoystickAngle+0x20>
     a52:	ca 01       	movw	r24, r20
     a54:	05 96       	adiw	r24, 0x05	; 5
     a56:	0b 97       	sbiw	r24, 0x0b	; 11
     a58:	18 f4       	brcc	.+6      	; 0xa60 <MultiBoard_UpdateJoystickAngle+0x20>
		board->JoyAngle = 0;  // Midtpunkt, sett vinkelen til 0
     a5a:	16 86       	std	Z+14, r1	; 0x0e
     a5c:	15 86       	std	Z+13, r1	; 0x0d
     a5e:	08 95       	ret
		} else {
		// Bestem kvadrant basert pï¿½ verdiane til x og y
		switch ((x >= 0) << 1 | (y >= 0)) {
     a60:	87 2f       	mov	r24, r23
     a62:	80 95       	com	r24
     a64:	88 1f       	adc	r24, r24
     a66:	88 27       	eor	r24, r24
     a68:	88 1f       	adc	r24, r24
     a6a:	90 e0       	ldi	r25, 0x00	; 0
     a6c:	88 0f       	add	r24, r24
     a6e:	99 1f       	adc	r25, r25
     a70:	25 2f       	mov	r18, r21
     a72:	20 95       	com	r18
     a74:	22 1f       	adc	r18, r18
     a76:	22 27       	eor	r18, r18
     a78:	22 1f       	adc	r18, r18
     a7a:	82 2b       	or	r24, r18
     a7c:	81 30       	cpi	r24, 0x01	; 1
     a7e:	91 05       	cpc	r25, r1
     a80:	b9 f0       	breq	.+46     	; 0xab0 <MultiBoard_UpdateJoystickAngle+0x70>
     a82:	1c f4       	brge	.+6      	; 0xa8a <MultiBoard_UpdateJoystickAngle+0x4a>
     a84:	89 2b       	or	r24, r25
     a86:	29 f1       	breq	.+74     	; 0xad2 <MultiBoard_UpdateJoystickAngle+0x92>
     a88:	45 c0       	rjmp	.+138    	; 0xb14 <MultiBoard_UpdateJoystickAngle+0xd4>
     a8a:	82 30       	cpi	r24, 0x02	; 2
     a8c:	91 05       	cpc	r25, r1
     a8e:	99 f1       	breq	.+102    	; 0xaf6 <MultiBoard_UpdateJoystickAngle+0xb6>
     a90:	03 97       	sbiw	r24, 0x03	; 3
     a92:	09 f0       	breq	.+2      	; 0xa96 <MultiBoard_UpdateJoystickAngle+0x56>
     a94:	3f c0       	rjmp	.+126    	; 0xb14 <MultiBoard_UpdateJoystickAngle+0xd4>
			case 0b11:  // Fï¿½rste kvadrant (x >= 0, y >= 0)
			board->JoyAngle = (y * 90) / (x + y);
     a96:	2a e5       	ldi	r18, 0x5A	; 90
     a98:	24 9f       	mul	r18, r20
     a9a:	c0 01       	movw	r24, r0
     a9c:	25 9f       	mul	r18, r21
     a9e:	90 0d       	add	r25, r0
     aa0:	11 24       	eor	r1, r1
     aa2:	64 0f       	add	r22, r20
     aa4:	75 1f       	adc	r23, r21
     aa6:	0e 94 a8 09 	call	0x1350	; 0x1350 <__divmodhi4>
     aaa:	76 87       	std	Z+14, r23	; 0x0e
     aac:	65 87       	std	Z+13, r22	; 0x0d
			break;
     aae:	08 95       	ret
			case 0b01:  // Andre kvadrant (x < 0, y >= 0)
			board->JoyAngle = 90 + ((-x * 90) / (-x + y));
     ab0:	26 ea       	ldi	r18, 0xA6	; 166
     ab2:	26 03       	mulsu	r18, r22
     ab4:	c0 01       	movw	r24, r0
     ab6:	27 9f       	mul	r18, r23
     ab8:	90 0d       	add	r25, r0
     aba:	11 24       	eor	r1, r1
     abc:	9a 01       	movw	r18, r20
     abe:	26 1b       	sub	r18, r22
     ac0:	37 0b       	sbc	r19, r23
     ac2:	b9 01       	movw	r22, r18
     ac4:	0e 94 a8 09 	call	0x1350	; 0x1350 <__divmodhi4>
     ac8:	66 5a       	subi	r22, 0xA6	; 166
     aca:	7f 4f       	sbci	r23, 0xFF	; 255
     acc:	76 87       	std	Z+14, r23	; 0x0e
     ace:	65 87       	std	Z+13, r22	; 0x0d
			break;
     ad0:	08 95       	ret
			case 0b00:  // Tredje kvadrant (x < 0, y < 0)
			board->JoyAngle = 180 + ((-y * 90) / (-x - y));
     ad2:	26 ea       	ldi	r18, 0xA6	; 166
     ad4:	24 03       	mulsu	r18, r20
     ad6:	c0 01       	movw	r24, r0
     ad8:	25 9f       	mul	r18, r21
     ada:	90 0d       	add	r25, r0
     adc:	11 24       	eor	r1, r1
     ade:	71 95       	neg	r23
     ae0:	61 95       	neg	r22
     ae2:	71 09       	sbc	r23, r1
     ae4:	64 1b       	sub	r22, r20
     ae6:	75 0b       	sbc	r23, r21
     ae8:	0e 94 a8 09 	call	0x1350	; 0x1350 <__divmodhi4>
     aec:	6c 54       	subi	r22, 0x4C	; 76
     aee:	7f 4f       	sbci	r23, 0xFF	; 255
     af0:	76 87       	std	Z+14, r23	; 0x0e
     af2:	65 87       	std	Z+13, r22	; 0x0d
			break;
     af4:	08 95       	ret
			case 0b10:  // Fjerde kvadrant (x >= 0, y < 0)
			board->JoyAngle = 270 + ((x * 90) / (x - y));
     af6:	2a e5       	ldi	r18, 0x5A	; 90
     af8:	26 9f       	mul	r18, r22
     afa:	c0 01       	movw	r24, r0
     afc:	27 9f       	mul	r18, r23
     afe:	90 0d       	add	r25, r0
     b00:	11 24       	eor	r1, r1
     b02:	64 1b       	sub	r22, r20
     b04:	75 0b       	sbc	r23, r21
     b06:	0e 94 a8 09 	call	0x1350	; 0x1350 <__divmodhi4>
     b0a:	62 5f       	subi	r22, 0xF2	; 242
     b0c:	7e 4f       	sbci	r23, 0xFE	; 254
     b0e:	76 87       	std	Z+14, r23	; 0x0e
     b10:	65 87       	std	Z+13, r22	; 0x0d
			break;
     b12:	08 95       	ret
			default:
			board->JoyAngle = 0;  // Feiltilfelle, skal ikkje skje
     b14:	16 86       	std	Z+14, r1	; 0x0e
     b16:	15 86       	std	Z+13, r1	; 0x0d
     b18:	08 95       	ret

00000b1a <MultiBoard_Update>:
	board->JoyAngle = 0;
	board->JoyBtn = 0;  // Endra fra en, vi bruker fortsatt 0 for av basert pÃ¥ logikk i MB_Update()
}


void MultiBoard_Update(MultiBoard* board) {
     b1a:	cf 93       	push	r28
     b1c:	df 93       	push	r29
     b1e:	ec 01       	movw	r28, r24
	// Velg kanal for venstre skyvebryter (LSpos)
	Universal_write(ADC_START, 0x00);
     b20:	60 e0       	ldi	r22, 0x00	; 0
     b22:	80 e0       	ldi	r24, 0x00	; 0
     b24:	94 e1       	ldi	r25, 0x14	; 20
     b26:	0e 94 88 09 	call	0x1310	; 0x1310 <Universal_write>
	loopUntilBitIsClear(PINB, BUSY_PIN);		// Vent til BUSY gï¿½r lav - klar for ï¿½ sende pï¿½ ny
     b2a:	b1 99       	sbic	0x16, 1	; 22
     b2c:	fe cf       	rjmp	.-4      	; 0xb2a <MultiBoard_Update+0x10>
	board->JoyYpos = Universal_read(ADC_START); //  - CH0 fï¿½rste RD low gir channel 0
     b2e:	80 e0       	ldi	r24, 0x00	; 0
     b30:	94 e1       	ldi	r25, 0x14	; 20
     b32:	0e 94 98 09 	call	0x1330	; 0x1330 <Universal_read>
     b36:	88 83       	st	Y, r24
	board->JoyXpos = Universal_read(ADC_START); //	- CH1 andre RD low gir channel 1
     b38:	80 e0       	ldi	r24, 0x00	; 0
     b3a:	94 e1       	ldi	r25, 0x14	; 20
     b3c:	0e 94 98 09 	call	0x1330	; 0x1330 <Universal_read>
     b40:	89 83       	std	Y+1, r24	; 0x01
	board->RSpos = Universal_read(ADC_START);	//	- CH2
     b42:	80 e0       	ldi	r24, 0x00	; 0
     b44:	94 e1       	ldi	r25, 0x14	; 20
     b46:	0e 94 98 09 	call	0x1330	; 0x1330 <Universal_read>
     b4a:	8b 83       	std	Y+3, r24	; 0x03
	board->LSpos = Universal_read(ADC_START);	//	- CH3
     b4c:	80 e0       	ldi	r24, 0x00	; 0
     b4e:	94 e1       	ldi	r25, 0x14	; 20
     b50:	0e 94 98 09 	call	0x1330	; 0x1330 <Universal_read>
     b54:	8a 83       	std	Y+2, r24	; 0x02
	// Les knappestatus
	board->LBtn = 0<testBit(PINB, LEFT_BUTTON_PIN);
     b56:	81 e0       	ldi	r24, 0x01	; 1
     b58:	b4 9b       	sbis	0x16, 4	; 22
     b5a:	80 e0       	ldi	r24, 0x00	; 0
     b5c:	8c 83       	std	Y+4, r24	; 0x04
	board->RBtn = 0<testBit(PINB, RIGHT_BUTTON_PIN);
     b5e:	81 e0       	ldi	r24, 0x01	; 1
     b60:	b3 9b       	sbis	0x16, 3	; 22
     b62:	80 e0       	ldi	r24, 0x00	; 0
     b64:	8d 83       	std	Y+5, r24	; 0x05
	board->JoyBtn = !(0<testBit(PINB, JOY_BUTTON_PIN));
     b66:	81 e0       	ldi	r24, 0x01	; 1
     b68:	b2 99       	sbic	0x16, 2	; 22
     b6a:	80 e0       	ldi	r24, 0x00	; 0
     b6c:	8e 83       	std	Y+6, r24	; 0x06
	// Opretter ein int med pluss og minus slik at vi kan finne riktig vinkel med _UpdateJoystickAngel
	board->JoyYposCal = (int16_t)(board->JoyYpos) - (int16_t)(board->JoyYOrigo);
     b6e:	88 81       	ld	r24, Y
     b70:	90 e0       	ldi	r25, 0x00	; 0
     b72:	28 85       	ldd	r18, Y+8	; 0x08
     b74:	82 1b       	sub	r24, r18
     b76:	91 09       	sbc	r25, r1
     b78:	9c 87       	std	Y+12, r25	; 0x0c
     b7a:	8b 87       	std	Y+11, r24	; 0x0b
	board->JoyXposCal = (int16_t)(board->JoyXpos) - (int16_t)(board->JoyXOrigo);
     b7c:	89 81       	ldd	r24, Y+1	; 0x01
     b7e:	90 e0       	ldi	r25, 0x00	; 0
     b80:	2f 81       	ldd	r18, Y+7	; 0x07
     b82:	82 1b       	sub	r24, r18
     b84:	91 09       	sbc	r25, r1
     b86:	9a 87       	std	Y+10, r25	; 0x0a
     b88:	89 87       	std	Y+9, r24	; 0x09
	///IKKJE TESTA
	MultiBoard_UpdateJoystickAngle(board);
     b8a:	ce 01       	movw	r24, r28
     b8c:	0e 94 20 05 	call	0xa40	; 0xa40 <MultiBoard_UpdateJoystickAngle>
}
     b90:	df 91       	pop	r29
     b92:	cf 91       	pop	r28
     b94:	08 95       	ret

00000b96 <oled_write_command>:
	// Gå gjennom hele bufferet og skriv til SRAM
	for (uint16_t i = 0; i < 1024; i++) {
		// Skriv hver byte fra bufferet til SRAM
		SRAM_write(sram_address + i, screen_1024[i]);
	}
}
     b96:	68 2f       	mov	r22, r24
     b98:	80 e0       	ldi	r24, 0x00	; 0
     b9a:	90 e0       	ldi	r25, 0x00	; 0
     b9c:	0e 94 88 09 	call	0x1310	; 0x1310 <Universal_write>
     ba0:	08 95       	ret

00000ba2 <oled_write_data>:
     ba2:	ef 92       	push	r14
     ba4:	ff 92       	push	r15
     ba6:	0f 93       	push	r16
     ba8:	1f 93       	push	r17
     baa:	cf 93       	push	r28
     bac:	df 93       	push	r29
     bae:	61 15       	cp	r22, r1
     bb0:	71 05       	cpc	r23, r1
     bb2:	81 f0       	breq	.+32     	; 0xbd4 <oled_write_data+0x32>
     bb4:	7c 01       	movw	r14, r24
     bb6:	8c 01       	movw	r16, r24
     bb8:	e6 0e       	add	r14, r22
     bba:	f7 1e       	adc	r15, r23
     bbc:	c0 e0       	ldi	r28, 0x00	; 0
     bbe:	d2 e0       	ldi	r29, 0x02	; 2
     bc0:	f8 01       	movw	r30, r16
     bc2:	61 91       	ld	r22, Z+
     bc4:	8f 01       	movw	r16, r30
     bc6:	ce 01       	movw	r24, r28
     bc8:	0e 94 88 09 	call	0x1310	; 0x1310 <Universal_write>
     bcc:	21 96       	adiw	r28, 0x01	; 1
     bce:	0e 15       	cp	r16, r14
     bd0:	1f 05       	cpc	r17, r15
     bd2:	b1 f7       	brne	.-20     	; 0xbc0 <oled_write_data+0x1e>
     bd4:	df 91       	pop	r29
     bd6:	cf 91       	pop	r28
     bd8:	1f 91       	pop	r17
     bda:	0f 91       	pop	r16
     bdc:	ff 90       	pop	r15
     bde:	ef 90       	pop	r14
     be0:	08 95       	ret

00000be2 <oled_set_page>:
     be2:	87 70       	andi	r24, 0x07	; 7
     be4:	80 6b       	ori	r24, 0xB0	; 176
     be6:	0e 94 cb 05 	call	0xb96	; 0xb96 <oled_write_command>
     bea:	08 95       	ret

00000bec <oled_set_column>:
     bec:	cf 93       	push	r28
     bee:	c8 2f       	mov	r28, r24
     bf0:	82 95       	swap	r24
     bf2:	8f 70       	andi	r24, 0x0F	; 15
     bf4:	80 61       	ori	r24, 0x10	; 16
     bf6:	0e 94 cb 05 	call	0xb96	; 0xb96 <oled_write_command>
     bfa:	8c 2f       	mov	r24, r28
     bfc:	8f 70       	andi	r24, 0x0F	; 15
     bfe:	0e 94 cb 05 	call	0xb96	; 0xb96 <oled_write_command>
     c02:	cf 91       	pop	r28
     c04:	08 95       	ret

00000c06 <oled_home>:
     c06:	80 e0       	ldi	r24, 0x00	; 0
     c08:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <oled_set_page>
     c0c:	80 e0       	ldi	r24, 0x00	; 0
     c0e:	0e 94 f6 05 	call	0xbec	; 0xbec <oled_set_column>
     c12:	08 95       	ret

00000c14 <oled_init>:
     c14:	8e ea       	ldi	r24, 0xAE	; 174
     c16:	0e 94 cb 05 	call	0xb96	; 0xb96 <oled_write_command>
     c1a:	81 ea       	ldi	r24, 0xA1	; 161
     c1c:	0e 94 cb 05 	call	0xb96	; 0xb96 <oled_write_command>
     c20:	8a ed       	ldi	r24, 0xDA	; 218
     c22:	0e 94 cb 05 	call	0xb96	; 0xb96 <oled_write_command>
     c26:	82 e1       	ldi	r24, 0x12	; 18
     c28:	0e 94 cb 05 	call	0xb96	; 0xb96 <oled_write_command>
     c2c:	88 ec       	ldi	r24, 0xC8	; 200
     c2e:	0e 94 cb 05 	call	0xb96	; 0xb96 <oled_write_command>
     c32:	88 ea       	ldi	r24, 0xA8	; 168
     c34:	0e 94 cb 05 	call	0xb96	; 0xb96 <oled_write_command>
     c38:	8f e3       	ldi	r24, 0x3F	; 63
     c3a:	0e 94 cb 05 	call	0xb96	; 0xb96 <oled_write_command>
     c3e:	85 ed       	ldi	r24, 0xD5	; 213
     c40:	0e 94 cb 05 	call	0xb96	; 0xb96 <oled_write_command>
     c44:	80 e8       	ldi	r24, 0x80	; 128
     c46:	0e 94 cb 05 	call	0xb96	; 0xb96 <oled_write_command>
     c4a:	81 e8       	ldi	r24, 0x81	; 129
     c4c:	0e 94 cb 05 	call	0xb96	; 0xb96 <oled_write_command>
     c50:	80 e5       	ldi	r24, 0x50	; 80
     c52:	0e 94 cb 05 	call	0xb96	; 0xb96 <oled_write_command>
     c56:	89 ed       	ldi	r24, 0xD9	; 217
     c58:	0e 94 cb 05 	call	0xb96	; 0xb96 <oled_write_command>
     c5c:	81 e2       	ldi	r24, 0x21	; 33
     c5e:	0e 94 cb 05 	call	0xb96	; 0xb96 <oled_write_command>
     c62:	80 e2       	ldi	r24, 0x20	; 32
     c64:	0e 94 cb 05 	call	0xb96	; 0xb96 <oled_write_command>
     c68:	82 e0       	ldi	r24, 0x02	; 2
     c6a:	0e 94 cb 05 	call	0xb96	; 0xb96 <oled_write_command>
     c6e:	8b ed       	ldi	r24, 0xDB	; 219
     c70:	0e 94 cb 05 	call	0xb96	; 0xb96 <oled_write_command>
     c74:	80 e3       	ldi	r24, 0x30	; 48
     c76:	0e 94 cb 05 	call	0xb96	; 0xb96 <oled_write_command>
     c7a:	8d ea       	ldi	r24, 0xAD	; 173
     c7c:	0e 94 cb 05 	call	0xb96	; 0xb96 <oled_write_command>
     c80:	80 e0       	ldi	r24, 0x00	; 0
     c82:	0e 94 cb 05 	call	0xb96	; 0xb96 <oled_write_command>
     c86:	84 ea       	ldi	r24, 0xA4	; 164
     c88:	0e 94 cb 05 	call	0xb96	; 0xb96 <oled_write_command>
     c8c:	86 ea       	ldi	r24, 0xA6	; 166
     c8e:	0e 94 cb 05 	call	0xb96	; 0xb96 <oled_write_command>
     c92:	8f ea       	ldi	r24, 0xAF	; 175
     c94:	0e 94 cb 05 	call	0xb96	; 0xb96 <oled_write_command>
     c98:	08 95       	ret

00000c9a <oled_data_from_SRAM>:
     c9a:	8f 92       	push	r8
     c9c:	9f 92       	push	r9
     c9e:	bf 92       	push	r11
     ca0:	cf 92       	push	r12
     ca2:	df 92       	push	r13
     ca4:	ef 92       	push	r14
     ca6:	ff 92       	push	r15
     ca8:	0f 93       	push	r16
     caa:	1f 93       	push	r17
     cac:	cf 93       	push	r28
     cae:	df 93       	push	r29
     cb0:	cd b7       	in	r28, 0x3d	; 61
     cb2:	de b7       	in	r29, 0x3e	; 62
     cb4:	c0 58       	subi	r28, 0x80	; 128
     cb6:	d1 09       	sbc	r29, r1
     cb8:	0f b6       	in	r0, 0x3f	; 63
     cba:	f8 94       	cli
     cbc:	de bf       	out	0x3e, r29	; 62
     cbe:	0f be       	out	0x3f, r0	; 63
     cc0:	cd bf       	out	0x3d, r28	; 61
     cc2:	ce 01       	movw	r24, r28
     cc4:	01 96       	adiw	r24, 0x01	; 1
     cc6:	4c 01       	movw	r8, r24
     cc8:	ee 24       	eor	r14, r14
     cca:	ff 24       	eor	r15, r15
     ccc:	e8 1a       	sub	r14, r24
     cce:	f9 0a       	sbc	r15, r25
     cd0:	b1 2c       	mov	r11, r1
     cd2:	6e 01       	movw	r12, r28
     cd4:	91 e8       	ldi	r25, 0x81	; 129
     cd6:	c9 0e       	add	r12, r25
     cd8:	d1 1c       	adc	r13, r1
     cda:	8b 2d       	mov	r24, r11
     cdc:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <oled_set_page>
     ce0:	80 e0       	ldi	r24, 0x00	; 0
     ce2:	0e 94 f6 05 	call	0xbec	; 0xbec <oled_set_column>
     ce6:	84 01       	movw	r16, r8
     ce8:	c8 01       	movw	r24, r16
     cea:	8e 0d       	add	r24, r14
     cec:	9f 1d       	adc	r25, r15
     cee:	0e 94 78 09 	call	0x12f0	; 0x12f0 <SRAM_read>
     cf2:	f8 01       	movw	r30, r16
     cf4:	81 93       	st	Z+, r24
     cf6:	8f 01       	movw	r16, r30
     cf8:	ec 15       	cp	r30, r12
     cfa:	fd 05       	cpc	r31, r13
     cfc:	a9 f7       	brne	.-22     	; 0xce8 <oled_data_from_SRAM+0x4e>
     cfe:	60 e8       	ldi	r22, 0x80	; 128
     d00:	70 e0       	ldi	r23, 0x00	; 0
     d02:	ce 01       	movw	r24, r28
     d04:	01 96       	adiw	r24, 0x01	; 1
     d06:	0e 94 d1 05 	call	0xba2	; 0xba2 <oled_write_data>
     d0a:	b3 94       	inc	r11
     d0c:	f0 e8       	ldi	r31, 0x80	; 128
     d0e:	ef 0e       	add	r14, r31
     d10:	f1 1c       	adc	r15, r1
     d12:	88 e0       	ldi	r24, 0x08	; 8
     d14:	b8 12       	cpse	r11, r24
     d16:	e1 cf       	rjmp	.-62     	; 0xcda <oled_data_from_SRAM+0x40>
     d18:	c0 58       	subi	r28, 0x80	; 128
     d1a:	df 4f       	sbci	r29, 0xFF	; 255
     d1c:	0f b6       	in	r0, 0x3f	; 63
     d1e:	f8 94       	cli
     d20:	de bf       	out	0x3e, r29	; 62
     d22:	0f be       	out	0x3f, r0	; 63
     d24:	cd bf       	out	0x3d, r28	; 61
     d26:	df 91       	pop	r29
     d28:	cf 91       	pop	r28
     d2a:	1f 91       	pop	r17
     d2c:	0f 91       	pop	r16
     d2e:	ff 90       	pop	r15
     d30:	ef 90       	pop	r14
     d32:	df 90       	pop	r13
     d34:	cf 90       	pop	r12
     d36:	bf 90       	pop	r11
     d38:	9f 90       	pop	r9
     d3a:	8f 90       	pop	r8
     d3c:	08 95       	ret

00000d3e <oled_write_screen_to_SRAM>:
     d3e:	8f 92       	push	r8
     d40:	9f 92       	push	r9
     d42:	af 92       	push	r10
     d44:	bf 92       	push	r11
     d46:	cf 92       	push	r12
     d48:	df 92       	push	r13
     d4a:	ef 92       	push	r14
     d4c:	ff 92       	push	r15
     d4e:	0f 93       	push	r16
     d50:	1f 93       	push	r17
     d52:	cf 93       	push	r28
     d54:	df 93       	push	r29
     d56:	5c 01       	movw	r10, r24
     d58:	00 e0       	ldi	r16, 0x00	; 0
     d5a:	10 e0       	ldi	r17, 0x00	; 0
     d5c:	0f 2e       	mov	r0, r31
     d5e:	f0 e7       	ldi	r31, 0x70	; 112
     d60:	8f 2e       	mov	r8, r31
     d62:	f0 e0       	ldi	r31, 0x00	; 0
     d64:	9f 2e       	mov	r9, r31
     d66:	f0 2d       	mov	r31, r0
     d68:	0f 2e       	mov	r0, r31
     d6a:	f8 e7       	ldi	r31, 0x78	; 120
     d6c:	cf 2e       	mov	r12, r31
     d6e:	f0 e0       	ldi	r31, 0x00	; 0
     d70:	df 2e       	mov	r13, r31
     d72:	f0 2d       	mov	r31, r0
     d74:	d5 01       	movw	r26, r10
     d76:	8d 91       	ld	r24, X+
     d78:	5d 01       	movw	r10, r26
     d7a:	80 52       	subi	r24, 0x20	; 32
     d7c:	80 36       	cpi	r24, 0x60	; 96
     d7e:	f8 f4       	brcc	.+62     	; 0xdbe <oled_write_screen_to_SRAM+0x80>
     d80:	c0 e0       	ldi	r28, 0x00	; 0
     d82:	d0 e0       	ldi	r29, 0x00	; 0
     d84:	7d 01       	movw	r14, r26
     d86:	b1 e0       	ldi	r27, 0x01	; 1
     d88:	eb 1a       	sub	r14, r27
     d8a:	f1 08       	sbc	r15, r1
     d8c:	d7 01       	movw	r26, r14
     d8e:	ec 91       	ld	r30, X
     d90:	f0 e0       	ldi	r31, 0x00	; 0
     d92:	b0 97       	sbiw	r30, 0x20	; 32
     d94:	ee 0f       	add	r30, r30
     d96:	ff 1f       	adc	r31, r31
     d98:	ee 0f       	add	r30, r30
     d9a:	ff 1f       	adc	r31, r31
     d9c:	ee 0f       	add	r30, r30
     d9e:	ff 1f       	adc	r31, r31
     da0:	ec 0f       	add	r30, r28
     da2:	fd 1f       	adc	r31, r29
     da4:	e0 59       	subi	r30, 0x90	; 144
     da6:	ff 4f       	sbci	r31, 0xFF	; 255
     da8:	64 91       	lpm	r22, Z
     daa:	ce 01       	movw	r24, r28
     dac:	80 0f       	add	r24, r16
     dae:	91 1f       	adc	r25, r17
     db0:	0e 94 68 09 	call	0x12d0	; 0x12d0 <SRAM_write>
     db4:	21 96       	adiw	r28, 0x01	; 1
     db6:	c8 30       	cpi	r28, 0x08	; 8
     db8:	d1 05       	cpc	r29, r1
     dba:	41 f7       	brne	.-48     	; 0xd8c <oled_write_screen_to_SRAM+0x4e>
     dbc:	10 c0       	rjmp	.+32     	; 0xdde <oled_write_screen_to_SRAM+0xa0>
     dbe:	c0 e7       	ldi	r28, 0x70	; 112
     dc0:	d0 e0       	ldi	r29, 0x00	; 0
     dc2:	78 01       	movw	r14, r16
     dc4:	e8 18       	sub	r14, r8
     dc6:	f9 08       	sbc	r15, r9
     dc8:	fe 01       	movw	r30, r28
     dca:	64 91       	lpm	r22, Z
     dcc:	c7 01       	movw	r24, r14
     dce:	8c 0f       	add	r24, r28
     dd0:	9d 1f       	adc	r25, r29
     dd2:	0e 94 68 09 	call	0x12d0	; 0x12d0 <SRAM_write>
     dd6:	21 96       	adiw	r28, 0x01	; 1
     dd8:	cc 16       	cp	r12, r28
     dda:	dd 06       	cpc	r13, r29
     ddc:	a9 f7       	brne	.-22     	; 0xdc8 <oled_write_screen_to_SRAM+0x8a>
     dde:	08 5f       	subi	r16, 0xF8	; 248
     de0:	1f 4f       	sbci	r17, 0xFF	; 255
     de2:	01 15       	cp	r16, r1
     de4:	f4 e0       	ldi	r31, 0x04	; 4
     de6:	1f 07       	cpc	r17, r31
     de8:	09 f0       	breq	.+2      	; 0xdec <oled_write_screen_to_SRAM+0xae>
     dea:	c4 cf       	rjmp	.-120    	; 0xd74 <oled_write_screen_to_SRAM+0x36>
     dec:	df 91       	pop	r29
     dee:	cf 91       	pop	r28
     df0:	1f 91       	pop	r17
     df2:	0f 91       	pop	r16
     df4:	ff 90       	pop	r15
     df6:	ef 90       	pop	r14
     df8:	df 90       	pop	r13
     dfa:	cf 90       	pop	r12
     dfc:	bf 90       	pop	r11
     dfe:	af 90       	pop	r10
     e00:	9f 90       	pop	r9
     e02:	8f 90       	pop	r8
     e04:	08 95       	ret

00000e06 <oled_write_line_to_SRAM>:
void oled_write_line_to_SRAM(uint8_t line, const char* data) {
     e06:	8f 92       	push	r8
     e08:	9f 92       	push	r9
     e0a:	bf 92       	push	r11
     e0c:	cf 92       	push	r12
     e0e:	df 92       	push	r13
     e10:	ef 92       	push	r14
     e12:	ff 92       	push	r15
     e14:	0f 93       	push	r16
     e16:	1f 93       	push	r17
     e18:	cf 93       	push	r28
     e1a:	df 93       	push	r29
	if (line >= 8) {
     e1c:	88 30       	cpi	r24, 0x08	; 8
     e1e:	08 f0       	brcs	.+2      	; 0xe22 <oled_write_line_to_SRAM+0x1c>
     e20:	5e c0       	rjmp	.+188    	; 0xede <oled_write_line_to_SRAM+0xd8>
     e22:	fb 01       	movw	r30, r22
		return; 
	}
	uint8_t max_chars_per_line = 16;
	uint16_t sram_address = line * 128;  // Hver linje er 128 bytes, 16 karakterer à 8 pixels
     e24:	90 e8       	ldi	r25, 0x80	; 128
     e26:	89 9f       	mul	r24, r25
     e28:	60 01       	movw	r12, r0
     e2a:	11 24       	eor	r1, r1
	uint8_t i = 0; // så den ikkje døyr når vi går ut av forloopen (brukast igjen)
	// Skriv karakterene til SRAM, men ikke mer enn 16
	for (; i < max_chars_per_line; i++) {
		if (data[i] == '\0') {
     e2c:	80 81       	ld	r24, Z
     e2e:	88 23       	and	r24, r24
     e30:	09 f4       	brne	.+2      	; 0xe34 <oled_write_line_to_SRAM+0x2e>
     e32:	47 c0       	rjmp	.+142    	; 0xec2 <oled_write_line_to_SRAM+0xbc>
     e34:	76 01       	movw	r14, r12
     e36:	8b 01       	movw	r16, r22
     e38:	b1 2c       	mov	r11, r1
     e3a:	0a c0       	rjmp	.+20     	; 0xe50 <oled_write_line_to_SRAM+0x4a>
     e3c:	0f 5f       	subi	r16, 0xFF	; 255
     e3e:	1f 4f       	sbci	r17, 0xFF	; 255
     e40:	a8 e0       	ldi	r26, 0x08	; 8
     e42:	ea 0e       	add	r14, r26
     e44:	f1 1c       	adc	r15, r1
     e46:	f8 01       	movw	r30, r16
     e48:	80 81       	ld	r24, Z
     e4a:	88 23       	and	r24, r24
     e4c:	09 f4       	brne	.+2      	; 0xe50 <oled_write_line_to_SRAM+0x4a>
     e4e:	3a c0       	rjmp	.+116    	; 0xec4 <oled_write_line_to_SRAM+0xbe>
     e50:	c0 e0       	ldi	r28, 0x00	; 0
     e52:	d0 e0       	ldi	r29, 0x00	; 0
			break;  // Avslutt hvis vi når slutten av data
		}
		for (uint8_t j = 0; j < 8; j++) {
			SRAM_write(sram_address + (i * 8) + j, pgm_read_byte(&font8x8_basic[(data[i] - 32) * 8 + j]));
     e54:	d8 01       	movw	r26, r16
     e56:	ec 91       	ld	r30, X
     e58:	f0 e0       	ldi	r31, 0x00	; 0
     e5a:	b0 97       	sbiw	r30, 0x20	; 32
     e5c:	ee 0f       	add	r30, r30
     e5e:	ff 1f       	adc	r31, r31
     e60:	ee 0f       	add	r30, r30
     e62:	ff 1f       	adc	r31, r31
     e64:	ee 0f       	add	r30, r30
     e66:	ff 1f       	adc	r31, r31
     e68:	ec 0f       	add	r30, r28
     e6a:	fd 1f       	adc	r31, r29
     e6c:	e0 59       	subi	r30, 0x90	; 144
     e6e:	ff 4f       	sbci	r31, 0xFF	; 255
     e70:	64 91       	lpm	r22, Z
     e72:	c7 01       	movw	r24, r14
     e74:	8c 0f       	add	r24, r28
     e76:	9d 1f       	adc	r25, r29
     e78:	0e 94 68 09 	call	0x12d0	; 0x12d0 <SRAM_write>
     e7c:	21 96       	adiw	r28, 0x01	; 1
	// Skriv karakterene til SRAM, men ikke mer enn 16
	for (; i < max_chars_per_line; i++) {
		if (data[i] == '\0') {
			break;  // Avslutt hvis vi når slutten av data
		}
		for (uint8_t j = 0; j < 8; j++) {
     e7e:	c8 30       	cpi	r28, 0x08	; 8
     e80:	d1 05       	cpc	r29, r1
     e82:	41 f7       	brne	.-48     	; 0xe54 <oled_write_line_to_SRAM+0x4e>
	}
	uint8_t max_chars_per_line = 16;
	uint16_t sram_address = line * 128;  // Hver linje er 128 bytes, 16 karakterer à 8 pixels
	uint8_t i = 0; // så den ikkje døyr når vi går ut av forloopen (brukast igjen)
	// Skriv karakterene til SRAM, men ikke mer enn 16
	for (; i < max_chars_per_line; i++) {
     e84:	b3 94       	inc	r11
     e86:	b0 e1       	ldi	r27, 0x10	; 16
     e88:	bb 12       	cpse	r11, r27
     e8a:	d8 cf       	rjmp	.-80     	; 0xe3c <oled_write_line_to_SRAM+0x36>
     e8c:	28 c0       	rjmp	.+80     	; 0xede <oled_write_line_to_SRAM+0xd8>
		}
	}
	// Fyll resten av linjen med tomrom (mellomrom) etter slutten av data
	for (; i < max_chars_per_line; i++) {
		for (uint8_t j = 0; j < 8; j++) {
			SRAM_write(sram_address + (i * 8) + j, pgm_read_byte(&font8x8_basic[(' ' - 32) * 8 + j]));
     e8e:	fe 01       	movw	r30, r28
     e90:	64 91       	lpm	r22, Z
     e92:	c8 01       	movw	r24, r16
     e94:	8c 0f       	add	r24, r28
     e96:	9d 1f       	adc	r25, r29
     e98:	0e 94 68 09 	call	0x12d0	; 0x12d0 <SRAM_write>
     e9c:	21 96       	adiw	r28, 0x01	; 1
			SRAM_write(sram_address + (i * 8) + j, pgm_read_byte(&font8x8_basic[(data[i] - 32) * 8 + j]));
		}
	}
	// Fyll resten av linjen med tomrom (mellomrom) etter slutten av data
	for (; i < max_chars_per_line; i++) {
		for (uint8_t j = 0; j < 8; j++) {
     e9e:	ce 15       	cp	r28, r14
     ea0:	df 05       	cpc	r29, r15
     ea2:	a9 f7       	brne	.-22     	; 0xe8e <oled_write_line_to_SRAM+0x88>
		for (uint8_t j = 0; j < 8; j++) {
			SRAM_write(sram_address + (i * 8) + j, pgm_read_byte(&font8x8_basic[(data[i] - 32) * 8 + j]));
		}
	}
	// Fyll resten av linjen med tomrom (mellomrom) etter slutten av data
	for (; i < max_chars_per_line; i++) {
     ea4:	b3 94       	inc	r11
     ea6:	ff e0       	ldi	r31, 0x0F	; 15
     ea8:	fb 15       	cp	r31, r11
     eaa:	c8 f0       	brcs	.+50     	; 0xede <oled_write_line_to_SRAM+0xd8>
		for (uint8_t j = 0; j < 8; j++) {
			SRAM_write(sram_address + (i * 8) + j, pgm_read_byte(&font8x8_basic[(' ' - 32) * 8 + j]));
     eac:	c0 e7       	ldi	r28, 0x70	; 112
     eae:	d0 e0       	ldi	r29, 0x00	; 0
     eb0:	86 01       	movw	r16, r12
     eb2:	88 e0       	ldi	r24, 0x08	; 8
     eb4:	b8 9e       	mul	r11, r24
     eb6:	00 0d       	add	r16, r0
     eb8:	11 1d       	adc	r17, r1
     eba:	11 24       	eor	r1, r1
     ebc:	08 19       	sub	r16, r8
     ebe:	19 09       	sbc	r17, r9
     ec0:	e6 cf       	rjmp	.-52     	; 0xe8e <oled_write_line_to_SRAM+0x88>
	if (line >= 8) {
		return; 
	}
	uint8_t max_chars_per_line = 16;
	uint16_t sram_address = line * 128;  // Hver linje er 128 bytes, 16 karakterer à 8 pixels
	uint8_t i = 0; // så den ikkje døyr når vi går ut av forloopen (brukast igjen)
     ec2:	b1 2c       	mov	r11, r1
     ec4:	0f 2e       	mov	r0, r31
     ec6:	f0 e7       	ldi	r31, 0x70	; 112
     ec8:	8f 2e       	mov	r8, r31
     eca:	f0 e0       	ldi	r31, 0x00	; 0
     ecc:	9f 2e       	mov	r9, r31
     ece:	f0 2d       	mov	r31, r0
     ed0:	0f 2e       	mov	r0, r31
     ed2:	f8 e7       	ldi	r31, 0x78	; 120
     ed4:	ef 2e       	mov	r14, r31
     ed6:	f0 e0       	ldi	r31, 0x00	; 0
     ed8:	ff 2e       	mov	r15, r31
     eda:	f0 2d       	mov	r31, r0
     edc:	e7 cf       	rjmp	.-50     	; 0xeac <oled_write_line_to_SRAM+0xa6>
	for (; i < max_chars_per_line; i++) {
		for (uint8_t j = 0; j < 8; j++) {
			SRAM_write(sram_address + (i * 8) + j, pgm_read_byte(&font8x8_basic[(' ' - 32) * 8 + j]));
		}
	}
}
     ede:	df 91       	pop	r29
     ee0:	cf 91       	pop	r28
     ee2:	1f 91       	pop	r17
     ee4:	0f 91       	pop	r16
     ee6:	ff 90       	pop	r15
     ee8:	ef 90       	pop	r14
     eea:	df 90       	pop	r13
     eec:	cf 90       	pop	r12
     eee:	bf 90       	pop	r11
     ef0:	9f 90       	pop	r9
     ef2:	8f 90       	pop	r8
     ef4:	08 95       	ret

00000ef6 <oled_write_char_to_SRAM>:
//Nyttig for menyen trur eg, lar deg spesifisere nøyaktig kor på skjermen du vil overskrive
void oled_write_char_to_SRAM(uint8_t row, uint8_t col, char c) {
     ef6:	ef 92       	push	r14
     ef8:	ff 92       	push	r15
     efa:	0f 93       	push	r16
     efc:	1f 93       	push	r17
     efe:	cf 93       	push	r28
     f00:	df 93       	push	r29
	if (row >= 8 || col >= 16) {
     f02:	88 30       	cpi	r24, 0x08	; 8
     f04:	70 f5       	brcc	.+92     	; 0xf62 <oled_write_char_to_SRAM+0x6c>
     f06:	60 31       	cpi	r22, 0x10	; 16
     f08:	60 f5       	brcc	.+88     	; 0xf62 <oled_write_char_to_SRAM+0x6c>
     f0a:	28 2f       	mov	r18, r24
		return; 
	}
	uint16_t sram_address = row * 128 + (col * 8); 
     f0c:	86 2f       	mov	r24, r22
     f0e:	90 e0       	ldi	r25, 0x00	; 0
     f10:	30 e1       	ldi	r19, 0x10	; 16
     f12:	23 9f       	mul	r18, r19
     f14:	80 0d       	add	r24, r0
     f16:	91 1d       	adc	r25, r1
     f18:	11 24       	eor	r1, r1
     f1a:	88 0f       	add	r24, r24
     f1c:	99 1f       	adc	r25, r25
     f1e:	88 0f       	add	r24, r24
     f20:	99 1f       	adc	r25, r25
     f22:	88 0f       	add	r24, r24
     f24:	99 1f       	adc	r25, r25
	for (uint8_t i = 0; i < 8; i++) {
		SRAM_write(sram_address + i, pgm_read_byte(&font8x8_basic[(c - 32) * 8 + i]));
     f26:	04 2f       	mov	r16, r20
     f28:	10 e0       	ldi	r17, 0x00	; 0
     f2a:	00 52       	subi	r16, 0x20	; 32
     f2c:	11 09       	sbc	r17, r1
     f2e:	00 0f       	add	r16, r16
     f30:	11 1f       	adc	r17, r17
     f32:	00 0f       	add	r16, r16
     f34:	11 1f       	adc	r17, r17
     f36:	00 0f       	add	r16, r16
     f38:	11 1f       	adc	r17, r17
     f3a:	7c 01       	movw	r14, r24
     f3c:	28 e0       	ldi	r18, 0x08	; 8
     f3e:	e2 0e       	add	r14, r18
     f40:	f1 1c       	adc	r15, r1
     f42:	ec 01       	movw	r28, r24
     f44:	08 1b       	sub	r16, r24
     f46:	19 0b       	sbc	r17, r25
     f48:	f8 01       	movw	r30, r16
     f4a:	ec 0f       	add	r30, r28
     f4c:	fd 1f       	adc	r31, r29
     f4e:	e0 59       	subi	r30, 0x90	; 144
     f50:	ff 4f       	sbci	r31, 0xFF	; 255
     f52:	64 91       	lpm	r22, Z
     f54:	ce 01       	movw	r24, r28
     f56:	0e 94 68 09 	call	0x12d0	; 0x12d0 <SRAM_write>
     f5a:	21 96       	adiw	r28, 0x01	; 1
void oled_write_char_to_SRAM(uint8_t row, uint8_t col, char c) {
	if (row >= 8 || col >= 16) {
		return; 
	}
	uint16_t sram_address = row * 128 + (col * 8); 
	for (uint8_t i = 0; i < 8; i++) {
     f5c:	ce 15       	cp	r28, r14
     f5e:	df 05       	cpc	r29, r15
     f60:	99 f7       	brne	.-26     	; 0xf48 <oled_write_char_to_SRAM+0x52>
		SRAM_write(sram_address + i, pgm_read_byte(&font8x8_basic[(c - 32) * 8 + i]));
	}
}
     f62:	df 91       	pop	r29
     f64:	cf 91       	pop	r28
     f66:	1f 91       	pop	r17
     f68:	0f 91       	pop	r16
     f6a:	ff 90       	pop	r15
     f6c:	ef 90       	pop	r14
     f6e:	08 95       	ret

00000f70 <oled_write_pixel_to_SRAM>:

void oled_write_pixel_to_SRAM(uint8_t row, uint8_t col, uint8_t value) {
     f70:	0f 93       	push	r16
     f72:	1f 93       	push	r17
     f74:	cf 93       	push	r28
     f76:	df 93       	push	r29
	if (row >= 64 || col >= 128) {
     f78:	80 34       	cpi	r24, 0x40	; 64
     f7a:	48 f5       	brcc	.+82     	; 0xfce <oled_write_pixel_to_SRAM+0x5e>
     f7c:	66 23       	and	r22, r22
     f7e:	3c f1       	brlt	.+78     	; 0xfce <oled_write_pixel_to_SRAM+0x5e>
     f80:	04 2f       	mov	r16, r20
     f82:	18 2f       	mov	r17, r24
		return;
	}
	
	// Finn korrekt byte i SRAM for å justere pikslen
	uint16_t sram_address = (row / 8) * 128 + col;
     f84:	86 95       	lsr	r24
     f86:	86 95       	lsr	r24
     f88:	86 95       	lsr	r24
     f8a:	c6 2f       	mov	r28, r22
     f8c:	d0 e0       	ldi	r29, 0x00	; 0
     f8e:	90 e8       	ldi	r25, 0x80	; 128
     f90:	89 9f       	mul	r24, r25
     f92:	c0 0d       	add	r28, r0
     f94:	d1 1d       	adc	r29, r1
     f96:	11 24       	eor	r1, r1
	uint8_t current_byte = SRAM_read(sram_address);
     f98:	ce 01       	movw	r24, r28
     f9a:	0e 94 78 09 	call	0x12f0	; 0x12f0 <SRAM_read>
	uint8_t bit_position = row % 8;
     f9e:	17 70       	andi	r17, 0x07	; 7

	// Sett eller nullstill den ønskede biten
	if (value) {
     fa0:	00 23       	and	r16, r16
     fa2:	49 f0       	breq	.+18     	; 0xfb6 <oled_write_pixel_to_SRAM+0x46>
		current_byte |= (1 << bit_position);  // Sett bit til 1
     fa4:	61 e0       	ldi	r22, 0x01	; 1
     fa6:	70 e0       	ldi	r23, 0x00	; 0
     fa8:	02 c0       	rjmp	.+4      	; 0xfae <oled_write_pixel_to_SRAM+0x3e>
     faa:	66 0f       	add	r22, r22
     fac:	77 1f       	adc	r23, r23
     fae:	1a 95       	dec	r17
     fb0:	e2 f7       	brpl	.-8      	; 0xfaa <oled_write_pixel_to_SRAM+0x3a>
     fb2:	68 2b       	or	r22, r24
     fb4:	09 c0       	rjmp	.+18     	; 0xfc8 <oled_write_pixel_to_SRAM+0x58>
		} else {
		current_byte &= ~(1 << bit_position);  // Nullstill bit til 0
     fb6:	61 e0       	ldi	r22, 0x01	; 1
     fb8:	70 e0       	ldi	r23, 0x00	; 0
     fba:	02 c0       	rjmp	.+4      	; 0xfc0 <oled_write_pixel_to_SRAM+0x50>
     fbc:	66 0f       	add	r22, r22
     fbe:	77 1f       	adc	r23, r23
     fc0:	1a 95       	dec	r17
     fc2:	e2 f7       	brpl	.-8      	; 0xfbc <oled_write_pixel_to_SRAM+0x4c>
     fc4:	60 95       	com	r22
     fc6:	68 23       	and	r22, r24
	}
	
	SRAM_write(sram_address, current_byte);
     fc8:	ce 01       	movw	r24, r28
     fca:	0e 94 68 09 	call	0x12d0	; 0x12d0 <SRAM_write>
}
     fce:	df 91       	pop	r29
     fd0:	cf 91       	pop	r28
     fd2:	1f 91       	pop	r17
     fd4:	0f 91       	pop	r16
     fd6:	08 95       	ret

00000fd8 <oled_clear_screen>:

void oled_clear_screen(void) {
     fd8:	cf 93       	push	r28
     fda:	df 93       	push	r29
     fdc:	cd b7       	in	r28, 0x3d	; 61
     fde:	de b7       	in	r29, 0x3e	; 62
     fe0:	c0 58       	subi	r28, 0x80	; 128
     fe2:	d1 09       	sbc	r29, r1
     fe4:	0f b6       	in	r0, 0x3f	; 63
     fe6:	f8 94       	cli
     fe8:	de bf       	out	0x3e, r29	; 62
     fea:	0f be       	out	0x3f, r0	; 63
     fec:	cd bf       	out	0x3d, r28	; 61
	// Lag en tom buffer fylt med nuller eller mellomrom (0 er nok, fordi funksjonen oversetter til ' ')
	char empty_buffer[128] = {0};  // Heile skjermen, 128 tegn
     fee:	ce 01       	movw	r24, r28
     ff0:	01 96       	adiw	r24, 0x01	; 1
     ff2:	20 e8       	ldi	r18, 0x80	; 128
     ff4:	fc 01       	movw	r30, r24
     ff6:	11 92       	st	Z+, r1
     ff8:	2a 95       	dec	r18
     ffa:	e9 f7       	brne	.-6      	; 0xff6 <oled_clear_screen+0x1e>

	// Skriv den tomme bufferen til SRAM, som vil tømme skjermen
	oled_write_screen_to_SRAM(empty_buffer);
     ffc:	0e 94 9f 06 	call	0xd3e	; 0xd3e <oled_write_screen_to_SRAM>
}
    1000:	c0 58       	subi	r28, 0x80	; 128
    1002:	df 4f       	sbci	r29, 0xFF	; 255
    1004:	0f b6       	in	r0, 0x3f	; 63
    1006:	f8 94       	cli
    1008:	de bf       	out	0x3e, r29	; 62
    100a:	0f be       	out	0x3f, r0	; 63
    100c:	cd bf       	out	0x3d, r28	; 61
    100e:	df 91       	pop	r29
    1010:	cf 91       	pop	r28
    1012:	08 95       	ret

00001014 <oled_draw_line>:

void oled_draw_line(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1) {
    1014:	6f 92       	push	r6
    1016:	7f 92       	push	r7
    1018:	8f 92       	push	r8
    101a:	9f 92       	push	r9
    101c:	af 92       	push	r10
    101e:	bf 92       	push	r11
    1020:	cf 92       	push	r12
    1022:	df 92       	push	r13
    1024:	ef 92       	push	r14
    1026:	ff 92       	push	r15
    1028:	0f 93       	push	r16
    102a:	1f 93       	push	r17
    102c:	cf 93       	push	r28
    102e:	df 93       	push	r29
    1030:	c8 2f       	mov	r28, r24
    1032:	d6 2f       	mov	r29, r22
    1034:	94 2e       	mov	r9, r20
    1036:	62 2e       	mov	r6, r18
	int dx = abs(x1 - x0);
    1038:	84 2f       	mov	r24, r20
    103a:	90 e0       	ldi	r25, 0x00	; 0
    103c:	8c 1b       	sub	r24, r28
    103e:	91 09       	sbc	r25, r1
    1040:	7c 01       	movw	r14, r24
    1042:	22 f4       	brpl	.+8      	; 0x104c <oled_draw_line+0x38>
    1044:	ee 24       	eor	r14, r14
    1046:	ff 24       	eor	r15, r15
    1048:	e8 1a       	sub	r14, r24
    104a:	f9 0a       	sbc	r15, r25
	int dy = abs(y1 - y0);
    104c:	86 2d       	mov	r24, r6
    104e:	90 e0       	ldi	r25, 0x00	; 0
    1050:	8d 1b       	sub	r24, r29
    1052:	91 09       	sbc	r25, r1
    1054:	5c 01       	movw	r10, r24
    1056:	22 f4       	brpl	.+8      	; 0x1060 <oled_draw_line+0x4c>
    1058:	aa 24       	eor	r10, r10
    105a:	bb 24       	eor	r11, r11
    105c:	a8 1a       	sub	r10, r24
    105e:	b9 0a       	sbc	r11, r25
	int sx = (x0 < x1) ? 1 : -1;
    1060:	c9 15       	cp	r28, r9
    1062:	18 f0       	brcs	.+6      	; 0x106a <oled_draw_line+0x56>
    1064:	88 24       	eor	r8, r8
    1066:	8a 94       	dec	r8
    1068:	02 c0       	rjmp	.+4      	; 0x106e <oled_draw_line+0x5a>
    106a:	88 24       	eor	r8, r8
    106c:	83 94       	inc	r8
	int sy = (y0 < y1) ? 1 : -1;
    106e:	d6 15       	cp	r29, r6
    1070:	18 f0       	brcs	.+6      	; 0x1078 <oled_draw_line+0x64>
    1072:	77 24       	eor	r7, r7
    1074:	7a 94       	dec	r7
    1076:	02 c0       	rjmp	.+4      	; 0x107c <oled_draw_line+0x68>
    1078:	77 24       	eor	r7, r7
    107a:	73 94       	inc	r7
	int err = dx - dy;
    107c:	87 01       	movw	r16, r14
    107e:	0a 19       	sub	r16, r10
    1080:	1b 09       	sbc	r17, r11
	while (1) {
		oled_write_pixel_to_SRAM(y0, x0, 1);  // Tegn piksel

		if (x0 == x1 && y0 == y1) break;
		int e2 = 2 * err;
		if (e2 > -dy) {
    1082:	cc 24       	eor	r12, r12
    1084:	dd 24       	eor	r13, r13
    1086:	ca 18       	sub	r12, r10
    1088:	db 08       	sbc	r13, r11
	int sx = (x0 < x1) ? 1 : -1;
	int sy = (y0 < y1) ? 1 : -1;
	int err = dx - dy;

	while (1) {
		oled_write_pixel_to_SRAM(y0, x0, 1);  // Tegn piksel
    108a:	41 e0       	ldi	r20, 0x01	; 1
    108c:	6c 2f       	mov	r22, r28
    108e:	8d 2f       	mov	r24, r29
    1090:	0e 94 b8 07 	call	0xf70	; 0xf70 <oled_write_pixel_to_SRAM>

		if (x0 == x1 && y0 == y1) break;
    1094:	c9 11       	cpse	r28, r9
    1096:	02 c0       	rjmp	.+4      	; 0x109c <oled_draw_line+0x88>
    1098:	d6 15       	cp	r29, r6
    109a:	81 f0       	breq	.+32     	; 0x10bc <oled_draw_line+0xa8>
		int e2 = 2 * err;
    109c:	c8 01       	movw	r24, r16
    109e:	88 0f       	add	r24, r24
    10a0:	99 1f       	adc	r25, r25
		if (e2 > -dy) {
    10a2:	c8 16       	cp	r12, r24
    10a4:	d9 06       	cpc	r13, r25
    10a6:	1c f4       	brge	.+6      	; 0x10ae <oled_draw_line+0x9a>
			err -= dy;
    10a8:	0a 19       	sub	r16, r10
    10aa:	1b 09       	sbc	r17, r11
			x0 += sx;
    10ac:	c8 0d       	add	r28, r8
		}
		if (e2 < dx) {
    10ae:	8e 15       	cp	r24, r14
    10b0:	9f 05       	cpc	r25, r15
    10b2:	5c f7       	brge	.-42     	; 0x108a <oled_draw_line+0x76>
			err += dx;
    10b4:	0e 0d       	add	r16, r14
    10b6:	1f 1d       	adc	r17, r15
			y0 += sy;
    10b8:	d7 0d       	add	r29, r7
    10ba:	e7 cf       	rjmp	.-50     	; 0x108a <oled_draw_line+0x76>
		}
	}
}
    10bc:	df 91       	pop	r29
    10be:	cf 91       	pop	r28
    10c0:	1f 91       	pop	r17
    10c2:	0f 91       	pop	r16
    10c4:	ff 90       	pop	r15
    10c6:	ef 90       	pop	r14
    10c8:	df 90       	pop	r13
    10ca:	cf 90       	pop	r12
    10cc:	bf 90       	pop	r11
    10ce:	af 90       	pop	r10
    10d0:	9f 90       	pop	r9
    10d2:	8f 90       	pop	r8
    10d4:	7f 90       	pop	r7
    10d6:	6f 90       	pop	r6
    10d8:	08 95       	ret

000010da <oled_draw_circle>:

void oled_draw_circle(uint8_t x0, uint8_t y0, uint8_t radius) {
    10da:	9f 92       	push	r9
    10dc:	af 92       	push	r10
    10de:	bf 92       	push	r11
    10e0:	cf 92       	push	r12
    10e2:	df 92       	push	r13
    10e4:	ef 92       	push	r14
    10e6:	ff 92       	push	r15
    10e8:	0f 93       	push	r16
    10ea:	1f 93       	push	r17
    10ec:	cf 93       	push	r28
    10ee:	df 93       	push	r29
    10f0:	98 2e       	mov	r9, r24
    10f2:	c6 2e       	mov	r12, r22
	int x = radius;
    10f4:	c4 2f       	mov	r28, r20
    10f6:	d0 e0       	ldi	r29, 0x00	; 0
    10f8:	a1 2c       	mov	r10, r1
    10fa:	b1 2c       	mov	r11, r1
    10fc:	00 e0       	ldi	r16, 0x00	; 0
    10fe:	10 e0       	ldi	r17, 0x00	; 0
	int y = 0;
	int err = 0;

	while (x >= y) {
		oled_write_pixel_to_SRAM(y0 + y, x0 + x, 1);
    1100:	41 e0       	ldi	r20, 0x01	; 1
    1102:	fc 2e       	mov	r15, r28
    1104:	f9 0c       	add	r15, r9
    1106:	6f 2d       	mov	r22, r15
    1108:	dc 2c       	mov	r13, r12
    110a:	d0 0e       	add	r13, r16
    110c:	8d 2d       	mov	r24, r13
    110e:	0e 94 b8 07 	call	0xf70	; 0xf70 <oled_write_pixel_to_SRAM>
		oled_write_pixel_to_SRAM(y0 + y, x0 - x, 1);
    1112:	41 e0       	ldi	r20, 0x01	; 1
    1114:	e9 2c       	mov	r14, r9
    1116:	ec 1a       	sub	r14, r28
    1118:	6e 2d       	mov	r22, r14
    111a:	8d 2d       	mov	r24, r13
    111c:	0e 94 b8 07 	call	0xf70	; 0xf70 <oled_write_pixel_to_SRAM>
		oled_write_pixel_to_SRAM(y0 - y, x0 + x, 1);
    1120:	41 e0       	ldi	r20, 0x01	; 1
    1122:	6f 2d       	mov	r22, r15
    1124:	fc 2c       	mov	r15, r12
    1126:	f0 1a       	sub	r15, r16
    1128:	8f 2d       	mov	r24, r15
    112a:	0e 94 b8 07 	call	0xf70	; 0xf70 <oled_write_pixel_to_SRAM>
		oled_write_pixel_to_SRAM(y0 - y, x0 - x, 1);
    112e:	41 e0       	ldi	r20, 0x01	; 1
    1130:	6e 2d       	mov	r22, r14
    1132:	8f 2d       	mov	r24, r15
    1134:	0e 94 b8 07 	call	0xf70	; 0xf70 <oled_write_pixel_to_SRAM>
		oled_write_pixel_to_SRAM(y0 + x, x0 + y, 1);
    1138:	41 e0       	ldi	r20, 0x01	; 1
    113a:	f9 2c       	mov	r15, r9
    113c:	f0 0e       	add	r15, r16
    113e:	6f 2d       	mov	r22, r15
    1140:	dc 2e       	mov	r13, r28
    1142:	dc 0c       	add	r13, r12
    1144:	8d 2d       	mov	r24, r13
    1146:	0e 94 b8 07 	call	0xf70	; 0xf70 <oled_write_pixel_to_SRAM>
		oled_write_pixel_to_SRAM(y0 + x, x0 - y, 1);
    114a:	41 e0       	ldi	r20, 0x01	; 1
    114c:	e9 2c       	mov	r14, r9
    114e:	e0 1a       	sub	r14, r16
    1150:	6e 2d       	mov	r22, r14
    1152:	8d 2d       	mov	r24, r13
    1154:	0e 94 b8 07 	call	0xf70	; 0xf70 <oled_write_pixel_to_SRAM>
		oled_write_pixel_to_SRAM(y0 - x, x0 + y, 1);
    1158:	41 e0       	ldi	r20, 0x01	; 1
    115a:	6f 2d       	mov	r22, r15
    115c:	fc 2c       	mov	r15, r12
    115e:	fc 1a       	sub	r15, r28
    1160:	8f 2d       	mov	r24, r15
    1162:	0e 94 b8 07 	call	0xf70	; 0xf70 <oled_write_pixel_to_SRAM>
		oled_write_pixel_to_SRAM(y0 - x, x0 - y, 1);
    1166:	41 e0       	ldi	r20, 0x01	; 1
    1168:	6e 2d       	mov	r22, r14
    116a:	8f 2d       	mov	r24, r15
    116c:	0e 94 b8 07 	call	0xf70	; 0xf70 <oled_write_pixel_to_SRAM>

		if (err <= 0) {
    1170:	1a 14       	cp	r1, r10
    1172:	1b 04       	cpc	r1, r11
    1174:	5c f0       	brlt	.+22     	; 0x118c <oled_draw_circle+0xb2>
			y += 1;
    1176:	0f 5f       	subi	r16, 0xFF	; 255
    1178:	1f 4f       	sbci	r17, 0xFF	; 255
			err += 2 * y + 1;
    117a:	c8 01       	movw	r24, r16
    117c:	88 0f       	add	r24, r24
    117e:	99 1f       	adc	r25, r25
    1180:	01 96       	adiw	r24, 0x01	; 1
    1182:	a8 0e       	add	r10, r24
    1184:	b9 1e       	adc	r11, r25
		}
		if (err > 0) {
    1186:	1a 14       	cp	r1, r10
    1188:	1b 04       	cpc	r1, r11
    118a:	3c f4       	brge	.+14     	; 0x119a <oled_draw_circle+0xc0>
			x -= 1;
    118c:	21 97       	sbiw	r28, 0x01	; 1
			err -= 2 * x + 1;
    118e:	ce 01       	movw	r24, r28
    1190:	88 0f       	add	r24, r24
    1192:	99 1f       	adc	r25, r25
    1194:	01 96       	adiw	r24, 0x01	; 1
    1196:	a8 1a       	sub	r10, r24
    1198:	b9 0a       	sbc	r11, r25
void oled_draw_circle(uint8_t x0, uint8_t y0, uint8_t radius) {
	int x = radius;
	int y = 0;
	int err = 0;

	while (x >= y) {
    119a:	c0 17       	cp	r28, r16
    119c:	d1 07       	cpc	r29, r17
    119e:	0c f0       	brlt	.+2      	; 0x11a2 <oled_draw_circle+0xc8>
    11a0:	af cf       	rjmp	.-162    	; 0x1100 <oled_draw_circle+0x26>
		if (err > 0) {
			x -= 1;
			err -= 2 * x + 1;
		}
	}
}
    11a2:	df 91       	pop	r29
    11a4:	cf 91       	pop	r28
    11a6:	1f 91       	pop	r17
    11a8:	0f 91       	pop	r16
    11aa:	ff 90       	pop	r15
    11ac:	ef 90       	pop	r14
    11ae:	df 90       	pop	r13
    11b0:	cf 90       	pop	r12
    11b2:	bf 90       	pop	r11
    11b4:	af 90       	pop	r10
    11b6:	9f 90       	pop	r9
    11b8:	08 95       	ret

000011ba <oled_draw_square>:

void oled_draw_square(uint8_t x0, uint8_t y0, uint8_t width, uint8_t height) {
    11ba:	0f 93       	push	r16
    11bc:	1f 93       	push	r17
    11be:	cf 93       	push	r28
    11c0:	df 93       	push	r29
    11c2:	08 2f       	mov	r16, r24
    11c4:	16 2f       	mov	r17, r22
    11c6:	d2 2f       	mov	r29, r18
	oled_draw_line(x0, y0, x0 + width, y0);           // Øvre linje
    11c8:	c8 2f       	mov	r28, r24
    11ca:	c4 0f       	add	r28, r20
    11cc:	26 2f       	mov	r18, r22
    11ce:	4c 2f       	mov	r20, r28
    11d0:	0e 94 0a 08 	call	0x1014	; 0x1014 <oled_draw_line>
	oled_draw_line(x0, y0 + height, x0 + width, y0 + height);  // Nedre linje
    11d4:	d1 0f       	add	r29, r17
    11d6:	2d 2f       	mov	r18, r29
    11d8:	4c 2f       	mov	r20, r28
    11da:	6d 2f       	mov	r22, r29
    11dc:	80 2f       	mov	r24, r16
    11de:	0e 94 0a 08 	call	0x1014	; 0x1014 <oled_draw_line>
	oled_draw_line(x0, y0, x0, y0 + height);           // Venstre linje
    11e2:	2d 2f       	mov	r18, r29
    11e4:	40 2f       	mov	r20, r16
    11e6:	61 2f       	mov	r22, r17
    11e8:	80 2f       	mov	r24, r16
    11ea:	0e 94 0a 08 	call	0x1014	; 0x1014 <oled_draw_line>
	oled_draw_line(x0 + width, y0, x0 + width, y0 + height);   // Høyre linje
    11ee:	2d 2f       	mov	r18, r29
    11f0:	4c 2f       	mov	r20, r28
    11f2:	61 2f       	mov	r22, r17
    11f4:	8c 2f       	mov	r24, r28
    11f6:	0e 94 0a 08 	call	0x1014	; 0x1014 <oled_draw_line>
}
    11fa:	df 91       	pop	r29
    11fc:	cf 91       	pop	r28
    11fe:	1f 91       	pop	r17
    1200:	0f 91       	pop	r16
    1202:	08 95       	ret

00001204 <__vector_15>:
							"  *    * *    * "  // linje 7 (tom linje)
							"   ****   ****  "  // linje 6 (bunnen av hodet)
							" \_____________/";

// Timer-overflyt interrupt service rutine
ISR(TIMER1_OVF_vect) {
    1204:	1f 92       	push	r1
    1206:	0f 92       	push	r0
    1208:	0f b6       	in	r0, 0x3f	; 63
    120a:	0f 92       	push	r0
    120c:	11 24       	eor	r1, r1
    120e:	8f 93       	push	r24
    1210:	9f 93       	push	r25
    1212:	af 93       	push	r26
    1214:	bf 93       	push	r27
	overflow_count++;
    1216:	80 91 bd 02 	lds	r24, 0x02BD	; 0x8002bd <overflow_count>
    121a:	90 91 be 02 	lds	r25, 0x02BE	; 0x8002be <overflow_count+0x1>
    121e:	a0 91 bf 02 	lds	r26, 0x02BF	; 0x8002bf <overflow_count+0x2>
    1222:	b0 91 c0 02 	lds	r27, 0x02C0	; 0x8002c0 <overflow_count+0x3>
    1226:	01 96       	adiw	r24, 0x01	; 1
    1228:	a1 1d       	adc	r26, r1
    122a:	b1 1d       	adc	r27, r1
    122c:	80 93 bd 02 	sts	0x02BD, r24	; 0x8002bd <overflow_count>
    1230:	90 93 be 02 	sts	0x02BE, r25	; 0x8002be <overflow_count+0x1>
    1234:	a0 93 bf 02 	sts	0x02BF, r26	; 0x8002bf <overflow_count+0x2>
    1238:	b0 93 c0 02 	sts	0x02C0, r27	; 0x8002c0 <overflow_count+0x3>
}
    123c:	bf 91       	pop	r27
    123e:	af 91       	pop	r26
    1240:	9f 91       	pop	r25
    1242:	8f 91       	pop	r24
    1244:	0f 90       	pop	r0
    1246:	0f be       	out	0x3f, r0	; 63
    1248:	0f 90       	pop	r0
    124a:	1f 90       	pop	r1
    124c:	18 95       	reti

0000124e <get_time_in_cycles>:
}

uint32_t get_time_in_cycles(void) {
	// Returner tiden i klokkesykluser
	// Hver gang timeren overflyter, har vi telt 65536 klokkesykluser
	return (overflow_count * 65536UL) + TCNT1;
    124e:	80 91 bd 02 	lds	r24, 0x02BD	; 0x8002bd <overflow_count>
    1252:	90 91 be 02 	lds	r25, 0x02BE	; 0x8002be <overflow_count+0x1>
    1256:	a0 91 bf 02 	lds	r26, 0x02BF	; 0x8002bf <overflow_count+0x2>
    125a:	b0 91 c0 02 	lds	r27, 0x02C0	; 0x8002c0 <overflow_count+0x3>
    125e:	2c b5       	in	r18, 0x2c	; 44
    1260:	3d b5       	in	r19, 0x2d	; 45
    1262:	dc 01       	movw	r26, r24
    1264:	99 27       	eor	r25, r25
    1266:	88 27       	eor	r24, r24
    1268:	bc 01       	movw	r22, r24
    126a:	cd 01       	movw	r24, r26
    126c:	62 0f       	add	r22, r18
    126e:	73 1f       	adc	r23, r19
    1270:	81 1d       	adc	r24, r1
    1272:	91 1d       	adc	r25, r1
}
    1274:	08 95       	ret

00001276 <get_time_in_ms>:
	overflow_count++;
}

// Funksjon som returnerer tida i millisekund sidan programstart
uint32_t get_time_in_ms(void){
	return get_time_in_cycles()/(4915200UL/1000);
    1276:	0e 94 27 09 	call	0x124e	; 0x124e <get_time_in_cycles>
    127a:	23 e3       	ldi	r18, 0x33	; 51
    127c:	33 e1       	ldi	r19, 0x13	; 19
    127e:	40 e0       	ldi	r20, 0x00	; 0
    1280:	50 e0       	ldi	r21, 0x00	; 0
    1282:	0e 94 bc 09 	call	0x1378	; 0x1378 <__udivmodsi4>
}
    1286:	ca 01       	movw	r24, r20
    1288:	b9 01       	movw	r22, r18
    128a:	08 95       	ret

0000128c <setup_timer>:
}

// Funksjon for å setje opp Timer1 til å generere 1 ms avbrot
void setup_timer() {
	// Sett normal modus (WGM12 = 0)
	TCCR1A = 0;      // Normal mode
    128c:	1f bc       	out	0x2f, r1	; 47
	TCCR1B = (1 << CS10); // Prescaler = 1 (ingen prescaling, f_CPU direkte)
    128e:	81 e0       	ldi	r24, 0x01	; 1
    1290:	8e bd       	out	0x2e, r24	; 46

	// Aktiver Timer1 overflow interrupt
	TIMSK = (1 << TOIE1);
    1292:	80 e8       	ldi	r24, 0x80	; 128
    1294:	89 bf       	out	0x39, r24	; 57

	// Nullstill Timer/Counter1
	TCNT1 = 0;
    1296:	1d bc       	out	0x2d, r1	; 45
    1298:	1c bc       	out	0x2c, r1	; 44
    129a:	08 95       	ret

0000129c <restart_timer>:
}
void restart_timer(){
	// Nullstill Timer/Counter1
	TCNT1 = 0;
    129c:	1d bc       	out	0x2d, r1	; 45
    129e:	1c bc       	out	0x2c, r1	; 44
	overflow_count = 0;
    12a0:	10 92 bd 02 	sts	0x02BD, r1	; 0x8002bd <overflow_count>
    12a4:	10 92 be 02 	sts	0x02BE, r1	; 0x8002be <overflow_count+0x1>
    12a8:	10 92 bf 02 	sts	0x02BF, r1	; 0x8002bf <overflow_count+0x2>
    12ac:	10 92 c0 02 	sts	0x02C0, r1	; 0x8002c0 <overflow_count+0x3>
    12b0:	08 95       	ret

000012b2 <externalMemoryInit>:
 */ 
#include "XMEM_Decode.h"
// Funksjon for ï¿½ initialisere det eksterne minnet (SRAM + latch)
void externalMemoryInit(void) {
	// Set Port A (AD0-AD7) og Port C (A8-A15) som utgang for adresse- og databuss
	DDRA = 0xFF;  // PA0-PA7 som utgang
    12b2:	8f ef       	ldi	r24, 0xFF	; 255
    12b4:	8a bb       	out	0x1a, r24	; 26
	DDRC = 0x0F ;  // PC0-PC3 som utgang
    12b6:	8f e0       	ldi	r24, 0x0F	; 15
    12b8:	84 bb       	out	0x14, r24	; 20
	
	// Set Port D (PD6 og PD7) som utgang for WR og RD signal
	setBit(DDRD, PD6);  // WR
    12ba:	8e 9a       	sbi	0x11, 6	; 17
	setBit(DDRD, PD7);  // RD
    12bc:	8f 9a       	sbi	0x11, 7	; 17

	// Set Port E (PE1) som utgang for ALE
	setBit(DDRE, PE1);  // ALE
    12be:	31 9a       	sbi	0x06, 1	; 6

	// Aktivere ekstern minnegrensesnitt
	setBit(MCUCR, SRE);   // Enable external SRAM interface
    12c0:	85 b7       	in	r24, 0x35	; 53
    12c2:	80 68       	ori	r24, 0x80	; 128
    12c4:	85 bf       	out	0x35, r24	; 53
	SFIOR = 0x00;         // No wait state
    12c6:	10 be       	out	0x30, r1	; 48
	
	//Maskes pc4-pc7 (disables as output) (s32 ATmega datasheet)
	setBit(SFIOR, XMM2);
    12c8:	80 b7       	in	r24, 0x30	; 48
    12ca:	80 62       	ori	r24, 0x20	; 32
    12cc:	80 bf       	out	0x30, r24	; 48
    12ce:	08 95       	ret

000012d0 <SRAM_write>:
}


// Funksjon for ï¿½ skrive data til SRAM
void SRAM_write(volatile uint16_t addr, uint8_t data) {
    12d0:	cf 93       	push	r28
    12d2:	df 93       	push	r29
    12d4:	00 d0       	rcall	.+0      	; 0x12d6 <SRAM_write+0x6>
    12d6:	cd b7       	in	r28, 0x3d	; 61
    12d8:	de b7       	in	r29, 0x3e	; 62
    12da:	9a 83       	std	Y+2, r25	; 0x02
    12dc:	89 83       	std	Y+1, r24	; 0x01
	volatile char *ext_ram = (char *) SRAM_START; // Startadresse for SRAM
	uint16_t ext_ram_size = SRAM_SIZE; // Stï¿½rrelsen pï¿½ SRAM (2 KB)
	ext_ram[addr] = data;
    12de:	e9 81       	ldd	r30, Y+1	; 0x01
    12e0:	fa 81       	ldd	r31, Y+2	; 0x02
    12e2:	f8 5e       	subi	r31, 0xE8	; 232
    12e4:	60 83       	st	Z, r22
}
    12e6:	0f 90       	pop	r0
    12e8:	0f 90       	pop	r0
    12ea:	df 91       	pop	r29
    12ec:	cf 91       	pop	r28
    12ee:	08 95       	ret

000012f0 <SRAM_read>:

// Funksjon for ï¿½ lese data frï¿½ SRAM
uint8_t SRAM_read(volatile uint16_t addr) {
    12f0:	cf 93       	push	r28
    12f2:	df 93       	push	r29
    12f4:	00 d0       	rcall	.+0      	; 0x12f6 <SRAM_read+0x6>
    12f6:	cd b7       	in	r28, 0x3d	; 61
    12f8:	de b7       	in	r29, 0x3e	; 62
    12fa:	9a 83       	std	Y+2, r25	; 0x02
    12fc:	89 83       	std	Y+1, r24	; 0x01
	volatile char *ext_ram = (char *) SRAM_START; // Startadresse for SRAM
	uint16_t ext_ram_size = SRAM_SIZE; // Stï¿½rrelsen pï¿½ SRAM (2 KB)
	uint8_t data = ext_ram[addr];
    12fe:	e9 81       	ldd	r30, Y+1	; 0x01
    1300:	fa 81       	ldd	r31, Y+2	; 0x02
    1302:	f8 5e       	subi	r31, 0xE8	; 232
    1304:	80 81       	ld	r24, Z
	
	return data;
}
    1306:	0f 90       	pop	r0
    1308:	0f 90       	pop	r0
    130a:	df 91       	pop	r29
    130c:	cf 91       	pop	r28
    130e:	08 95       	ret

00001310 <Universal_write>:

// Funksjon for ï¿½ skrive data til SRAM
void Universal_write(volatile uint16_t addr, uint8_t data) {
    1310:	cf 93       	push	r28
    1312:	df 93       	push	r29
    1314:	00 d0       	rcall	.+0      	; 0x1316 <Universal_write+0x6>
    1316:	cd b7       	in	r28, 0x3d	; 61
    1318:	de b7       	in	r29, 0x3e	; 62
    131a:	9a 83       	std	Y+2, r25	; 0x02
    131c:	89 83       	std	Y+1, r24	; 0x01
	volatile char *ext_ram = (char *) OLED_START; // Startadresse for SRAM
	ext_ram[addr] = data;
    131e:	e9 81       	ldd	r30, Y+1	; 0x01
    1320:	fa 81       	ldd	r31, Y+2	; 0x02
    1322:	f0 5f       	subi	r31, 0xF0	; 240
    1324:	60 83       	st	Z, r22
		
}
    1326:	0f 90       	pop	r0
    1328:	0f 90       	pop	r0
    132a:	df 91       	pop	r29
    132c:	cf 91       	pop	r28
    132e:	08 95       	ret

00001330 <Universal_read>:

// Funksjon for ï¿½ lese data frï¿½ SRAM
uint8_t Universal_read(volatile uint16_t addr) {
    1330:	cf 93       	push	r28
    1332:	df 93       	push	r29
    1334:	00 d0       	rcall	.+0      	; 0x1336 <Universal_read+0x6>
    1336:	cd b7       	in	r28, 0x3d	; 61
    1338:	de b7       	in	r29, 0x3e	; 62
    133a:	9a 83       	std	Y+2, r25	; 0x02
    133c:	89 83       	std	Y+1, r24	; 0x01
	volatile char *ext_ram = (char *) OLED_START; // Startadresse for SRAM
	uint8_t data = ext_ram[addr];
    133e:	e9 81       	ldd	r30, Y+1	; 0x01
    1340:	fa 81       	ldd	r31, Y+2	; 0x02
    1342:	f0 5f       	subi	r31, 0xF0	; 240
    1344:	80 81       	ld	r24, Z
	
	return data;
}
    1346:	0f 90       	pop	r0
    1348:	0f 90       	pop	r0
    134a:	df 91       	pop	r29
    134c:	cf 91       	pop	r28
    134e:	08 95       	ret

00001350 <__divmodhi4>:
    1350:	97 fb       	bst	r25, 7
    1352:	07 2e       	mov	r0, r23
    1354:	16 f4       	brtc	.+4      	; 0x135a <__divmodhi4+0xa>
    1356:	00 94       	com	r0
    1358:	07 d0       	rcall	.+14     	; 0x1368 <__divmodhi4_neg1>
    135a:	77 fd       	sbrc	r23, 7
    135c:	09 d0       	rcall	.+18     	; 0x1370 <__divmodhi4_neg2>
    135e:	0e 94 de 09 	call	0x13bc	; 0x13bc <__udivmodhi4>
    1362:	07 fc       	sbrc	r0, 7
    1364:	05 d0       	rcall	.+10     	; 0x1370 <__divmodhi4_neg2>
    1366:	3e f4       	brtc	.+14     	; 0x1376 <__divmodhi4_exit>

00001368 <__divmodhi4_neg1>:
    1368:	90 95       	com	r25
    136a:	81 95       	neg	r24
    136c:	9f 4f       	sbci	r25, 0xFF	; 255
    136e:	08 95       	ret

00001370 <__divmodhi4_neg2>:
    1370:	70 95       	com	r23
    1372:	61 95       	neg	r22
    1374:	7f 4f       	sbci	r23, 0xFF	; 255

00001376 <__divmodhi4_exit>:
    1376:	08 95       	ret

00001378 <__udivmodsi4>:
    1378:	a1 e2       	ldi	r26, 0x21	; 33
    137a:	1a 2e       	mov	r1, r26
    137c:	aa 1b       	sub	r26, r26
    137e:	bb 1b       	sub	r27, r27
    1380:	fd 01       	movw	r30, r26
    1382:	0d c0       	rjmp	.+26     	; 0x139e <__udivmodsi4_ep>

00001384 <__udivmodsi4_loop>:
    1384:	aa 1f       	adc	r26, r26
    1386:	bb 1f       	adc	r27, r27
    1388:	ee 1f       	adc	r30, r30
    138a:	ff 1f       	adc	r31, r31
    138c:	a2 17       	cp	r26, r18
    138e:	b3 07       	cpc	r27, r19
    1390:	e4 07       	cpc	r30, r20
    1392:	f5 07       	cpc	r31, r21
    1394:	20 f0       	brcs	.+8      	; 0x139e <__udivmodsi4_ep>
    1396:	a2 1b       	sub	r26, r18
    1398:	b3 0b       	sbc	r27, r19
    139a:	e4 0b       	sbc	r30, r20
    139c:	f5 0b       	sbc	r31, r21

0000139e <__udivmodsi4_ep>:
    139e:	66 1f       	adc	r22, r22
    13a0:	77 1f       	adc	r23, r23
    13a2:	88 1f       	adc	r24, r24
    13a4:	99 1f       	adc	r25, r25
    13a6:	1a 94       	dec	r1
    13a8:	69 f7       	brne	.-38     	; 0x1384 <__udivmodsi4_loop>
    13aa:	60 95       	com	r22
    13ac:	70 95       	com	r23
    13ae:	80 95       	com	r24
    13b0:	90 95       	com	r25
    13b2:	9b 01       	movw	r18, r22
    13b4:	ac 01       	movw	r20, r24
    13b6:	bd 01       	movw	r22, r26
    13b8:	cf 01       	movw	r24, r30
    13ba:	08 95       	ret

000013bc <__udivmodhi4>:
    13bc:	aa 1b       	sub	r26, r26
    13be:	bb 1b       	sub	r27, r27
    13c0:	51 e1       	ldi	r21, 0x11	; 17
    13c2:	07 c0       	rjmp	.+14     	; 0x13d2 <__udivmodhi4_ep>

000013c4 <__udivmodhi4_loop>:
    13c4:	aa 1f       	adc	r26, r26
    13c6:	bb 1f       	adc	r27, r27
    13c8:	a6 17       	cp	r26, r22
    13ca:	b7 07       	cpc	r27, r23
    13cc:	10 f0       	brcs	.+4      	; 0x13d2 <__udivmodhi4_ep>
    13ce:	a6 1b       	sub	r26, r22
    13d0:	b7 0b       	sbc	r27, r23

000013d2 <__udivmodhi4_ep>:
    13d2:	88 1f       	adc	r24, r24
    13d4:	99 1f       	adc	r25, r25
    13d6:	5a 95       	dec	r21
    13d8:	a9 f7       	brne	.-22     	; 0x13c4 <__udivmodhi4_loop>
    13da:	80 95       	com	r24
    13dc:	90 95       	com	r25
    13de:	bc 01       	movw	r22, r24
    13e0:	cd 01       	movw	r24, r26
    13e2:	08 95       	ret

000013e4 <strncpy_P>:
    13e4:	fb 01       	movw	r30, r22
    13e6:	dc 01       	movw	r26, r24
    13e8:	41 50       	subi	r20, 0x01	; 1
    13ea:	50 40       	sbci	r21, 0x00	; 0
    13ec:	48 f0       	brcs	.+18     	; 0x1400 <strncpy_P+0x1c>
    13ee:	05 90       	lpm	r0, Z+
    13f0:	0d 92       	st	X+, r0
    13f2:	00 20       	and	r0, r0
    13f4:	c9 f7       	brne	.-14     	; 0x13e8 <strncpy_P+0x4>
    13f6:	01 c0       	rjmp	.+2      	; 0x13fa <strncpy_P+0x16>
    13f8:	1d 92       	st	X+, r1
    13fa:	41 50       	subi	r20, 0x01	; 1
    13fc:	50 40       	sbci	r21, 0x00	; 0
    13fe:	e0 f7       	brcc	.-8      	; 0x13f8 <strncpy_P+0x14>
    1400:	08 95       	ret

00001402 <strncpy>:
    1402:	fb 01       	movw	r30, r22
    1404:	dc 01       	movw	r26, r24
    1406:	41 50       	subi	r20, 0x01	; 1
    1408:	50 40       	sbci	r21, 0x00	; 0
    140a:	48 f0       	brcs	.+18     	; 0x141e <strncpy+0x1c>
    140c:	01 90       	ld	r0, Z+
    140e:	0d 92       	st	X+, r0
    1410:	00 20       	and	r0, r0
    1412:	c9 f7       	brne	.-14     	; 0x1406 <strncpy+0x4>
    1414:	01 c0       	rjmp	.+2      	; 0x1418 <strncpy+0x16>
    1416:	1d 92       	st	X+, r1
    1418:	41 50       	subi	r20, 0x01	; 1
    141a:	50 40       	sbci	r21, 0x00	; 0
    141c:	e0 f7       	brcc	.-8      	; 0x1416 <strncpy+0x14>
    141e:	08 95       	ret

00001420 <_exit>:
    1420:	f8 94       	cli

00001422 <__stop_program>:
    1422:	ff cf       	rjmp	.-2      	; 0x1422 <__stop_program>
