
ATmega162.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000f6  00800100  00001a7c  00001b10  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001a7c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000001f  008001f6  008001f6  00001c06  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001c06  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00001c38  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000288  00000000  00000000  00001c74  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000034f4  00000000  00000000  00001efc  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001262  00000000  00000000  000053f0  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001633  00000000  00000000  00006652  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000728  00000000  00000000  00007c88  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000abe  00000000  00000000  000083b0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00002067  00000000  00000000  00008e6e  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000208  00000000  00000000  0000aed5  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 1c 05 	jmp	0xa38	; 0xa38 <__ctors_end>
       4:	0c 94 39 05 	jmp	0xa72	; 0xa72 <__bad_interrupt>
       8:	0c 94 39 05 	jmp	0xa72	; 0xa72 <__bad_interrupt>
       c:	0c 94 39 05 	jmp	0xa72	; 0xa72 <__bad_interrupt>
      10:	0c 94 39 05 	jmp	0xa72	; 0xa72 <__bad_interrupt>
      14:	0c 94 39 05 	jmp	0xa72	; 0xa72 <__bad_interrupt>
      18:	0c 94 39 05 	jmp	0xa72	; 0xa72 <__bad_interrupt>
      1c:	0c 94 39 05 	jmp	0xa72	; 0xa72 <__bad_interrupt>
      20:	0c 94 39 05 	jmp	0xa72	; 0xa72 <__bad_interrupt>
      24:	0c 94 39 05 	jmp	0xa72	; 0xa72 <__bad_interrupt>
      28:	0c 94 39 05 	jmp	0xa72	; 0xa72 <__bad_interrupt>
      2c:	0c 94 39 05 	jmp	0xa72	; 0xa72 <__bad_interrupt>
      30:	0c 94 39 05 	jmp	0xa72	; 0xa72 <__bad_interrupt>
      34:	0c 94 39 05 	jmp	0xa72	; 0xa72 <__bad_interrupt>
      38:	0c 94 39 05 	jmp	0xa72	; 0xa72 <__bad_interrupt>
      3c:	0c 94 2e 0c 	jmp	0x185c	; 0x185c <__vector_15>
      40:	0c 94 39 05 	jmp	0xa72	; 0xa72 <__bad_interrupt>
      44:	0c 94 39 05 	jmp	0xa72	; 0xa72 <__bad_interrupt>
      48:	0c 94 39 05 	jmp	0xa72	; 0xa72 <__bad_interrupt>
      4c:	0c 94 66 05 	jmp	0xacc	; 0xacc <__vector_19>
      50:	0c 94 39 05 	jmp	0xa72	; 0xa72 <__bad_interrupt>
      54:	0c 94 39 05 	jmp	0xa72	; 0xa72 <__bad_interrupt>
      58:	0c 94 39 05 	jmp	0xa72	; 0xa72 <__bad_interrupt>
      5c:	0c 94 39 05 	jmp	0xa72	; 0xa72 <__bad_interrupt>
      60:	0c 94 39 05 	jmp	0xa72	; 0xa72 <__bad_interrupt>
      64:	0c 94 39 05 	jmp	0xa72	; 0xa72 <__bad_interrupt>
      68:	0c 94 39 05 	jmp	0xa72	; 0xa72 <__bad_interrupt>
      6c:	0c 94 39 05 	jmp	0xa72	; 0xa72 <__bad_interrupt>

00000070 <__trampolines_end>:
      70:	00 00       	nop
      72:	1e 1e       	adc	r1, r30
      74:	00 00       	nop
      76:	1e 1e       	adc	r1, r30
      78:	00 1e       	adc	r0, r16
      7a:	1e 00       	.word	0x001e	; ????
      7c:	00 00       	nop
      7e:	1e 1e       	adc	r1, r30
      80:	00 1e       	adc	r0, r16
      82:	1e 00       	.word	0x001e	; ????
      84:	00 00       	nop
      86:	1e 1e       	adc	r1, r30
      88:	00 00       	nop
      8a:	00 00       	nop
      8c:	00 00       	nop
      8e:	1e 1e       	adc	r1, r30
      90:	3f 3f       	cpi	r19, 0xFF	; 255
      92:	3f 3f       	cpi	r19, 0xFF	; 255
      94:	3f 3f       	cpi	r19, 0xFF	; 255
      96:	ff ff       	.word	0xffff	; ????
      98:	3f 3f       	cpi	r19, 0xFF	; 255
      9a:	3f 3f       	cpi	r19, 0xFF	; 255
      9c:	3f 3f       	cpi	r19, 0xFF	; 255
      9e:	ff ff       	.word	0xffff	; ????
      a0:	1f 1f       	adc	r17, r31
      a2:	1f 1f       	adc	r17, r31
      a4:	1f 1f       	adc	r17, r31
      a6:	ff ff       	.word	0xffff	; ????
      a8:	1f 1f       	adc	r17, r31
      aa:	1f 1f       	adc	r17, r31
      ac:	1f 1f       	adc	r17, r31
      ae:	ff ff       	.word	0xffff	; ????
      b0:	00 1e       	adc	r0, r16
      b2:	1e 00       	.word	0x001e	; ????
      b4:	00 00       	nop
      b6:	1e 1e       	adc	r1, r30
      b8:	00 1e       	adc	r0, r16
      ba:	1e 00       	.word	0x001e	; ????
      bc:	00 00       	nop
      be:	1e 1e       	adc	r1, r30
      c0:	00 00       	nop
      c2:	00 00       	nop
      c4:	00 00       	nop
      c6:	1e 1e       	adc	r1, r30
      c8:	00 1e       	adc	r0, r16
      ca:	1e 00       	.word	0x001e	; ????
      cc:	00 00       	nop
      ce:	1e 1e       	adc	r1, r30
	...

00000470 <smiley>:
     470:	20 20 5f 5f 5f 5f 5f 25 20 20 25 5f 5f 5f 5f 5f       _____%  %_____
     480:	20 20 2a 2a 2a 2a 2a 20 20 20 2a 2a 2a 2a 2a 20       *****   ***** 
     490:	20 2a 20 20 20 20 20 2a 20 2a 20 20 20 20 20 2a      *     * *     *
     4a0:	20 2a 20 20 2a 2a 20 20 2a 20 20 2a 2a 20 20 2a      *  **  *  **  *
     4b0:	20 2a 20 20 20 20 20 20 2a 20 20 20 20 20 20 2a      *      *      *
     4c0:	20 20 2a 20 20 20 20 2a 20 2a 20 20 20 20 2a 20       *    * *    * 
     4d0:	20 20 20 2a 2a 2a 2a 20 20 20 2a 2a 2a 2a 20 20        ****   ****  
     4e0:	20 5c 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 2f      \_____________/

000004f0 <solkors>:
     4f0:	20 20 20 79 61 70 40 40 40 2a 20 20 20 20 20 20        yap@@@*      
     500:	20 20 20 23 40 40 40 23 20 20 20 2a 23 20 20 20        #@@@#   *#   
     510:	20 20 23 40 40 40 2a 20 20 2a 40 40 40 40 23 20       #@@@*  *@@@@# 
     520:	2a 20 20 2b 23 40 40 40 40 40 40 20 20 40 40 40     *  +#@@@@@@  @@@
     530:	40 40 20 20 20 2b 40 40 40 40 2a 20 20 20 40 40     @@   +@@@@*   @@
     540:	40 40 40 25 25 40 40 40 40 40 40 20 2b 20 20 2a     @@@%%@@@@@@ +  *
     550:	20 23 40 40 40 40 2a 20 20 2a 40 40 40 23 20 20      #@@@@*  *@@@#  
     560:	20 20 20 23 23 20 20 20 23 40 40 40 23 20 20 20        ##   #@@@#   

00000570 <font8x8_basic>:
	...
     578:	00 00 5f 00 00 00 00 00 00 07 00 07 00 00 00 00     .._.............
     588:	14 7f 14 7f 14 00 00 00 24 2a 7f 2a 12 00 00 00     ........$*.*....
     598:	23 13 08 64 62 00 00 00 36 49 56 20 50 00 00 00     #..db...6IV P...
     5a8:	00 08 07 03 00 00 00 00 00 1c 22 41 00 00 00 00     .........."A....
     5b8:	00 41 22 1c 00 00 00 00 14 08 3e 08 14 00 00 00     .A".......>.....
     5c8:	08 08 3e 08 08 00 00 00 00 50 30 00 00 00 00 00     ..>......P0.....
     5d8:	08 08 08 08 08 00 00 00 00 60 60 00 00 00 00 00     .........``.....
     5e8:	20 10 08 04 02 00 00 00 3e 51 49 45 3e 00 00 00      .......>QIE>...
     5f8:	00 42 7f 40 00 00 00 00 42 61 51 49 46 00 00 00     .B.@....BaQIF...
     608:	21 41 45 4b 31 00 00 00 18 14 12 7f 10 00 00 00     !AEK1...........
     618:	27 45 45 45 39 00 00 00 3c 4a 49 49 30 00 00 00     'EEE9...<JII0...
     628:	01 71 09 05 03 00 00 00 36 49 49 49 36 00 00 00     .q......6III6...
     638:	06 49 49 29 1e 00 00 00 00 36 36 00 00 00 00 00     .II).....66.....
     648:	00 56 36 00 00 00 00 00 08 14 22 41 00 00 00 00     .V6......."A....
     658:	14 14 14 14 14 14 00 00 41 22 14 08 00 00 00 00     ........A"......
     668:	02 01 51 09 06 00 00 00 3e 41 5d 5d 1e 00 00 00     ..Q.....>A]]....
     678:	7e 11 11 11 7e 00 00 00 7f 49 49 49 36 00 00 00     ~...~....III6...
     688:	3e 41 41 41 22 00 00 00 7f 41 41 22 1c 00 00 00     >AAA"....AA"....
     698:	7f 49 49 49 41 00 00 00 7f 09 09 09 01 00 00 00     .IIIA...........
     6a8:	3e 41 49 49 7a 00 00 00 7f 08 08 08 7f 00 00 00     >AIIz...........
     6b8:	00 41 7f 41 00 00 00 00 20 40 41 3f 01 00 00 00     .A.A.... @A?....
     6c8:	7f 08 14 22 41 00 00 00 7f 40 40 40 40 00 00 00     ..."A....@@@@...
     6d8:	7f 02 04 02 7f 00 00 00 7f 02 04 08 7f 00 00 00     ................
     6e8:	3e 41 41 41 3e 00 00 00 7f 09 09 09 06 00 00 00     >AAA>...........
     6f8:	3e 41 51 21 5e 00 00 00 7f 09 19 29 46 00 00 00     >AQ!^......)F...
     708:	46 49 49 49 31 00 00 00 01 01 7f 01 01 00 00 00     FIII1...........
     718:	3f 40 40 40 3f 00 00 00 1f 20 40 20 1f 00 00 00     ?@@@?.... @ ....
     728:	7f 20 18 20 7f 00 00 00 63 14 08 14 63 00 00 00     . . ....c...c...
     738:	03 04 78 04 03 00 00 00 61 51 49 45 43 00 00 00     ..x.....aQIEC...
     748:	00 3e 41 41 00 00 00 00 02 04 08 10 20 00 00 00     .>AA........ ...
     758:	00 41 41 3e 00 00 00 00 04 02 01 02 04 00 00 00     .AA>............
     768:	40 40 40 40 40 40 00 00 00 00 03 07 00 00 00 00     @@@@@@..........
     778:	20 54 54 54 78 00 00 00 7f 48 44 44 38 00 00 00      TTTx....HDD8...
     788:	38 44 44 44 20 00 00 00 38 44 44 48 7f 00 00 00     8DDD ...8DDH....
     798:	38 54 54 54 18 00 00 00 08 7e 09 01 02 00 00 00     8TTT.....~......
     7a8:	08 14 54 54 3c 00 00 00 7f 08 04 04 78 00 00 00     ..TT<.......x...
     7b8:	00 44 7d 40 00 00 00 00 20 40 44 3d 00 00 00 00     .D}@.... @D=....
     7c8:	00 7f 10 28 44 00 00 00 00 41 7f 40 00 00 00 00     ...(D....A.@....
     7d8:	7c 04 18 04 78 00 00 00 7c 08 04 04 78 00 00 00     |...x...|...x...
     7e8:	38 44 44 44 38 00 00 00 7c 14 14 14 08 00 00 00     8DDD8...|.......
     7f8:	08 14 14 18 7c 00 00 00 7c 08 04 04 08 00 00 00     ....|...|.......
     808:	48 54 54 54 20 00 00 00 04 3f 44 40 20 00 00 00     HTTT ....?D@ ...
     818:	3c 40 40 20 7c 00 00 00 1c 20 40 20 1c 00 00 00     <@@ |.... @ ....
     828:	3c 40 30 40 3c 00 00 00 44 28 10 28 44 00 00 00     <@0@<...D(.(D...
     838:	0c 50 50 50 3c 00 00 00 44 64 54 4c 44 00 00 00     .PPP<...DdTLD...
     848:	00 08 36 41 00 00 00 00 00 00 7f 00 00 00 00 00     ..6A............
     858:	00 41 36 08 00 00 00 00 08 04 08 10 08 00 00 00     .A6.............

00000868 <settingsMenuItems>:
     868:	20 53 6f 75 6e 64 20 20 20 20 20 20 20 20 00 00      Sound        ..
     878:	20 42 72 69 67 68 74 6e 65 73 73 20 20 20 00 00      Brightness   ..
     888:	20 43 6f 6e 74 72 6f 6c 73 20 20 20 20 20 00 00      Controls     ..
     898:	20 42 61 63 6b 20 20 20 20 20 20 20 20 20 00 00      Back         ..

000008a8 <scrollMenuItems>:
     8a8:	20 49 74 65 6d 20 31 20 20 42 41 43 4b 20 00 00      Item 1  BACK ..
     8b8:	20 49 74 65 6d 20 32 20 20 20 20 20 20 20 00 00      Item 2       ..
     8c8:	20 49 74 65 6d 20 33 20 20 20 20 20 20 20 00 00      Item 3       ..
     8d8:	20 49 74 65 6d 20 34 20 20 20 20 20 20 20 00 00      Item 4       ..
     8e8:	20 49 74 65 6d 20 35 20 20 20 20 20 20 20 00 00      Item 5       ..
     8f8:	20 49 74 65 6d 20 36 20 20 20 20 20 20 20 00 00      Item 6       ..
     908:	20 49 74 65 6d 20 37 20 20 20 20 20 20 20 00 00      Item 7       ..
     918:	20 49 74 65 6d 20 38 20 20 20 20 20 20 20 00 00      Item 8       ..
     928:	20 49 74 65 6d 20 39 20 20 20 20 20 20 20 00 00      Item 9       ..
     938:	20 49 74 65 6d 20 31 30 20 20 20 20 20 20 00 00      Item 10      ..
     948:	20 49 74 65 6d 20 31 31 20 20 20 20 20 20 00 00      Item 11      ..
     958:	20 49 74 65 6d 20 31 32 20 20 20 20 20 20 00 00      Item 12      ..
     968:	20 49 74 65 6d 20 31 33 20 20 20 20 20 20 00 00      Item 13      ..
     978:	20 49 74 65 6d 20 31 34 20 20 20 20 20 20 00 00      Item 14      ..
     988:	20 49 74 65 6d 20 31 35 20 20 20 20 20 20 00 00      Item 15      ..
     998:	20 49 74 65 6d 20 31 36 20 20 20 20 20 20 00 00      Item 16      ..
     9a8:	20 49 74 65 6d 20 31 37 20 20 20 20 20 20 00 00      Item 17      ..
     9b8:	20 49 74 65 6d 20 31 38 20 20 20 20 20 20 00 00      Item 18      ..
     9c8:	20 49 74 65 6d 20 31 39 20 20 20 20 20 20 00 00      Item 19      ..
     9d8:	20 49 74 65 6d 20 32 30 20 20 20 20 20 20 00 00      Item 20      ..

000009e8 <mainMenuItems>:
     9e8:	20 53 74 61 72 74 20 47 61 6d 65 20 20 20 00 00      Start Game   ..
     9f8:	20 53 65 74 74 69 6e 67 73 20 20 20 20 20 00 00      Settings     ..
     a08:	20 48 69 67 68 20 53 63 6f 72 65 73 20 20 00 00      High Scores  ..
     a18:	20 43 72 65 64 69 74 73 20 20 20 20 20 20 00 00      Credits      ..
     a28:	20 45 78 69 74 20 20 20 20 20 20 20 20 20 00 00      Exit         ..

00000a38 <__ctors_end>:
     a38:	11 24       	eor	r1, r1
     a3a:	1f be       	out	0x3f, r1	; 63
     a3c:	cf ef       	ldi	r28, 0xFF	; 255
     a3e:	d4 e0       	ldi	r29, 0x04	; 4
     a40:	de bf       	out	0x3e, r29	; 62
     a42:	cd bf       	out	0x3d, r28	; 61

00000a44 <__do_copy_data>:
     a44:	11 e0       	ldi	r17, 0x01	; 1
     a46:	a0 e0       	ldi	r26, 0x00	; 0
     a48:	b1 e0       	ldi	r27, 0x01	; 1
     a4a:	ec e7       	ldi	r30, 0x7C	; 124
     a4c:	fa e1       	ldi	r31, 0x1A	; 26
     a4e:	02 c0       	rjmp	.+4      	; 0xa54 <__do_copy_data+0x10>
     a50:	05 90       	lpm	r0, Z+
     a52:	0d 92       	st	X+, r0
     a54:	a6 3f       	cpi	r26, 0xF6	; 246
     a56:	b1 07       	cpc	r27, r17
     a58:	d9 f7       	brne	.-10     	; 0xa50 <__do_copy_data+0xc>

00000a5a <__do_clear_bss>:
     a5a:	22 e0       	ldi	r18, 0x02	; 2
     a5c:	a6 ef       	ldi	r26, 0xF6	; 246
     a5e:	b1 e0       	ldi	r27, 0x01	; 1
     a60:	01 c0       	rjmp	.+2      	; 0xa64 <.do_clear_bss_start>

00000a62 <.do_clear_bss_loop>:
     a62:	1d 92       	st	X+, r1

00000a64 <.do_clear_bss_start>:
     a64:	a5 31       	cpi	r26, 0x15	; 21
     a66:	b2 07       	cpc	r27, r18
     a68:	e1 f7       	brne	.-8      	; 0xa62 <.do_clear_bss_loop>
     a6a:	0e 94 73 05 	call	0xae6	; 0xae6 <main>
     a6e:	0c 94 3c 0d 	jmp	0x1a78	; 0x1a78 <_exit>

00000a72 <__bad_interrupt>:
     a72:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000a76 <UART_Init>:
	setBit(UCSR0B, RXCIE0);
}

// Deaktiver avbrot for når data blir mottatt
void UART_DisableReceiveInterrupt(void) {
	clearBit(UCSR0B, RXCIE0);
     a76:	90 bd       	out	0x20, r25	; 32
     a78:	89 b9       	out	0x09, r24	; 9
     a7a:	54 9a       	sbi	0x0a, 4	; 10
     a7c:	53 9a       	sbi	0x0a, 3	; 10
     a7e:	8e e8       	ldi	r24, 0x8E	; 142
     a80:	80 bd       	out	0x20, r24	; 32
     a82:	08 95       	ret

00000a84 <UART_SendChar>:
     a84:	5d 9b       	sbis	0x0b, 5	; 11
     a86:	fe cf       	rjmp	.-4      	; 0xa84 <UART_SendChar>
     a88:	8c b9       	out	0x0c, r24	; 12
     a8a:	08 95       	ret

00000a8c <UART_putChar>:
     a8c:	0e 94 42 05 	call	0xa84	; 0xa84 <UART_SendChar>
     a90:	80 e0       	ldi	r24, 0x00	; 0
     a92:	90 e0       	ldi	r25, 0x00	; 0
     a94:	08 95       	ret

00000a96 <UART_ReceiveChar>:
     a96:	5f 9b       	sbis	0x0b, 7	; 11
     a98:	fe cf       	rjmp	.-4      	; 0xa96 <UART_ReceiveChar>
     a9a:	8c b1       	in	r24, 0x0c	; 12
     a9c:	08 95       	ret

00000a9e <UART_getChar>:
     a9e:	cf 93       	push	r28
     aa0:	0e 94 4b 05 	call	0xa96	; 0xa96 <UART_ReceiveChar>
     aa4:	c8 2f       	mov	r28, r24
     aa6:	0e 94 42 05 	call	0xa84	; 0xa84 <UART_SendChar>
     aaa:	8c 2f       	mov	r24, r28
     aac:	90 e0       	ldi	r25, 0x00	; 0
     aae:	cf 91       	pop	r28
     ab0:	08 95       	ret

00000ab2 <URAT_initStudio>:
     ab2:	ef e0       	ldi	r30, 0x0F	; 15
     ab4:	f2 e0       	ldi	r31, 0x02	; 2
     ab6:	8e e0       	ldi	r24, 0x0E	; 14
     ab8:	91 e0       	ldi	r25, 0x01	; 1
     aba:	93 83       	std	Z+3, r25	; 0x03
     abc:	82 83       	std	Z+2, r24	; 0x02
     abe:	80 e0       	ldi	r24, 0x00	; 0
     ac0:	91 e0       	ldi	r25, 0x01	; 1
     ac2:	91 83       	std	Z+1, r25	; 0x01
     ac4:	80 83       	st	Z, r24
     ac6:	08 95       	ret

00000ac8 <UART_EnableReceiveInterrupt>:
     ac8:	57 9a       	sbi	0x0a, 7	; 10
     aca:	08 95       	ret

00000acc <__vector_19>:
}

// UART mottaksavbrotvektor USART0_RX_vect
ISR(USART0_RXC_vect) {
     acc:	1f 92       	push	r1
     ace:	0f 92       	push	r0
     ad0:	0f b6       	in	r0, 0x3f	; 63
     ad2:	0f 92       	push	r0
     ad4:	11 24       	eor	r1, r1
     ad6:	8f 93       	push	r24
	// Handter mottatt data
	char received = UDR0;
     ad8:	8c b1       	in	r24, 0x0c	; 12
}
     ada:	8f 91       	pop	r24
     adc:	0f 90       	pop	r0
     ade:	0f be       	out	0x3f, r0	; 63
     ae0:	0f 90       	pop	r0
     ae2:	1f 90       	pop	r1
     ae4:	18 95       	reti

00000ae6 <main>:

#include "DriverUART.h"
#include "SRAM.h"
#include "Menu_init.h"

int main(void) {
     ae6:	cf 93       	push	r28
     ae8:	df 93       	push	r29
     aea:	cd b7       	in	r28, 0x3d	; 61
     aec:	de b7       	in	r29, 0x3e	; 62
     aee:	2f 97       	sbiw	r28, 0x0f	; 15
     af0:	0f b6       	in	r0, 0x3f	; 63
     af2:	f8 94       	cli
     af4:	de bf       	out	0x3e, r29	; 62
     af6:	0f be       	out	0x3f, r0	; 63
     af8:	cd bf       	out	0x3d, r28	; 61
	/*_________________INITIALISERINGER START______________________*/
	// Initialiser UART med baudrate 9600
	UART_Init(MYUBBR);
     afa:	8f e1       	ldi	r24, 0x1F	; 31
     afc:	90 e0       	ldi	r25, 0x00	; 0
     afe:	0e 94 3b 05 	call	0xa76	; 0xa76 <UART_Init>
	URAT_initStudio();
     b02:	0e 94 59 05 	call	0xab2	; 0xab2 <URAT_initStudio>
	UART_EnableReceiveInterrupt();
     b06:	0e 94 64 05 	call	0xac8	; 0xac8 <UART_EnableReceiveInterrupt>
    setup_timer();						// Start millisekundteljinga
     b0a:	0e 94 72 0c 	call	0x18e4	; 0x18e4 <setup_timer>
	sei();								// Aktiver globale avbrot
     b0e:	78 94       	sei
	externalMemoryInit();				// Initialiser eksternt minne må vere etter sei
     b10:	0e 94 85 0c 	call	0x190a	; 0x190a <externalMemoryInit>
	initialize_menus();
     b14:	0e 94 f6 06 	call	0xdec	; 0xdec <initialize_menus>
	MultiBoard board;
	MultiBoard_Init(&board);			// Initialiser MultiBoard og kalibrer joystickens origo
     b18:	ce 01       	movw	r24, r28
     b1a:	01 96       	adiw	r24, 0x01	; 1
     b1c:	0e 94 12 08 	call	0x1024	; 0x1024 <MultiBoard_Init>
	oled_init();						// Initialiser OLED-skjermen
     b20:	0e 94 25 09 	call	0x124a	; 0x124a <oled_init>
	//current_menu = &mainMenu;
	

	/*_______TEST OLED______________________*/
	
	oled_home();
     b24:	0e 94 1e 09 	call	0x123c	; 0x123c <oled_home>
	oled_write_screen_to_SRAM(smiley);
     b28:	80 e7       	ldi	r24, 0x70	; 112
     b2a:	94 e0       	ldi	r25, 0x04	; 4
     b2c:	0e 94 ba 09 	call	0x1374	; 0x1374 <oled_write_screen_to_SRAM>
	oled_data_from_SRAM();
     b30:	0e 94 68 09 	call	0x12d0	; 0x12d0 <oled_data_from_SRAM>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     b34:	2f ef       	ldi	r18, 0xFF	; 255
     b36:	8f ef       	ldi	r24, 0xFF	; 255
     b38:	9e e0       	ldi	r25, 0x0E	; 14
     b3a:	21 50       	subi	r18, 0x01	; 1
     b3c:	80 40       	sbci	r24, 0x00	; 0
     b3e:	90 40       	sbci	r25, 0x00	; 0
     b40:	e1 f7       	brne	.-8      	; 0xb3a <main+0x54>
     b42:	00 c0       	rjmp	.+0      	; 0xb44 <main+0x5e>
     b44:	00 00       	nop
	_delay_ms(1000); //smile litt før start
	
	//linje og slikt
	oled_clear_screen();
     b46:	0e 94 26 0b 	call	0x164c	; 0x164c <oled_clear_screen>
	oled_draw_line(10, 10, 100, 50);
     b4a:	22 e3       	ldi	r18, 0x32	; 50
     b4c:	44 e6       	ldi	r20, 0x64	; 100
     b4e:	6a e0       	ldi	r22, 0x0A	; 10
     b50:	8a e0       	ldi	r24, 0x0A	; 10
     b52:	0e 94 36 0b 	call	0x166c	; 0x166c <oled_draw_line>
	oled_draw_circle(64, 32, 20);
     b56:	44 e1       	ldi	r20, 0x14	; 20
     b58:	50 e0       	ldi	r21, 0x00	; 0
     b5a:	60 e2       	ldi	r22, 0x20	; 32
     b5c:	70 e0       	ldi	r23, 0x00	; 0
     b5e:	80 e4       	ldi	r24, 0x40	; 64
     b60:	90 e0       	ldi	r25, 0x00	; 0
     b62:	0e 94 99 0b 	call	0x1732	; 0x1732 <oled_draw_circle>
	oled_draw_square(20, 20, 40, 30);
     b66:	2e e1       	ldi	r18, 0x1E	; 30
     b68:	48 e2       	ldi	r20, 0x28	; 40
     b6a:	64 e1       	ldi	r22, 0x14	; 20
     b6c:	84 e1       	ldi	r24, 0x14	; 20
     b6e:	0e 94 09 0c 	call	0x1812	; 0x1812 <oled_draw_square>
	oled_data_from_SRAM();
     b72:	0e 94 68 09 	call	0x12d0	; 0x12d0 <oled_data_from_SRAM>
     b76:	2f ef       	ldi	r18, 0xFF	; 255
     b78:	8f ef       	ldi	r24, 0xFF	; 255
     b7a:	9e e0       	ldi	r25, 0x0E	; 14
     b7c:	21 50       	subi	r18, 0x01	; 1
     b7e:	80 40       	sbci	r24, 0x00	; 0
     b80:	90 40       	sbci	r25, 0x00	; 0
     b82:	e1 f7       	brne	.-8      	; 0xb7c <main+0x96>
     b84:	00 c0       	rjmp	.+0      	; 0xb86 <main+0xa0>
     b86:	00 00       	nop
	_delay_ms(1000);
	oled_write_FULLscreen_to_SRAM(emoji_sunglasses_1024);
     b88:	80 e7       	ldi	r24, 0x70	; 112
     b8a:	90 e0       	ldi	r25, 0x00	; 0
     b8c:	0e 94 25 0a 	call	0x144a	; 0x144a <oled_write_FULLscreen_to_SRAM>
	oled_data_from_SRAM();
     b90:	0e 94 68 09 	call	0x12d0	; 0x12d0 <oled_data_from_SRAM>
     b94:	2f ef       	ldi	r18, 0xFF	; 255
     b96:	8f ef       	ldi	r24, 0xFF	; 255
     b98:	9e e0       	ldi	r25, 0x0E	; 14
     b9a:	21 50       	subi	r18, 0x01	; 1
     b9c:	80 40       	sbci	r24, 0x00	; 0
     b9e:	90 40       	sbci	r25, 0x00	; 0
     ba0:	e1 f7       	brne	.-8      	; 0xb9a <main+0xb4>
     ba2:	00 c0       	rjmp	.+0      	; 0xba4 <main+0xbe>
     ba4:	00 00       	nop
	_delay_ms(1000);
	oled_write_FULLscreen_to_SRAM(&mainMenu.items);
     ba6:	83 e0       	ldi	r24, 0x03	; 3
     ba8:	92 e0       	ldi	r25, 0x02	; 2
     baa:	0e 94 25 0a 	call	0x144a	; 0x144a <oled_write_FULLscreen_to_SRAM>
	oled_data_from_SRAM();
     bae:	0e 94 68 09 	call	0x12d0	; 0x12d0 <oled_data_from_SRAM>
     bb2:	2f ef       	ldi	r18, 0xFF	; 255
     bb4:	8f ef       	ldi	r24, 0xFF	; 255
     bb6:	9e e0       	ldi	r25, 0x0E	; 14
     bb8:	21 50       	subi	r18, 0x01	; 1
     bba:	80 40       	sbci	r24, 0x00	; 0
     bbc:	90 40       	sbci	r25, 0x00	; 0
     bbe:	e1 f7       	brne	.-8      	; 0xbb8 <main+0xd2>
     bc0:	00 c0       	rjmp	.+0      	; 0xbc2 <main+0xdc>
     bc2:	00 00       	nop
	_delay_ms(1000);
	
	/*_______HOVUDLØKKE______*/
	 while (1) {

        menu_navigate(&board, &current_menu);  // Kallar `menu_navigate` med referanse til gjeldande meny
     bc4:	66 ef       	ldi	r22, 0xF6	; 246
     bc6:	71 e0       	ldi	r23, 0x01	; 1
     bc8:	ce 01       	movw	r24, r28
     bca:	01 96       	adiw	r24, 0x01	; 1
     bcc:	0e 94 af 06 	call	0xd5e	; 0xd5e <menu_navigate>
		
		/*Så lenge vi ikkje har noko delay gåandes og ditta står her tenker eg 
		at den oppdateres automatisk med det minnet vi har skreve til sramen?
		Det kunne vert fornuftig med eit flag her då
		*/
		if (get_time_in_ms() >= 16) {
     bd0:	0e 94 67 0c 	call	0x18ce	; 0x18ce <get_time_in_ms>
     bd4:	60 31       	cpi	r22, 0x10	; 16
     bd6:	71 05       	cpc	r23, r1
     bd8:	81 05       	cpc	r24, r1
     bda:	91 05       	cpc	r25, r1
     bdc:	98 f3       	brcs	.-26     	; 0xbc4 <main+0xde>
			restart_timer();
     bde:	0e 94 7a 0c 	call	0x18f4	; 0x18f4 <restart_timer>
			oled_data_from_SRAM();
     be2:	0e 94 68 09 	call	0x12d0	; 0x12d0 <oled_data_from_SRAM>
     be6:	ee cf       	rjmp	.-36     	; 0xbc4 <main+0xde>

00000be8 <oled_display_menu>:
}

// Sjekker om joystick-knappen er trykt
uint8_t is_joystick_button_pressed(MultiBoard* board) {
	return (board->JoyBtn != 0);  // Anta at knappen er aktiv-høg (1 betyr trykt)
}
     be8:	cf 92       	push	r12
     bea:	df 92       	push	r13
     bec:	ef 92       	push	r14
     bee:	ff 92       	push	r15
     bf0:	1f 93       	push	r17
     bf2:	cf 93       	push	r28
     bf4:	df 93       	push	r29
     bf6:	cd b7       	in	r28, 0x3d	; 61
     bf8:	de b7       	in	r29, 0x3e	; 62
     bfa:	c0 59       	subi	r28, 0x90	; 144
     bfc:	d1 09       	sbc	r29, r1
     bfe:	0f b6       	in	r0, 0x3f	; 63
     c00:	f8 94       	cli
     c02:	de bf       	out	0x3e, r29	; 62
     c04:	0f be       	out	0x3f, r0	; 63
     c06:	cd bf       	out	0x3d, r28	; 61
     c08:	6c 01       	movw	r12, r24
     c0a:	fe 01       	movw	r30, r28
     c0c:	71 96       	adiw	r30, 0x11	; 17
     c0e:	80 e8       	ldi	r24, 0x80	; 128
     c10:	df 01       	movw	r26, r30
     c12:	1d 92       	st	X+, r1
     c14:	8a 95       	dec	r24
     c16:	e9 f7       	brne	.-6      	; 0xc12 <oled_display_menu+0x2a>
     c18:	7f 01       	movw	r14, r30
     c1a:	10 e0       	ldi	r17, 0x00	; 0
     c1c:	f6 01       	movw	r30, r12
     c1e:	84 81       	ldd	r24, Z+4	; 0x04
     c20:	81 0f       	add	r24, r17
     c22:	95 81       	ldd	r25, Z+5	; 0x05
     c24:	89 17       	cp	r24, r25
     c26:	b0 f4       	brcc	.+44     	; 0xc54 <oled_display_menu+0x6c>
     c28:	60 81       	ld	r22, Z
     c2a:	71 81       	ldd	r23, Z+1	; 0x01
     c2c:	f0 e1       	ldi	r31, 0x10	; 16
     c2e:	8f 9f       	mul	r24, r31
     c30:	60 0d       	add	r22, r0
     c32:	71 1d       	adc	r23, r1
     c34:	11 24       	eor	r1, r1
     c36:	4f e0       	ldi	r20, 0x0F	; 15
     c38:	50 e0       	ldi	r21, 0x00	; 0
     c3a:	ce 01       	movw	r24, r28
     c3c:	01 96       	adiw	r24, 0x01	; 1
     c3e:	0e 94 1e 0d 	call	0x1a3c	; 0x1a3c <strncpy_P>
     c42:	18 8a       	std	Y+16, r1	; 0x10
     c44:	40 e1       	ldi	r20, 0x10	; 16
     c46:	50 e0       	ldi	r21, 0x00	; 0
     c48:	be 01       	movw	r22, r28
     c4a:	6f 5f       	subi	r22, 0xFF	; 255
     c4c:	7f 4f       	sbci	r23, 0xFF	; 255
     c4e:	c7 01       	movw	r24, r14
     c50:	0e 94 2d 0d 	call	0x1a5a	; 0x1a5a <strncpy>
     c54:	1f 5f       	subi	r17, 0xFF	; 255
     c56:	80 e1       	ldi	r24, 0x10	; 16
     c58:	e8 0e       	add	r14, r24
     c5a:	f1 1c       	adc	r15, r1
     c5c:	18 30       	cpi	r17, 0x08	; 8
     c5e:	f1 f6       	brne	.-68     	; 0xc1c <oled_display_menu+0x34>
     c60:	ce 01       	movw	r24, r28
     c62:	41 96       	adiw	r24, 0x11	; 17
     c64:	0e 94 ba 09 	call	0x1374	; 0x1374 <oled_write_screen_to_SRAM>
     c68:	d6 01       	movw	r26, r12
     c6a:	12 96       	adiw	r26, 0x02	; 2
     c6c:	8c 91       	ld	r24, X
     c6e:	12 97       	sbiw	r26, 0x02	; 2
     c70:	14 96       	adiw	r26, 0x04	; 4
     c72:	9c 91       	ld	r25, X
     c74:	4e e3       	ldi	r20, 0x3E	; 62
     c76:	60 e0       	ldi	r22, 0x00	; 0
     c78:	89 1b       	sub	r24, r25
     c7a:	0e 94 b5 0a 	call	0x156a	; 0x156a <oled_write_char_to_SRAM>
     c7e:	c0 57       	subi	r28, 0x70	; 112
     c80:	df 4f       	sbci	r29, 0xFF	; 255
     c82:	0f b6       	in	r0, 0x3f	; 63
     c84:	f8 94       	cli
     c86:	de bf       	out	0x3e, r29	; 62
     c88:	0f be       	out	0x3f, r0	; 63
     c8a:	cd bf       	out	0x3d, r28	; 61
     c8c:	df 91       	pop	r29
     c8e:	cf 91       	pop	r28
     c90:	1f 91       	pop	r17
     c92:	ff 90       	pop	r15
     c94:	ef 90       	pop	r14
     c96:	df 90       	pop	r13
     c98:	cf 90       	pop	r12
     c9a:	08 95       	ret

00000c9c <update_menu_arrows>:
     c9c:	cf 93       	push	r28
     c9e:	c8 2f       	mov	r28, r24
     ca0:	86 2f       	mov	r24, r22
     ca2:	40 e2       	ldi	r20, 0x20	; 32
     ca4:	60 e0       	ldi	r22, 0x00	; 0
     ca6:	0e 94 b5 0a 	call	0x156a	; 0x156a <oled_write_char_to_SRAM>
     caa:	4e e3       	ldi	r20, 0x3E	; 62
     cac:	60 e0       	ldi	r22, 0x00	; 0
     cae:	8c 2f       	mov	r24, r28
     cb0:	0e 94 b5 0a 	call	0x156a	; 0x156a <oled_write_char_to_SRAM>
     cb4:	cf 91       	pop	r28
     cb6:	08 95       	ret

00000cb8 <update_menu_position_from_joystick>:
     cb8:	fb 01       	movw	r30, r22
     cba:	dc 01       	movw	r26, r24
     cbc:	1b 96       	adiw	r26, 0x0b	; 11
     cbe:	8d 91       	ld	r24, X+
     cc0:	9c 91       	ld	r25, X
     cc2:	1c 97       	sbiw	r26, 0x0c	; 12
     cc4:	83 33       	cpi	r24, 0x33	; 51
     cc6:	91 05       	cpc	r25, r1
     cc8:	fc f0       	brlt	.+62     	; 0xd08 <update_menu_position_from_joystick+0x50>
     cca:	62 81       	ldd	r22, Z+2	; 0x02
     ccc:	66 23       	and	r22, r22
     cce:	09 f4       	brne	.+2      	; 0xcd2 <update_menu_position_from_joystick+0x1a>
     cd0:	45 c0       	rjmp	.+138    	; 0xd5c <update_menu_position_from_joystick+0xa4>
     cd2:	63 83       	std	Z+3, r22	; 0x03
     cd4:	8f ef       	ldi	r24, 0xFF	; 255
     cd6:	86 0f       	add	r24, r22
     cd8:	82 83       	std	Z+2, r24	; 0x02
     cda:	94 81       	ldd	r25, Z+4	; 0x04
     cdc:	89 17       	cp	r24, r25
     cde:	30 f4       	brcc	.+12     	; 0xcec <update_menu_position_from_joystick+0x34>
     ce0:	91 50       	subi	r25, 0x01	; 1
     ce2:	94 83       	std	Z+4, r25	; 0x04
     ce4:	cf 01       	movw	r24, r30
     ce6:	0e 94 f4 05 	call	0xbe8	; 0xbe8 <oled_display_menu>
     cea:	04 c0       	rjmp	.+8      	; 0xcf4 <update_menu_position_from_joystick+0x3c>
     cec:	69 1b       	sub	r22, r25
     cee:	89 1b       	sub	r24, r25
     cf0:	0e 94 4e 06 	call	0xc9c	; 0xc9c <update_menu_arrows>
     cf4:	bf ef       	ldi	r27, 0xFF	; 255
     cf6:	2f ef       	ldi	r18, 0xFF	; 255
     cf8:	82 e0       	ldi	r24, 0x02	; 2
     cfa:	b1 50       	subi	r27, 0x01	; 1
     cfc:	20 40       	sbci	r18, 0x00	; 0
     cfe:	80 40       	sbci	r24, 0x00	; 0
     d00:	e1 f7       	brne	.-8      	; 0xcfa <update_menu_position_from_joystick+0x42>
     d02:	00 c0       	rjmp	.+0      	; 0xd04 <update_menu_position_from_joystick+0x4c>
     d04:	00 c0       	rjmp	.+0      	; 0xd06 <update_menu_position_from_joystick+0x4e>
     d06:	08 95       	ret
     d08:	8e 3c       	cpi	r24, 0xCE	; 206
     d0a:	9f 4f       	sbci	r25, 0xFF	; 255
     d0c:	3c f5       	brge	.+78     	; 0xd5c <update_menu_position_from_joystick+0xa4>
     d0e:	62 81       	ldd	r22, Z+2	; 0x02
     d10:	26 2f       	mov	r18, r22
     d12:	30 e0       	ldi	r19, 0x00	; 0
     d14:	85 81       	ldd	r24, Z+5	; 0x05
     d16:	90 e0       	ldi	r25, 0x00	; 0
     d18:	01 97       	sbiw	r24, 0x01	; 1
     d1a:	28 17       	cp	r18, r24
     d1c:	39 07       	cpc	r19, r25
     d1e:	f4 f4       	brge	.+60     	; 0xd5c <update_menu_position_from_joystick+0xa4>
     d20:	63 83       	std	Z+3, r22	; 0x03
     d22:	81 e0       	ldi	r24, 0x01	; 1
     d24:	86 0f       	add	r24, r22
     d26:	82 83       	std	Z+2, r24	; 0x02
     d28:	94 81       	ldd	r25, Z+4	; 0x04
     d2a:	48 2f       	mov	r20, r24
     d2c:	50 e0       	ldi	r21, 0x00	; 0
     d2e:	29 2f       	mov	r18, r25
     d30:	30 e0       	ldi	r19, 0x00	; 0
     d32:	28 5f       	subi	r18, 0xF8	; 248
     d34:	3f 4f       	sbci	r19, 0xFF	; 255
     d36:	42 17       	cp	r20, r18
     d38:	53 07       	cpc	r21, r19
     d3a:	1c f0       	brlt	.+6      	; 0xd42 <update_menu_position_from_joystick+0x8a>
     d3c:	9f 5f       	subi	r25, 0xFF	; 255
     d3e:	94 83       	std	Z+4, r25	; 0x04
     d40:	04 c0       	rjmp	.+8      	; 0xd4a <update_menu_position_from_joystick+0x92>
     d42:	69 1b       	sub	r22, r25
     d44:	89 1b       	sub	r24, r25
     d46:	0e 94 4e 06 	call	0xc9c	; 0xc9c <update_menu_arrows>
     d4a:	bf ef       	ldi	r27, 0xFF	; 255
     d4c:	2f ef       	ldi	r18, 0xFF	; 255
     d4e:	82 e0       	ldi	r24, 0x02	; 2
     d50:	b1 50       	subi	r27, 0x01	; 1
     d52:	20 40       	sbci	r18, 0x00	; 0
     d54:	80 40       	sbci	r24, 0x00	; 0
     d56:	e1 f7       	brne	.-8      	; 0xd50 <update_menu_position_from_joystick+0x98>
     d58:	00 c0       	rjmp	.+0      	; 0xd5a <update_menu_position_from_joystick+0xa2>
     d5a:	00 c0       	rjmp	.+0      	; 0xd5c <update_menu_position_from_joystick+0xa4>
     d5c:	08 95       	ret

00000d5e <menu_navigate>:
tillater oss å modifisere pekeren som peker til den aktive menyen 
(f.eks. current_menu) inne i funksjonen. Dette er nyttig hvis vi trenger 
å bytte meny underveis, f.eks. fra hovedmeny til innstillingsmeny.
- Ganske fett
*/
void menu_navigate(MultiBoard* board, Menu** menu) {
     d5e:	0f 93       	push	r16
     d60:	1f 93       	push	r17
     d62:	cf 93       	push	r28
     d64:	df 93       	push	r29
     d66:	ec 01       	movw	r28, r24
     d68:	8b 01       	movw	r16, r22

	// Oppdater joystick- og menyposisjon
	MultiBoard_Update(board);
     d6a:	0e 94 a8 08 	call	0x1150	; 0x1150 <MultiBoard_Update>
	update_menu_position_from_joystick(board, *menu);
     d6e:	f8 01       	movw	r30, r16
     d70:	60 81       	ld	r22, Z
     d72:	71 81       	ldd	r23, Z+1	; 0x01
     d74:	ce 01       	movw	r24, r28
     d76:	0e 94 5c 06 	call	0xcb8	; 0xcb8 <update_menu_position_from_joystick>

	// Sjekk om knappen er trykt for å bekrefte menyval
	if (is_joystick_button_pressed(board)) {
     d7a:	8e 81       	ldd	r24, Y+6	; 0x06
     d7c:	88 23       	and	r24, r24
     d7e:	31 f1       	breq	.+76     	; 0xdcc <menu_navigate+0x6e>
		oled_write_screen_to_SRAM(smiley);
     d80:	80 e7       	ldi	r24, 0x70	; 112
     d82:	94 e0       	ldi	r25, 0x04	; 4
     d84:	0e 94 ba 09 	call	0x1374	; 0x1374 <oled_write_screen_to_SRAM>
		oled_data_from_SRAM();
     d88:	0e 94 68 09 	call	0x12d0	; 0x12d0 <oled_data_from_SRAM>
     d8c:	ff ef       	ldi	r31, 0xFF	; 255
     d8e:	2f ef       	ldi	r18, 0xFF	; 255
     d90:	8e e0       	ldi	r24, 0x0E	; 14
     d92:	f1 50       	subi	r31, 0x01	; 1
     d94:	20 40       	sbci	r18, 0x00	; 0
     d96:	80 40       	sbci	r24, 0x00	; 0
     d98:	e1 f7       	brne	.-8      	; 0xd92 <menu_navigate+0x34>
     d9a:	00 c0       	rjmp	.+0      	; 0xd9c <menu_navigate+0x3e>
     d9c:	00 00       	nop
		_delay_ms(1000);
		oled_clear_screen();
     d9e:	0e 94 26 0b 	call	0x164c	; 0x164c <oled_clear_screen>
		oled_data_from_SRAM();
     da2:	0e 94 68 09 	call	0x12d0	; 0x12d0 <oled_data_from_SRAM>
     da6:	9f ef       	ldi	r25, 0xFF	; 255
     da8:	ef ef       	ldi	r30, 0xFF	; 255
     daa:	fe e0       	ldi	r31, 0x0E	; 14
     dac:	91 50       	subi	r25, 0x01	; 1
     dae:	e0 40       	sbci	r30, 0x00	; 0
     db0:	f0 40       	sbci	r31, 0x00	; 0
     db2:	e1 f7       	brne	.-8      	; 0xdac <menu_navigate+0x4e>
     db4:	00 c0       	rjmp	.+0      	; 0xdb6 <menu_navigate+0x58>
     db6:	00 00       	nop
		_delay_ms(1000);
		handleMenuSelection(board, *menu);  // Behandlar menyvalet
     db8:	f8 01       	movw	r30, r16
     dba:	60 81       	ld	r22, Z
     dbc:	71 81       	ldd	r23, Z+1	; 0x01
     dbe:	ce 01       	movw	r24, r28
     dc0:	0e 94 2c 07 	call	0xe58	; 0xe58 <handleMenuSelection>
		menu_changed = 1;  // Menyen vil endre seg etter valet
     dc4:	81 e0       	ldi	r24, 0x01	; 1
     dc6:	80 93 1c 01 	sts	0x011C, r24	; 0x80011c <menu_changed>
     dca:	04 c0       	rjmp	.+8      	; 0xdd4 <menu_navigate+0x76>
	}
	// Sjekk om menyen har endra seg
	if (menu_changed == 1) {
     dcc:	80 91 1c 01 	lds	r24, 0x011C	; 0x80011c <menu_changed>
     dd0:	81 30       	cpi	r24, 0x01	; 1
     dd2:	39 f4       	brne	.+14     	; 0xde2 <menu_navigate+0x84>
		oled_display_menu(*menu);  // Oppdater OLED med den nye menyen
     dd4:	f8 01       	movw	r30, r16
     dd6:	80 81       	ld	r24, Z
     dd8:	91 81       	ldd	r25, Z+1	; 0x01
     dda:	0e 94 f4 05 	call	0xbe8	; 0xbe8 <oled_display_menu>
		menu_changed = 0;  // Nullstill flagget etter oppdatering
     dde:	10 92 1c 01 	sts	0x011C, r1	; 0x80011c <menu_changed>
	}

	
}
     de2:	df 91       	pop	r29
     de4:	cf 91       	pop	r28
     de6:	1f 91       	pop	r17
     de8:	0f 91       	pop	r16
     dea:	08 95       	ret

00000dec <initialize_menus>:
Menu mainMenu;
Menu scrollMenu;
Menu settingsMenu;

void initialize_menus() {
	mainMenu.items = *mainMenuItems;
     dec:	e3 e0       	ldi	r30, 0x03	; 3
     dee:	f2 e0       	ldi	r31, 0x02	; 2
     df0:	88 ee       	ldi	r24, 0xE8	; 232
     df2:	99 e0       	ldi	r25, 0x09	; 9
     df4:	91 83       	std	Z+1, r25	; 0x01
     df6:	80 83       	st	Z, r24
	mainMenu.num_items = 5;
     df8:	85 e0       	ldi	r24, 0x05	; 5
     dfa:	85 83       	std	Z+5, r24	; 0x05
	mainMenu.current_position = 0;
     dfc:	12 82       	std	Z+2, r1	; 0x02
	mainMenu.prev_position = 0;
     dfe:	13 82       	std	Z+3, r1	; 0x03
	mainMenu.scroll_offset = 0;
     e00:	14 82       	std	Z+4, r1	; 0x04

	scrollMenu.items = *scrollMenuItems;
     e02:	a9 e0       	ldi	r26, 0x09	; 9
     e04:	b2 e0       	ldi	r27, 0x02	; 2
     e06:	88 ea       	ldi	r24, 0xA8	; 168
     e08:	98 e0       	ldi	r25, 0x08	; 8
     e0a:	11 96       	adiw	r26, 0x01	; 1
     e0c:	9c 93       	st	X, r25
     e0e:	8e 93       	st	-X, r24
	scrollMenu.num_items = 20;
     e10:	84 e1       	ldi	r24, 0x14	; 20
     e12:	15 96       	adiw	r26, 0x05	; 5
     e14:	8c 93       	st	X, r24
     e16:	15 97       	sbiw	r26, 0x05	; 5
	scrollMenu.current_position = 0;
     e18:	12 96       	adiw	r26, 0x02	; 2
     e1a:	1c 92       	st	X, r1
     e1c:	12 97       	sbiw	r26, 0x02	; 2
	scrollMenu.prev_position = 0;
     e1e:	13 96       	adiw	r26, 0x03	; 3
     e20:	1c 92       	st	X, r1
     e22:	13 97       	sbiw	r26, 0x03	; 3
	scrollMenu.scroll_offset = 0;
     e24:	14 96       	adiw	r26, 0x04	; 4
     e26:	1c 92       	st	X, r1

	settingsMenu.items = *settingsMenuItems;
     e28:	ad ef       	ldi	r26, 0xFD	; 253
     e2a:	b1 e0       	ldi	r27, 0x01	; 1
     e2c:	88 e6       	ldi	r24, 0x68	; 104
     e2e:	98 e0       	ldi	r25, 0x08	; 8
     e30:	11 96       	adiw	r26, 0x01	; 1
     e32:	9c 93       	st	X, r25
     e34:	8e 93       	st	-X, r24
	settingsMenu.num_items = 4;
     e36:	84 e0       	ldi	r24, 0x04	; 4
     e38:	15 96       	adiw	r26, 0x05	; 5
     e3a:	8c 93       	st	X, r24
     e3c:	15 97       	sbiw	r26, 0x05	; 5
	settingsMenu.current_position = 0;
     e3e:	12 96       	adiw	r26, 0x02	; 2
     e40:	1c 92       	st	X, r1
     e42:	12 97       	sbiw	r26, 0x02	; 2
	settingsMenu.prev_position = 0;
     e44:	13 96       	adiw	r26, 0x03	; 3
     e46:	1c 92       	st	X, r1
     e48:	13 97       	sbiw	r26, 0x03	; 3
	settingsMenu.scroll_offset = 0;
     e4a:	14 96       	adiw	r26, 0x04	; 4
     e4c:	1c 92       	st	X, r1
	
	current_menu = &mainMenu;
     e4e:	f0 93 f7 01 	sts	0x01F7, r31	; 0x8001f7 <__data_end+0x1>
     e52:	e0 93 f6 01 	sts	0x01F6, r30	; 0x8001f6 <__data_end>
     e56:	08 95       	ret

00000e58 <handleMenuSelection>:
}

void handleMenuSelection(MultiBoard* board, Menu* menu) {
	switch (currentMenuState) {
     e58:	80 91 f8 01 	lds	r24, 0x01F8	; 0x8001f8 <currentMenuState>
     e5c:	81 30       	cpi	r24, 0x01	; 1
     e5e:	09 f4       	brne	.+2      	; 0xe62 <handleMenuSelection+0xa>
     e60:	c0 c0       	rjmp	.+384    	; 0xfe2 <handleMenuSelection+0x18a>
     e62:	20 f0       	brcs	.+8      	; 0xe6c <handleMenuSelection+0x14>
     e64:	82 30       	cpi	r24, 0x02	; 2
     e66:	09 f4       	brne	.+2      	; 0xe6a <handleMenuSelection+0x12>
     e68:	91 c0       	rjmp	.+290    	; 0xf8c <handleMenuSelection+0x134>
     e6a:	08 95       	ret
		case MAIN_MENU:
		switch (menu->current_position) {
     e6c:	fb 01       	movw	r30, r22
     e6e:	82 81       	ldd	r24, Z+2	; 0x02
     e70:	82 30       	cpi	r24, 0x02	; 2
     e72:	a1 f1       	breq	.+104    	; 0xedc <handleMenuSelection+0x84>
     e74:	28 f4       	brcc	.+10     	; 0xe80 <handleMenuSelection+0x28>
     e76:	88 23       	and	r24, r24
     e78:	51 f0       	breq	.+20     	; 0xe8e <handleMenuSelection+0x36>
     e7a:	81 30       	cpi	r24, 0x01	; 1
     e7c:	b9 f0       	breq	.+46     	; 0xeac <handleMenuSelection+0x54>
     e7e:	72 c0       	rjmp	.+228    	; 0xf64 <handleMenuSelection+0x10c>
     e80:	83 30       	cpi	r24, 0x03	; 3
     e82:	09 f4       	brne	.+2      	; 0xe86 <handleMenuSelection+0x2e>
     e84:	43 c0       	rjmp	.+134    	; 0xf0c <handleMenuSelection+0xb4>
     e86:	84 30       	cpi	r24, 0x04	; 4
     e88:	09 f4       	brne	.+2      	; 0xe8c <handleMenuSelection+0x34>
     e8a:	58 c0       	rjmp	.+176    	; 0xf3c <handleMenuSelection+0xe4>
     e8c:	6b c0       	rjmp	.+214    	; 0xf64 <handleMenuSelection+0x10c>
			case 0:
			oled_write_line_to_SRAM(1, "Caes 0 main");
     e8e:	6d e1       	ldi	r22, 0x1D	; 29
     e90:	71 e0       	ldi	r23, 0x01	; 1
     e92:	81 e0       	ldi	r24, 0x01	; 1
     e94:	0e 94 3d 0a 	call	0x147a	; 0x147a <oled_write_line_to_SRAM>
     e98:	ff ef       	ldi	r31, 0xFF	; 255
     e9a:	2f ef       	ldi	r18, 0xFF	; 255
     e9c:	8e e0       	ldi	r24, 0x0E	; 14
     e9e:	f1 50       	subi	r31, 0x01	; 1
     ea0:	20 40       	sbci	r18, 0x00	; 0
     ea2:	80 40       	sbci	r24, 0x00	; 0
     ea4:	e1 f7       	brne	.-8      	; 0xe9e <handleMenuSelection+0x46>
     ea6:	00 c0       	rjmp	.+0      	; 0xea8 <handleMenuSelection+0x50>
     ea8:	00 00       	nop
     eaa:	08 95       	ret
			_delay_ms(1000);
			break;
			case 1:
			// Gå til innstillingar
			oled_write_line_to_SRAM(1, "Caes 1 main");
     eac:	69 e2       	ldi	r22, 0x29	; 41
     eae:	71 e0       	ldi	r23, 0x01	; 1
     eb0:	81 e0       	ldi	r24, 0x01	; 1
     eb2:	0e 94 3d 0a 	call	0x147a	; 0x147a <oled_write_line_to_SRAM>
     eb6:	9f ef       	ldi	r25, 0xFF	; 255
     eb8:	ef ef       	ldi	r30, 0xFF	; 255
     eba:	fe e0       	ldi	r31, 0x0E	; 14
     ebc:	91 50       	subi	r25, 0x01	; 1
     ebe:	e0 40       	sbci	r30, 0x00	; 0
     ec0:	f0 40       	sbci	r31, 0x00	; 0
     ec2:	e1 f7       	brne	.-8      	; 0xebc <handleMenuSelection+0x64>
     ec4:	00 c0       	rjmp	.+0      	; 0xec6 <handleMenuSelection+0x6e>
     ec6:	00 00       	nop
			_delay_ms(1000);
			currentMenuState = SETTINGS_MENU;
     ec8:	82 e0       	ldi	r24, 0x02	; 2
     eca:	80 93 f8 01 	sts	0x01F8, r24	; 0x8001f8 <currentMenuState>
			current_menu = &settingsMenu;  // Oppdater til innstillingsmeny
     ece:	8d ef       	ldi	r24, 0xFD	; 253
     ed0:	91 e0       	ldi	r25, 0x01	; 1
     ed2:	90 93 f7 01 	sts	0x01F7, r25	; 0x8001f7 <__data_end+0x1>
     ed6:	80 93 f6 01 	sts	0x01F6, r24	; 0x8001f6 <__data_end>
			break;
     eda:	08 95       	ret
			case 2:
			// Gå til scrollemeny
			oled_write_line_to_SRAM(1, "Caes 2 main");
     edc:	65 e3       	ldi	r22, 0x35	; 53
     ede:	71 e0       	ldi	r23, 0x01	; 1
     ee0:	81 e0       	ldi	r24, 0x01	; 1
     ee2:	0e 94 3d 0a 	call	0x147a	; 0x147a <oled_write_line_to_SRAM>
     ee6:	2f ef       	ldi	r18, 0xFF	; 255
     ee8:	8f ef       	ldi	r24, 0xFF	; 255
     eea:	9e e0       	ldi	r25, 0x0E	; 14
     eec:	21 50       	subi	r18, 0x01	; 1
     eee:	80 40       	sbci	r24, 0x00	; 0
     ef0:	90 40       	sbci	r25, 0x00	; 0
     ef2:	e1 f7       	brne	.-8      	; 0xeec <handleMenuSelection+0x94>
     ef4:	00 c0       	rjmp	.+0      	; 0xef6 <handleMenuSelection+0x9e>
     ef6:	00 00       	nop
			_delay_ms(1000);
			currentMenuState = SCROLL_MENU;
     ef8:	81 e0       	ldi	r24, 0x01	; 1
     efa:	80 93 f8 01 	sts	0x01F8, r24	; 0x8001f8 <currentMenuState>
			current_menu = &scrollMenu;  // Oppdater til scrollemeny
     efe:	89 e0       	ldi	r24, 0x09	; 9
     f00:	92 e0       	ldi	r25, 0x02	; 2
     f02:	90 93 f7 01 	sts	0x01F7, r25	; 0x8001f7 <__data_end+0x1>
     f06:	80 93 f6 01 	sts	0x01F6, r24	; 0x8001f6 <__data_end>
			break;
     f0a:	08 95       	ret
			case 3:
			oled_write_line_to_SRAM(0, "Caes 3 main");
     f0c:	61 e4       	ldi	r22, 0x41	; 65
     f0e:	71 e0       	ldi	r23, 0x01	; 1
     f10:	80 e0       	ldi	r24, 0x00	; 0
     f12:	0e 94 3d 0a 	call	0x147a	; 0x147a <oled_write_line_to_SRAM>
     f16:	ef ef       	ldi	r30, 0xFF	; 255
     f18:	ff ef       	ldi	r31, 0xFF	; 255
     f1a:	2e e0       	ldi	r18, 0x0E	; 14
     f1c:	e1 50       	subi	r30, 0x01	; 1
     f1e:	f0 40       	sbci	r31, 0x00	; 0
     f20:	20 40       	sbci	r18, 0x00	; 0
     f22:	e1 f7       	brne	.-8      	; 0xf1c <handleMenuSelection+0xc4>
     f24:	00 c0       	rjmp	.+0      	; 0xf26 <handleMenuSelection+0xce>
     f26:	00 00       	nop
			_delay_ms(1000);
			oled_write_line_to_SRAM(0, "Viser kredittar...");
     f28:	6d e4       	ldi	r22, 0x4D	; 77
     f2a:	71 e0       	ldi	r23, 0x01	; 1
     f2c:	80 e0       	ldi	r24, 0x00	; 0
     f2e:	0e 94 3d 0a 	call	0x147a	; 0x147a <oled_write_line_to_SRAM>
			oled_write_screen_to_SRAM(solkors);  // Vis kredittar på skjermen
     f32:	80 ef       	ldi	r24, 0xF0	; 240
     f34:	94 e0       	ldi	r25, 0x04	; 4
     f36:	0e 94 ba 09 	call	0x1374	; 0x1374 <oled_write_screen_to_SRAM>
			break;
     f3a:	08 95       	ret
			case 4:
			oled_write_line_to_SRAM(0, "Caes 4 main");
     f3c:	60 e6       	ldi	r22, 0x60	; 96
     f3e:	71 e0       	ldi	r23, 0x01	; 1
     f40:	80 e0       	ldi	r24, 0x00	; 0
     f42:	0e 94 3d 0a 	call	0x147a	; 0x147a <oled_write_line_to_SRAM>
     f46:	8f ef       	ldi	r24, 0xFF	; 255
     f48:	9f ef       	ldi	r25, 0xFF	; 255
     f4a:	ee e0       	ldi	r30, 0x0E	; 14
     f4c:	81 50       	subi	r24, 0x01	; 1
     f4e:	90 40       	sbci	r25, 0x00	; 0
     f50:	e0 40       	sbci	r30, 0x00	; 0
     f52:	e1 f7       	brne	.-8      	; 0xf4c <handleMenuSelection+0xf4>
     f54:	00 c0       	rjmp	.+0      	; 0xf56 <handleMenuSelection+0xfe>
     f56:	00 00       	nop
			_delay_ms(1000);
			oled_write_line_to_SRAM(0, "Avsluttar...");
     f58:	6c e6       	ldi	r22, 0x6C	; 108
     f5a:	71 e0       	ldi	r23, 0x01	; 1
     f5c:	80 e0       	ldi	r24, 0x00	; 0
     f5e:	0e 94 3d 0a 	call	0x147a	; 0x147a <oled_write_line_to_SRAM>
			// Legg eventuelt til funksjonalitet for å avslutte
			break;
     f62:	08 95       	ret
			default:
			oled_write_line_to_SRAM(0, "Caes ugyldig main");
     f64:	69 e7       	ldi	r22, 0x79	; 121
     f66:	71 e0       	ldi	r23, 0x01	; 1
     f68:	80 e0       	ldi	r24, 0x00	; 0
     f6a:	0e 94 3d 0a 	call	0x147a	; 0x147a <oled_write_line_to_SRAM>
     f6e:	ff ef       	ldi	r31, 0xFF	; 255
     f70:	2f ef       	ldi	r18, 0xFF	; 255
     f72:	8e e0       	ldi	r24, 0x0E	; 14
     f74:	f1 50       	subi	r31, 0x01	; 1
     f76:	20 40       	sbci	r18, 0x00	; 0
     f78:	80 40       	sbci	r24, 0x00	; 0
     f7a:	e1 f7       	brne	.-8      	; 0xf74 <handleMenuSelection+0x11c>
     f7c:	00 c0       	rjmp	.+0      	; 0xf7e <handleMenuSelection+0x126>
     f7e:	00 00       	nop
			_delay_ms(1000);
			oled_write_line_to_SRAM(0, "Ugyldig valg");
     f80:	6b e8       	ldi	r22, 0x8B	; 139
     f82:	71 e0       	ldi	r23, 0x01	; 1
     f84:	80 e0       	ldi	r24, 0x00	; 0
     f86:	0e 94 3d 0a 	call	0x147a	; 0x147a <oled_write_line_to_SRAM>
			break;
     f8a:	08 95       	ret
		}
		break;

		case SETTINGS_MENU:
		// Håndter valg i innstillingsmenyen
		switch (menu->current_position) {
     f8c:	fb 01       	movw	r30, r22
     f8e:	82 81       	ldd	r24, Z+2	; 0x02
     f90:	81 30       	cpi	r24, 0x01	; 1
     f92:	61 f0       	breq	.+24     	; 0xfac <handleMenuSelection+0x154>
     f94:	28 f0       	brcs	.+10     	; 0xfa0 <handleMenuSelection+0x148>
     f96:	82 30       	cpi	r24, 0x02	; 2
     f98:	79 f0       	breq	.+30     	; 0xfb8 <handleMenuSelection+0x160>
     f9a:	83 30       	cpi	r24, 0x03	; 3
     f9c:	99 f0       	breq	.+38     	; 0xfc4 <handleMenuSelection+0x16c>
     f9e:	1b c0       	rjmp	.+54     	; 0xfd6 <handleMenuSelection+0x17e>
			case 0:
			oled_write_line_to_SRAM(0, "Endrer lydinnstillingar...");
     fa0:	68 e9       	ldi	r22, 0x98	; 152
     fa2:	71 e0       	ldi	r23, 0x01	; 1
     fa4:	80 e0       	ldi	r24, 0x00	; 0
     fa6:	0e 94 3d 0a 	call	0x147a	; 0x147a <oled_write_line_to_SRAM>
			break;
     faa:	08 95       	ret
			case 1:
			oled_write_line_to_SRAM(0, "Endrer lysstyrke...");
     fac:	63 eb       	ldi	r22, 0xB3	; 179
     fae:	71 e0       	ldi	r23, 0x01	; 1
     fb0:	80 e0       	ldi	r24, 0x00	; 0
     fb2:	0e 94 3d 0a 	call	0x147a	; 0x147a <oled_write_line_to_SRAM>
			break;
     fb6:	08 95       	ret
			case 2:
			oled_write_line_to_SRAM(0, "Endrer kontrollar...");
     fb8:	67 ec       	ldi	r22, 0xC7	; 199
     fba:	71 e0       	ldi	r23, 0x01	; 1
     fbc:	80 e0       	ldi	r24, 0x00	; 0
     fbe:	0e 94 3d 0a 	call	0x147a	; 0x147a <oled_write_line_to_SRAM>
			break;
     fc2:	08 95       	ret
			case 3:
			// Gå tilbake til hovudmenyen
			currentMenuState = MAIN_MENU;
     fc4:	10 92 f8 01 	sts	0x01F8, r1	; 0x8001f8 <currentMenuState>
			current_menu = &mainMenu;
     fc8:	83 e0       	ldi	r24, 0x03	; 3
     fca:	92 e0       	ldi	r25, 0x02	; 2
     fcc:	90 93 f7 01 	sts	0x01F7, r25	; 0x8001f7 <__data_end+0x1>
     fd0:	80 93 f6 01 	sts	0x01F6, r24	; 0x8001f6 <__data_end>
			break;
     fd4:	08 95       	ret
			default:
			oled_write_line_to_SRAM(0, "Ugyldig valg");
     fd6:	6b e8       	ldi	r22, 0x8B	; 139
     fd8:	71 e0       	ldi	r23, 0x01	; 1
     fda:	80 e0       	ldi	r24, 0x00	; 0
     fdc:	0e 94 3d 0a 	call	0x147a	; 0x147a <oled_write_line_to_SRAM>
			break;
     fe0:	08 95       	ret
		}
		break;

		case SCROLL_MENU:
		// Håndter valg i scrollemenyen
		switch (menu->current_position) {
     fe2:	fb 01       	movw	r30, r22
     fe4:	82 81       	ldd	r24, Z+2	; 0x02
     fe6:	88 23       	and	r24, r24
     fe8:	19 f0       	breq	.+6      	; 0xff0 <handleMenuSelection+0x198>
     fea:	81 30       	cpi	r24, 0x01	; 1
     fec:	79 f0       	breq	.+30     	; 0x100c <handleMenuSelection+0x1b4>
     fee:	14 c0       	rjmp	.+40     	; 0x1018 <handleMenuSelection+0x1c0>
			case 0:
			oled_write_line_to_SRAM(0, "Item 1 valgt");
     ff0:	6c ed       	ldi	r22, 0xDC	; 220
     ff2:	71 e0       	ldi	r23, 0x01	; 1
     ff4:	80 e0       	ldi	r24, 0x00	; 0
     ff6:	0e 94 3d 0a 	call	0x147a	; 0x147a <oled_write_line_to_SRAM>
			currentMenuState = MAIN_MENU;
     ffa:	10 92 f8 01 	sts	0x01F8, r1	; 0x8001f8 <currentMenuState>
			current_menu = &mainMenu;
     ffe:	83 e0       	ldi	r24, 0x03	; 3
    1000:	92 e0       	ldi	r25, 0x02	; 2
    1002:	90 93 f7 01 	sts	0x01F7, r25	; 0x8001f7 <__data_end+0x1>
    1006:	80 93 f6 01 	sts	0x01F6, r24	; 0x8001f6 <__data_end>
			break;
    100a:	08 95       	ret
			case 1:
			oled_write_line_to_SRAM(0, "Item 2 valgt");
    100c:	69 ee       	ldi	r22, 0xE9	; 233
    100e:	71 e0       	ldi	r23, 0x01	; 1
    1010:	80 e0       	ldi	r24, 0x00	; 0
    1012:	0e 94 3d 0a 	call	0x147a	; 0x147a <oled_write_line_to_SRAM>
			break;
    1016:	08 95       	ret
			default:
			oled_write_line_to_SRAM(0, "Ugyldig valg");
    1018:	6b e8       	ldi	r22, 0x8B	; 139
    101a:	71 e0       	ldi	r23, 0x01	; 1
    101c:	80 e0       	ldi	r24, 0x00	; 0
    101e:	0e 94 3d 0a 	call	0x147a	; 0x147a <oled_write_line_to_SRAM>
    1022:	08 95       	ret

00001024 <MultiBoard_Init>:
 * Created: 14.09.2024 11:00:59
 *  Author: ravneb
 */ 
#include "MultiBoard.h"

void MultiBoard_Init(MultiBoard* board) {
    1024:	cf 93       	push	r28
    1026:	df 93       	push	r29
    1028:	ec 01       	movw	r28, r24
	// Set pinner for knapper som input
	clearBit(DDRB, LEFT_BUTTON_PIN);  // Set Left button pin as input
    102a:	bc 98       	cbi	0x17, 4	; 23
	clearBit(DDRB, RIGHT_BUTTON_PIN); // Set Right button pin as input
    102c:	bb 98       	cbi	0x17, 3	; 23
	clearBit(DDRB, JOY_BUTTON_PIN);   // Set Joystick button pin as input
    102e:	ba 98       	cbi	0x17, 2	; 23
	clearBit(DDRB, BUSY_PIN);         // Set BUSY pin as input
    1030:	b9 98       	cbi	0x17, 1	; 23
	
	// Aktiver pullup
	setBit(PORTB, JOY_BUTTON_PIN);
    1032:	c2 9a       	sbi	0x18, 2	; 24
	

	// Kalibrer joysticken (finn origo)
	Universal_write(ADC_START, 0x80); // For Chip Enable til ADC, (data her er irrelevant)
    1034:	60 e8       	ldi	r22, 0x80	; 128
    1036:	80 e0       	ldi	r24, 0x00	; 0
    1038:	94 e1       	ldi	r25, 0x14	; 20
    103a:	0e 94 b4 0c 	call	0x1968	; 0x1968 <Universal_write>
	loopUntilBitIsClear(PINB, BUSY_PIN);    // Vent til BUSY gï¿½r lav
    103e:	b1 99       	sbic	0x16, 1	; 22
    1040:	fe cf       	rjmp	.-4      	; 0x103e <MultiBoard_Init+0x1a>
	board->JoyYOrigo = Universal_read(ADC_START); //CH0
    1042:	80 e0       	ldi	r24, 0x00	; 0
    1044:	94 e1       	ldi	r25, 0x14	; 20
    1046:	0e 94 c4 0c 	call	0x1988	; 0x1988 <Universal_read>
    104a:	88 87       	std	Y+8, r24	; 0x08
	board->JoyXOrigo = Universal_read(ADC_START); //CH1
    104c:	80 e0       	ldi	r24, 0x00	; 0
    104e:	94 e1       	ldi	r25, 0x14	; 20
    1050:	0e 94 c4 0c 	call	0x1988	; 0x1988 <Universal_read>
    1054:	8f 83       	std	Y+7, r24	; 0x07
	
	// Initialiser alle andre verdier
	board->LSpos = 0;
    1056:	1a 82       	std	Y+2, r1	; 0x02
	board->RSpos = 0;
    1058:	1b 82       	std	Y+3, r1	; 0x03
	board->LBtn = 0;
    105a:	1c 82       	std	Y+4, r1	; 0x04
	board->RBtn = 0;
    105c:	1d 82       	std	Y+5, r1	; 0x05
	board->JoyXpos = 0;
    105e:	19 82       	std	Y+1, r1	; 0x01
	board->JoyYpos = 0;
    1060:	18 82       	st	Y, r1
	board->JoyXposCal = 0;
    1062:	1a 86       	std	Y+10, r1	; 0x0a
    1064:	19 86       	std	Y+9, r1	; 0x09
	board->JoyYposCal = 0;
    1066:	1c 86       	std	Y+12, r1	; 0x0c
    1068:	1b 86       	std	Y+11, r1	; 0x0b
	board->JoyAngle = 0;
    106a:	1e 86       	std	Y+14, r1	; 0x0e
    106c:	1d 86       	std	Y+13, r1	; 0x0d
	board->JoyBtn = 0;  // Endra fra en, vi bruker fortsatt 0 for av basert pÃ¥ logikk i MB_Update()
    106e:	1e 82       	std	Y+6, r1	; 0x06
}
    1070:	df 91       	pop	r29
    1072:	cf 91       	pop	r28
    1074:	08 95       	ret

00001076 <MultiBoard_UpdateJoystickAngle>:
	///IKKJE TESTA
	MultiBoard_UpdateJoystickAngle(board);
}

/// IKKJE TESTA 
void MultiBoard_UpdateJoystickAngle(MultiBoard* board) {
    1076:	fc 01       	movw	r30, r24
	int16_t x = board->JoyXposCal;
    1078:	61 85       	ldd	r22, Z+9	; 0x09
    107a:	72 85       	ldd	r23, Z+10	; 0x0a
	int16_t y = board->JoyYposCal;
    107c:	43 85       	ldd	r20, Z+11	; 0x0b
    107e:	54 85       	ldd	r21, Z+12	; 0x0c

	// Unngï¿½ divisjon med 0 (nï¿½r senterpunkt) + hysterese
	if (!(abs(x) > JOY_ANGLE_HYSTERESIS || abs(y) >  JOY_ANGLE_HYSTERESIS)) {
    1080:	cb 01       	movw	r24, r22
    1082:	05 96       	adiw	r24, 0x05	; 5
    1084:	0b 97       	sbiw	r24, 0x0b	; 11
    1086:	38 f4       	brcc	.+14     	; 0x1096 <MultiBoard_UpdateJoystickAngle+0x20>
    1088:	ca 01       	movw	r24, r20
    108a:	05 96       	adiw	r24, 0x05	; 5
    108c:	0b 97       	sbiw	r24, 0x0b	; 11
    108e:	18 f4       	brcc	.+6      	; 0x1096 <MultiBoard_UpdateJoystickAngle+0x20>
		board->JoyAngle = 0;  // Midtpunkt, sett vinkelen til 0
    1090:	16 86       	std	Z+14, r1	; 0x0e
    1092:	15 86       	std	Z+13, r1	; 0x0d
    1094:	08 95       	ret
		} else {
		// Bestem kvadrant basert pï¿½ verdiane til x og y
		switch ((x >= 0) << 1 | (y >= 0)) {
    1096:	87 2f       	mov	r24, r23
    1098:	80 95       	com	r24
    109a:	88 1f       	adc	r24, r24
    109c:	88 27       	eor	r24, r24
    109e:	88 1f       	adc	r24, r24
    10a0:	90 e0       	ldi	r25, 0x00	; 0
    10a2:	88 0f       	add	r24, r24
    10a4:	99 1f       	adc	r25, r25
    10a6:	25 2f       	mov	r18, r21
    10a8:	20 95       	com	r18
    10aa:	22 1f       	adc	r18, r18
    10ac:	22 27       	eor	r18, r18
    10ae:	22 1f       	adc	r18, r18
    10b0:	82 2b       	or	r24, r18
    10b2:	81 30       	cpi	r24, 0x01	; 1
    10b4:	91 05       	cpc	r25, r1
    10b6:	b9 f0       	breq	.+46     	; 0x10e6 <MultiBoard_UpdateJoystickAngle+0x70>
    10b8:	1c f4       	brge	.+6      	; 0x10c0 <MultiBoard_UpdateJoystickAngle+0x4a>
    10ba:	89 2b       	or	r24, r25
    10bc:	29 f1       	breq	.+74     	; 0x1108 <MultiBoard_UpdateJoystickAngle+0x92>
    10be:	45 c0       	rjmp	.+138    	; 0x114a <MultiBoard_UpdateJoystickAngle+0xd4>
    10c0:	82 30       	cpi	r24, 0x02	; 2
    10c2:	91 05       	cpc	r25, r1
    10c4:	99 f1       	breq	.+102    	; 0x112c <MultiBoard_UpdateJoystickAngle+0xb6>
    10c6:	03 97       	sbiw	r24, 0x03	; 3
    10c8:	09 f0       	breq	.+2      	; 0x10cc <MultiBoard_UpdateJoystickAngle+0x56>
    10ca:	3f c0       	rjmp	.+126    	; 0x114a <MultiBoard_UpdateJoystickAngle+0xd4>
			case 0b11:  // Fï¿½rste kvadrant (x >= 0, y >= 0)
			board->JoyAngle = (y * 90) / (x + y);
    10cc:	2a e5       	ldi	r18, 0x5A	; 90
    10ce:	24 9f       	mul	r18, r20
    10d0:	c0 01       	movw	r24, r0
    10d2:	25 9f       	mul	r18, r21
    10d4:	90 0d       	add	r25, r0
    10d6:	11 24       	eor	r1, r1
    10d8:	64 0f       	add	r22, r20
    10da:	75 1f       	adc	r23, r21
    10dc:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <__divmodhi4>
    10e0:	76 87       	std	Z+14, r23	; 0x0e
    10e2:	65 87       	std	Z+13, r22	; 0x0d
			break;
    10e4:	08 95       	ret
			case 0b01:  // Andre kvadrant (x < 0, y >= 0)
			board->JoyAngle = 90 + ((-x * 90) / (-x + y));
    10e6:	26 ea       	ldi	r18, 0xA6	; 166
    10e8:	26 03       	mulsu	r18, r22
    10ea:	c0 01       	movw	r24, r0
    10ec:	27 9f       	mul	r18, r23
    10ee:	90 0d       	add	r25, r0
    10f0:	11 24       	eor	r1, r1
    10f2:	9a 01       	movw	r18, r20
    10f4:	26 1b       	sub	r18, r22
    10f6:	37 0b       	sbc	r19, r23
    10f8:	b9 01       	movw	r22, r18
    10fa:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <__divmodhi4>
    10fe:	66 5a       	subi	r22, 0xA6	; 166
    1100:	7f 4f       	sbci	r23, 0xFF	; 255
    1102:	76 87       	std	Z+14, r23	; 0x0e
    1104:	65 87       	std	Z+13, r22	; 0x0d
			break;
    1106:	08 95       	ret
			case 0b00:  // Tredje kvadrant (x < 0, y < 0)
			board->JoyAngle = 180 + ((-y * 90) / (-x - y));
    1108:	26 ea       	ldi	r18, 0xA6	; 166
    110a:	24 03       	mulsu	r18, r20
    110c:	c0 01       	movw	r24, r0
    110e:	25 9f       	mul	r18, r21
    1110:	90 0d       	add	r25, r0
    1112:	11 24       	eor	r1, r1
    1114:	71 95       	neg	r23
    1116:	61 95       	neg	r22
    1118:	71 09       	sbc	r23, r1
    111a:	64 1b       	sub	r22, r20
    111c:	75 0b       	sbc	r23, r21
    111e:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <__divmodhi4>
    1122:	6c 54       	subi	r22, 0x4C	; 76
    1124:	7f 4f       	sbci	r23, 0xFF	; 255
    1126:	76 87       	std	Z+14, r23	; 0x0e
    1128:	65 87       	std	Z+13, r22	; 0x0d
			break;
    112a:	08 95       	ret
			case 0b10:  // Fjerde kvadrant (x >= 0, y < 0)
			board->JoyAngle = 270 + ((x * 90) / (x - y));
    112c:	2a e5       	ldi	r18, 0x5A	; 90
    112e:	26 9f       	mul	r18, r22
    1130:	c0 01       	movw	r24, r0
    1132:	27 9f       	mul	r18, r23
    1134:	90 0d       	add	r25, r0
    1136:	11 24       	eor	r1, r1
    1138:	64 1b       	sub	r22, r20
    113a:	75 0b       	sbc	r23, r21
    113c:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <__divmodhi4>
    1140:	62 5f       	subi	r22, 0xF2	; 242
    1142:	7e 4f       	sbci	r23, 0xFE	; 254
    1144:	76 87       	std	Z+14, r23	; 0x0e
    1146:	65 87       	std	Z+13, r22	; 0x0d
			break;
    1148:	08 95       	ret
			default:
			board->JoyAngle = 0;  // Feiltilfelle, skal ikkje skje
    114a:	16 86       	std	Z+14, r1	; 0x0e
    114c:	15 86       	std	Z+13, r1	; 0x0d
    114e:	08 95       	ret

00001150 <MultiBoard_Update>:
	board->JoyAngle = 0;
	board->JoyBtn = 0;  // Endra fra en, vi bruker fortsatt 0 for av basert pÃ¥ logikk i MB_Update()
}


void MultiBoard_Update(MultiBoard* board) {
    1150:	cf 93       	push	r28
    1152:	df 93       	push	r29
    1154:	ec 01       	movw	r28, r24
	// Velg kanal for venstre skyvebryter (LSpos)
	Universal_write(ADC_START, 0x00);
    1156:	60 e0       	ldi	r22, 0x00	; 0
    1158:	80 e0       	ldi	r24, 0x00	; 0
    115a:	94 e1       	ldi	r25, 0x14	; 20
    115c:	0e 94 b4 0c 	call	0x1968	; 0x1968 <Universal_write>
	loopUntilBitIsClear(PINB, BUSY_PIN);		// Vent til BUSY gï¿½r lav - klar for ï¿½ sende pï¿½ ny
    1160:	b1 99       	sbic	0x16, 1	; 22
    1162:	fe cf       	rjmp	.-4      	; 0x1160 <MultiBoard_Update+0x10>
	board->JoyYpos = Universal_read(ADC_START); //  - CH0 fï¿½rste RD low gir channel 0
    1164:	80 e0       	ldi	r24, 0x00	; 0
    1166:	94 e1       	ldi	r25, 0x14	; 20
    1168:	0e 94 c4 0c 	call	0x1988	; 0x1988 <Universal_read>
    116c:	88 83       	st	Y, r24
	board->JoyXpos = Universal_read(ADC_START); //	- CH1 andre RD low gir channel 1
    116e:	80 e0       	ldi	r24, 0x00	; 0
    1170:	94 e1       	ldi	r25, 0x14	; 20
    1172:	0e 94 c4 0c 	call	0x1988	; 0x1988 <Universal_read>
    1176:	89 83       	std	Y+1, r24	; 0x01
	board->RSpos = Universal_read(ADC_START);	//	- CH2
    1178:	80 e0       	ldi	r24, 0x00	; 0
    117a:	94 e1       	ldi	r25, 0x14	; 20
    117c:	0e 94 c4 0c 	call	0x1988	; 0x1988 <Universal_read>
    1180:	8b 83       	std	Y+3, r24	; 0x03
	board->LSpos = Universal_read(ADC_START);	//	- CH3
    1182:	80 e0       	ldi	r24, 0x00	; 0
    1184:	94 e1       	ldi	r25, 0x14	; 20
    1186:	0e 94 c4 0c 	call	0x1988	; 0x1988 <Universal_read>
    118a:	8a 83       	std	Y+2, r24	; 0x02
	// Les knappestatus
	board->LBtn = 0<testBit(PINB, LEFT_BUTTON_PIN);
    118c:	81 e0       	ldi	r24, 0x01	; 1
    118e:	b4 9b       	sbis	0x16, 4	; 22
    1190:	80 e0       	ldi	r24, 0x00	; 0
    1192:	8c 83       	std	Y+4, r24	; 0x04
	board->RBtn = 0<testBit(PINB, RIGHT_BUTTON_PIN);
    1194:	81 e0       	ldi	r24, 0x01	; 1
    1196:	b3 9b       	sbis	0x16, 3	; 22
    1198:	80 e0       	ldi	r24, 0x00	; 0
    119a:	8d 83       	std	Y+5, r24	; 0x05
	board->JoyBtn = !(0<testBit(PINB, JOY_BUTTON_PIN));
    119c:	81 e0       	ldi	r24, 0x01	; 1
    119e:	b2 99       	sbic	0x16, 2	; 22
    11a0:	80 e0       	ldi	r24, 0x00	; 0
    11a2:	8e 83       	std	Y+6, r24	; 0x06
	// Opretter ein int med pluss og minus slik at vi kan finne riktig vinkel med _UpdateJoystickAngel
	board->JoyYposCal = (int16_t)(board->JoyYpos) - (int16_t)(board->JoyYOrigo);
    11a4:	88 81       	ld	r24, Y
    11a6:	90 e0       	ldi	r25, 0x00	; 0
    11a8:	28 85       	ldd	r18, Y+8	; 0x08
    11aa:	82 1b       	sub	r24, r18
    11ac:	91 09       	sbc	r25, r1
    11ae:	9c 87       	std	Y+12, r25	; 0x0c
    11b0:	8b 87       	std	Y+11, r24	; 0x0b
	board->JoyXposCal = (int16_t)(board->JoyXpos) - (int16_t)(board->JoyXOrigo);
    11b2:	89 81       	ldd	r24, Y+1	; 0x01
    11b4:	90 e0       	ldi	r25, 0x00	; 0
    11b6:	2f 81       	ldd	r18, Y+7	; 0x07
    11b8:	82 1b       	sub	r24, r18
    11ba:	91 09       	sbc	r25, r1
    11bc:	9a 87       	std	Y+10, r25	; 0x0a
    11be:	89 87       	std	Y+9, r24	; 0x09
	///IKKJE TESTA
	MultiBoard_UpdateJoystickAngle(board);
    11c0:	ce 01       	movw	r24, r28
    11c2:	0e 94 3b 08 	call	0x1076	; 0x1076 <MultiBoard_UpdateJoystickAngle>
}
    11c6:	df 91       	pop	r29
    11c8:	cf 91       	pop	r28
    11ca:	08 95       	ret

000011cc <oled_write_command>:
}

void oled_update_display_non_blocking(void) {
	if (get_time_in_ms() >= 16) {
		restart_timer();
		oled_data_from_SRAM();
    11cc:	68 2f       	mov	r22, r24
    11ce:	80 e0       	ldi	r24, 0x00	; 0
    11d0:	90 e0       	ldi	r25, 0x00	; 0
    11d2:	0e 94 b4 0c 	call	0x1968	; 0x1968 <Universal_write>
    11d6:	08 95       	ret

000011d8 <oled_write_data>:
    11d8:	ef 92       	push	r14
    11da:	ff 92       	push	r15
    11dc:	0f 93       	push	r16
    11de:	1f 93       	push	r17
    11e0:	cf 93       	push	r28
    11e2:	df 93       	push	r29
    11e4:	61 15       	cp	r22, r1
    11e6:	71 05       	cpc	r23, r1
    11e8:	81 f0       	breq	.+32     	; 0x120a <oled_write_data+0x32>
    11ea:	7c 01       	movw	r14, r24
    11ec:	8c 01       	movw	r16, r24
    11ee:	e6 0e       	add	r14, r22
    11f0:	f7 1e       	adc	r15, r23
    11f2:	c0 e0       	ldi	r28, 0x00	; 0
    11f4:	d2 e0       	ldi	r29, 0x02	; 2
    11f6:	f8 01       	movw	r30, r16
    11f8:	61 91       	ld	r22, Z+
    11fa:	8f 01       	movw	r16, r30
    11fc:	ce 01       	movw	r24, r28
    11fe:	0e 94 b4 0c 	call	0x1968	; 0x1968 <Universal_write>
    1202:	21 96       	adiw	r28, 0x01	; 1
    1204:	0e 15       	cp	r16, r14
    1206:	1f 05       	cpc	r17, r15
    1208:	b1 f7       	brne	.-20     	; 0x11f6 <oled_write_data+0x1e>
    120a:	df 91       	pop	r29
    120c:	cf 91       	pop	r28
    120e:	1f 91       	pop	r17
    1210:	0f 91       	pop	r16
    1212:	ff 90       	pop	r15
    1214:	ef 90       	pop	r14
    1216:	08 95       	ret

00001218 <oled_set_page>:
    1218:	87 70       	andi	r24, 0x07	; 7
    121a:	80 6b       	ori	r24, 0xB0	; 176
    121c:	0e 94 e6 08 	call	0x11cc	; 0x11cc <oled_write_command>
    1220:	08 95       	ret

00001222 <oled_set_column>:
    1222:	cf 93       	push	r28
    1224:	c8 2f       	mov	r28, r24
    1226:	82 95       	swap	r24
    1228:	8f 70       	andi	r24, 0x0F	; 15
    122a:	80 61       	ori	r24, 0x10	; 16
    122c:	0e 94 e6 08 	call	0x11cc	; 0x11cc <oled_write_command>
    1230:	8c 2f       	mov	r24, r28
    1232:	8f 70       	andi	r24, 0x0F	; 15
    1234:	0e 94 e6 08 	call	0x11cc	; 0x11cc <oled_write_command>
    1238:	cf 91       	pop	r28
    123a:	08 95       	ret

0000123c <oled_home>:
    123c:	80 e0       	ldi	r24, 0x00	; 0
    123e:	0e 94 0c 09 	call	0x1218	; 0x1218 <oled_set_page>
    1242:	80 e0       	ldi	r24, 0x00	; 0
    1244:	0e 94 11 09 	call	0x1222	; 0x1222 <oled_set_column>
    1248:	08 95       	ret

0000124a <oled_init>:
    124a:	8e ea       	ldi	r24, 0xAE	; 174
    124c:	0e 94 e6 08 	call	0x11cc	; 0x11cc <oled_write_command>
    1250:	81 ea       	ldi	r24, 0xA1	; 161
    1252:	0e 94 e6 08 	call	0x11cc	; 0x11cc <oled_write_command>
    1256:	8a ed       	ldi	r24, 0xDA	; 218
    1258:	0e 94 e6 08 	call	0x11cc	; 0x11cc <oled_write_command>
    125c:	82 e1       	ldi	r24, 0x12	; 18
    125e:	0e 94 e6 08 	call	0x11cc	; 0x11cc <oled_write_command>
    1262:	88 ec       	ldi	r24, 0xC8	; 200
    1264:	0e 94 e6 08 	call	0x11cc	; 0x11cc <oled_write_command>
    1268:	88 ea       	ldi	r24, 0xA8	; 168
    126a:	0e 94 e6 08 	call	0x11cc	; 0x11cc <oled_write_command>
    126e:	8f e3       	ldi	r24, 0x3F	; 63
    1270:	0e 94 e6 08 	call	0x11cc	; 0x11cc <oled_write_command>
    1274:	85 ed       	ldi	r24, 0xD5	; 213
    1276:	0e 94 e6 08 	call	0x11cc	; 0x11cc <oled_write_command>
    127a:	80 e8       	ldi	r24, 0x80	; 128
    127c:	0e 94 e6 08 	call	0x11cc	; 0x11cc <oled_write_command>
    1280:	81 e8       	ldi	r24, 0x81	; 129
    1282:	0e 94 e6 08 	call	0x11cc	; 0x11cc <oled_write_command>
    1286:	80 e5       	ldi	r24, 0x50	; 80
    1288:	0e 94 e6 08 	call	0x11cc	; 0x11cc <oled_write_command>
    128c:	89 ed       	ldi	r24, 0xD9	; 217
    128e:	0e 94 e6 08 	call	0x11cc	; 0x11cc <oled_write_command>
    1292:	81 e2       	ldi	r24, 0x21	; 33
    1294:	0e 94 e6 08 	call	0x11cc	; 0x11cc <oled_write_command>
    1298:	80 e2       	ldi	r24, 0x20	; 32
    129a:	0e 94 e6 08 	call	0x11cc	; 0x11cc <oled_write_command>
    129e:	82 e0       	ldi	r24, 0x02	; 2
    12a0:	0e 94 e6 08 	call	0x11cc	; 0x11cc <oled_write_command>
    12a4:	8b ed       	ldi	r24, 0xDB	; 219
    12a6:	0e 94 e6 08 	call	0x11cc	; 0x11cc <oled_write_command>
    12aa:	80 e3       	ldi	r24, 0x30	; 48
    12ac:	0e 94 e6 08 	call	0x11cc	; 0x11cc <oled_write_command>
    12b0:	8d ea       	ldi	r24, 0xAD	; 173
    12b2:	0e 94 e6 08 	call	0x11cc	; 0x11cc <oled_write_command>
    12b6:	80 e0       	ldi	r24, 0x00	; 0
    12b8:	0e 94 e6 08 	call	0x11cc	; 0x11cc <oled_write_command>
    12bc:	84 ea       	ldi	r24, 0xA4	; 164
    12be:	0e 94 e6 08 	call	0x11cc	; 0x11cc <oled_write_command>
    12c2:	86 ea       	ldi	r24, 0xA6	; 166
    12c4:	0e 94 e6 08 	call	0x11cc	; 0x11cc <oled_write_command>
    12c8:	8f ea       	ldi	r24, 0xAF	; 175
    12ca:	0e 94 e6 08 	call	0x11cc	; 0x11cc <oled_write_command>
    12ce:	08 95       	ret

000012d0 <oled_data_from_SRAM>:
    12d0:	8f 92       	push	r8
    12d2:	9f 92       	push	r9
    12d4:	bf 92       	push	r11
    12d6:	cf 92       	push	r12
    12d8:	df 92       	push	r13
    12da:	ef 92       	push	r14
    12dc:	ff 92       	push	r15
    12de:	0f 93       	push	r16
    12e0:	1f 93       	push	r17
    12e2:	cf 93       	push	r28
    12e4:	df 93       	push	r29
    12e6:	cd b7       	in	r28, 0x3d	; 61
    12e8:	de b7       	in	r29, 0x3e	; 62
    12ea:	c0 58       	subi	r28, 0x80	; 128
    12ec:	d1 09       	sbc	r29, r1
    12ee:	0f b6       	in	r0, 0x3f	; 63
    12f0:	f8 94       	cli
    12f2:	de bf       	out	0x3e, r29	; 62
    12f4:	0f be       	out	0x3f, r0	; 63
    12f6:	cd bf       	out	0x3d, r28	; 61
    12f8:	ce 01       	movw	r24, r28
    12fa:	01 96       	adiw	r24, 0x01	; 1
    12fc:	4c 01       	movw	r8, r24
    12fe:	ee 24       	eor	r14, r14
    1300:	ff 24       	eor	r15, r15
    1302:	e8 1a       	sub	r14, r24
    1304:	f9 0a       	sbc	r15, r25
    1306:	b1 2c       	mov	r11, r1
    1308:	6e 01       	movw	r12, r28
    130a:	91 e8       	ldi	r25, 0x81	; 129
    130c:	c9 0e       	add	r12, r25
    130e:	d1 1c       	adc	r13, r1
    1310:	8b 2d       	mov	r24, r11
    1312:	0e 94 0c 09 	call	0x1218	; 0x1218 <oled_set_page>
    1316:	80 e0       	ldi	r24, 0x00	; 0
    1318:	0e 94 11 09 	call	0x1222	; 0x1222 <oled_set_column>
    131c:	84 01       	movw	r16, r8
    131e:	c8 01       	movw	r24, r16
    1320:	8e 0d       	add	r24, r14
    1322:	9f 1d       	adc	r25, r15
    1324:	0e 94 a4 0c 	call	0x1948	; 0x1948 <SRAM_read>
    1328:	f8 01       	movw	r30, r16
    132a:	81 93       	st	Z+, r24
    132c:	8f 01       	movw	r16, r30
    132e:	ec 15       	cp	r30, r12
    1330:	fd 05       	cpc	r31, r13
    1332:	a9 f7       	brne	.-22     	; 0x131e <oled_data_from_SRAM+0x4e>
    1334:	60 e8       	ldi	r22, 0x80	; 128
    1336:	70 e0       	ldi	r23, 0x00	; 0
    1338:	ce 01       	movw	r24, r28
    133a:	01 96       	adiw	r24, 0x01	; 1
    133c:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <oled_write_data>
    1340:	b3 94       	inc	r11
    1342:	f0 e8       	ldi	r31, 0x80	; 128
    1344:	ef 0e       	add	r14, r31
    1346:	f1 1c       	adc	r15, r1
    1348:	88 e0       	ldi	r24, 0x08	; 8
    134a:	b8 12       	cpse	r11, r24
    134c:	e1 cf       	rjmp	.-62     	; 0x1310 <oled_data_from_SRAM+0x40>
    134e:	c0 58       	subi	r28, 0x80	; 128
    1350:	df 4f       	sbci	r29, 0xFF	; 255
    1352:	0f b6       	in	r0, 0x3f	; 63
    1354:	f8 94       	cli
    1356:	de bf       	out	0x3e, r29	; 62
    1358:	0f be       	out	0x3f, r0	; 63
    135a:	cd bf       	out	0x3d, r28	; 61
    135c:	df 91       	pop	r29
    135e:	cf 91       	pop	r28
    1360:	1f 91       	pop	r17
    1362:	0f 91       	pop	r16
    1364:	ff 90       	pop	r15
    1366:	ef 90       	pop	r14
    1368:	df 90       	pop	r13
    136a:	cf 90       	pop	r12
    136c:	bf 90       	pop	r11
    136e:	9f 90       	pop	r9
    1370:	8f 90       	pop	r8
    1372:	08 95       	ret

00001374 <oled_write_screen_to_SRAM>:
	}
}


/*______________IKKJE_TESTA______________*/
void oled_write_screen_to_SRAM(const char *screen) {
    1374:	6f 92       	push	r6
    1376:	7f 92       	push	r7
    1378:	8f 92       	push	r8
    137a:	9f 92       	push	r9
    137c:	af 92       	push	r10
    137e:	bf 92       	push	r11
    1380:	cf 92       	push	r12
    1382:	df 92       	push	r13
    1384:	ef 92       	push	r14
    1386:	ff 92       	push	r15
    1388:	0f 93       	push	r16
    138a:	1f 93       	push	r17
    138c:	cf 93       	push	r28
    138e:	df 93       	push	r29
    1390:	4c 01       	movw	r8, r24
    1392:	e1 2c       	mov	r14, r1
    1394:	f1 2c       	mov	r15, r1
    1396:	0f 2e       	mov	r0, r31
    1398:	f0 e7       	ldi	r31, 0x70	; 112
    139a:	6f 2e       	mov	r6, r31
    139c:	f5 e0       	ldi	r31, 0x05	; 5
    139e:	7f 2e       	mov	r7, r31
    13a0:	f0 2d       	mov	r31, r0
    13a2:	0f 2e       	mov	r0, r31
    13a4:	f8 e7       	ldi	r31, 0x78	; 120
    13a6:	af 2e       	mov	r10, r31
    13a8:	f5 e0       	ldi	r31, 0x05	; 5
    13aa:	bf 2e       	mov	r11, r31
    13ac:	f0 2d       	mov	r31, r0
	for (int j = 0; j < 128; j++) {
		// Les byte direkte frå PROGMEM
		char c = pgm_read_byte(&screen[j]);
    13ae:	f4 01       	movw	r30, r8
    13b0:	04 91       	lpm	r16, Z

		// Forsikre at char er i ASCII-intervall
		if (c >= 32 && c <= 127) {
    13b2:	80 ee       	ldi	r24, 0xE0	; 224
    13b4:	80 0f       	add	r24, r16
    13b6:	80 36       	cpi	r24, 0x60	; 96
    13b8:	f0 f4       	brcc	.+60     	; 0x13f6 <oled_write_screen_to_SRAM+0x82>
			// Skriv teiknet frå fonten til SRAM
			for (uint8_t i = 0; i < 8; i++) {
				SRAM_write(j * 8 + i, pgm_read_byte(&font8x8_basic[(c - 32) * 8 + i]));
    13ba:	10 e0       	ldi	r17, 0x00	; 0
    13bc:	00 52       	subi	r16, 0x20	; 32
    13be:	11 09       	sbc	r17, r1
    13c0:	00 0f       	add	r16, r16
    13c2:	11 1f       	adc	r17, r17
    13c4:	00 0f       	add	r16, r16
    13c6:	11 1f       	adc	r17, r17
    13c8:	00 0f       	add	r16, r16
    13ca:	11 1f       	adc	r17, r17
    13cc:	67 01       	movw	r12, r14
    13ce:	f8 e0       	ldi	r31, 0x08	; 8
    13d0:	cf 0e       	add	r12, r31
    13d2:	d1 1c       	adc	r13, r1
    13d4:	e7 01       	movw	r28, r14
    13d6:	0e 19       	sub	r16, r14
    13d8:	1f 09       	sbc	r17, r15
    13da:	f8 01       	movw	r30, r16
    13dc:	ec 0f       	add	r30, r28
    13de:	fd 1f       	adc	r31, r29
    13e0:	e0 59       	subi	r30, 0x90	; 144
    13e2:	fa 4f       	sbci	r31, 0xFA	; 250
    13e4:	64 91       	lpm	r22, Z
    13e6:	ce 01       	movw	r24, r28
    13e8:	0e 94 94 0c 	call	0x1928	; 0x1928 <SRAM_write>
    13ec:	21 96       	adiw	r28, 0x01	; 1
		char c = pgm_read_byte(&screen[j]);

		// Forsikre at char er i ASCII-intervall
		if (c >= 32 && c <= 127) {
			// Skriv teiknet frå fonten til SRAM
			for (uint8_t i = 0; i < 8; i++) {
    13ee:	cc 16       	cp	r12, r28
    13f0:	dd 06       	cpc	r13, r29
    13f2:	99 f7       	brne	.-26     	; 0x13da <oled_write_screen_to_SRAM+0x66>
    13f4:	10 c0       	rjmp	.+32     	; 0x1416 <oled_write_screen_to_SRAM+0xa2>
	for (int j = 0; j < 128; j++) {
		// Les byte direkte frå PROGMEM
		char c = pgm_read_byte(&screen[j]);

		// Forsikre at char er i ASCII-intervall
		if (c >= 32 && c <= 127) {
    13f6:	c0 e7       	ldi	r28, 0x70	; 112
    13f8:	d5 e0       	ldi	r29, 0x05	; 5
				SRAM_write(j * 8 + i, pgm_read_byte(&font8x8_basic[(c - 32) * 8 + i]));
			}
			} else {
			// Bruk mellomrom (' ') som standard for ugyldige teikn
			for (uint8_t i = 0; i < 8; i++) {
				SRAM_write(j * 8 + i, pgm_read_byte(&font8x8_basic[(0x20 - 32) * 8 + i])); // ASCII 0x20 for space
    13fa:	87 01       	movw	r16, r14
    13fc:	06 19       	sub	r16, r6
    13fe:	17 09       	sbc	r17, r7
    1400:	fe 01       	movw	r30, r28
    1402:	64 91       	lpm	r22, Z
    1404:	c8 01       	movw	r24, r16
    1406:	8c 0f       	add	r24, r28
    1408:	9d 1f       	adc	r25, r29
    140a:	0e 94 94 0c 	call	0x1928	; 0x1928 <SRAM_write>
    140e:	21 96       	adiw	r28, 0x01	; 1
			for (uint8_t i = 0; i < 8; i++) {
				SRAM_write(j * 8 + i, pgm_read_byte(&font8x8_basic[(c - 32) * 8 + i]));
			}
			} else {
			// Bruk mellomrom (' ') som standard for ugyldige teikn
			for (uint8_t i = 0; i < 8; i++) {
    1410:	ca 15       	cp	r28, r10
    1412:	db 05       	cpc	r29, r11
    1414:	a9 f7       	brne	.-22     	; 0x1400 <oled_write_screen_to_SRAM+0x8c>
    1416:	ff ef       	ldi	r31, 0xFF	; 255
    1418:	8f 1a       	sub	r8, r31
    141a:	9f 0a       	sbc	r9, r31
    141c:	88 e0       	ldi	r24, 0x08	; 8
    141e:	e8 0e       	add	r14, r24
    1420:	f1 1c       	adc	r15, r1
}


/*______________IKKJE_TESTA______________*/
void oled_write_screen_to_SRAM(const char *screen) {
	for (int j = 0; j < 128; j++) {
    1422:	e1 14       	cp	r14, r1
    1424:	e4 e0       	ldi	r30, 0x04	; 4
    1426:	fe 06       	cpc	r15, r30
    1428:	09 f0       	breq	.+2      	; 0x142c <oled_write_screen_to_SRAM+0xb8>
    142a:	c1 cf       	rjmp	.-126    	; 0x13ae <oled_write_screen_to_SRAM+0x3a>
			for (uint8_t i = 0; i < 8; i++) {
				SRAM_write(j * 8 + i, pgm_read_byte(&font8x8_basic[(0x20 - 32) * 8 + i])); // ASCII 0x20 for space
			}
		}
	}
}
    142c:	df 91       	pop	r29
    142e:	cf 91       	pop	r28
    1430:	1f 91       	pop	r17
    1432:	0f 91       	pop	r16
    1434:	ff 90       	pop	r15
    1436:	ef 90       	pop	r14
    1438:	df 90       	pop	r13
    143a:	cf 90       	pop	r12
    143c:	bf 90       	pop	r11
    143e:	af 90       	pop	r10
    1440:	9f 90       	pop	r9
    1442:	8f 90       	pop	r8
    1444:	7f 90       	pop	r7
    1446:	6f 90       	pop	r6
    1448:	08 95       	ret

0000144a <oled_write_FULLscreen_to_SRAM>:


void oled_write_FULLscreen_to_SRAM(const uint8_t *screen_1024) {
    144a:	0f 93       	push	r16
    144c:	1f 93       	push	r17
    144e:	cf 93       	push	r28
    1450:	df 93       	push	r29
    1452:	8c 01       	movw	r16, r24
	// Gå gjennom hele bufferet og skriv til SRAM, men les frå PROGMEM
	for (uint16_t i = 0; i < 1024; i++) {
    1454:	c0 e0       	ldi	r28, 0x00	; 0
    1456:	d0 e0       	ldi	r29, 0x00	; 0
		// Les byte direkte frå Flash og skriv til SRAM
		uint8_t byte_from_flash = pgm_read_byte(&screen_1024[i]);
    1458:	f8 01       	movw	r30, r16
    145a:	ec 0f       	add	r30, r28
    145c:	fd 1f       	adc	r31, r29
    145e:	64 91       	lpm	r22, Z
		SRAM_write(i, byte_from_flash);
    1460:	ce 01       	movw	r24, r28
    1462:	0e 94 94 0c 	call	0x1928	; 0x1928 <SRAM_write>
}


void oled_write_FULLscreen_to_SRAM(const uint8_t *screen_1024) {
	// Gå gjennom hele bufferet og skriv til SRAM, men les frå PROGMEM
	for (uint16_t i = 0; i < 1024; i++) {
    1466:	21 96       	adiw	r28, 0x01	; 1
    1468:	c1 15       	cp	r28, r1
    146a:	84 e0       	ldi	r24, 0x04	; 4
    146c:	d8 07       	cpc	r29, r24
    146e:	a1 f7       	brne	.-24     	; 0x1458 <oled_write_FULLscreen_to_SRAM+0xe>
		// Les byte direkte frå Flash og skriv til SRAM
		uint8_t byte_from_flash = pgm_read_byte(&screen_1024[i]);
		SRAM_write(i, byte_from_flash);
	}
}
    1470:	df 91       	pop	r29
    1472:	cf 91       	pop	r28
    1474:	1f 91       	pop	r17
    1476:	0f 91       	pop	r16
    1478:	08 95       	ret

0000147a <oled_write_line_to_SRAM>:


void oled_write_line_to_SRAM(uint8_t line, const char* data) {
    147a:	8f 92       	push	r8
    147c:	9f 92       	push	r9
    147e:	bf 92       	push	r11
    1480:	cf 92       	push	r12
    1482:	df 92       	push	r13
    1484:	ef 92       	push	r14
    1486:	ff 92       	push	r15
    1488:	0f 93       	push	r16
    148a:	1f 93       	push	r17
    148c:	cf 93       	push	r28
    148e:	df 93       	push	r29
	if (line >= 8) {
    1490:	88 30       	cpi	r24, 0x08	; 8
    1492:	08 f0       	brcs	.+2      	; 0x1496 <oled_write_line_to_SRAM+0x1c>
    1494:	5e c0       	rjmp	.+188    	; 0x1552 <oled_write_line_to_SRAM+0xd8>
    1496:	fb 01       	movw	r30, r22
		return; 
	}
	uint8_t max_chars_per_line = 16;
	uint16_t sram_address = line * 128;  // Hver linje er 128 bytes, 16 karakterer à 8 pixels
    1498:	90 e8       	ldi	r25, 0x80	; 128
    149a:	89 9f       	mul	r24, r25
    149c:	60 01       	movw	r12, r0
    149e:	11 24       	eor	r1, r1
	uint8_t i = 0; // så den ikkje døyr når vi går ut av forloopen (brukast igjen)
	// Skriv karakterene til SRAM, men ikke mer enn 16
	for (; i < max_chars_per_line; i++) {
		if (data[i] == '\0') {
    14a0:	80 81       	ld	r24, Z
    14a2:	88 23       	and	r24, r24
    14a4:	09 f4       	brne	.+2      	; 0x14a8 <oled_write_line_to_SRAM+0x2e>
    14a6:	47 c0       	rjmp	.+142    	; 0x1536 <oled_write_line_to_SRAM+0xbc>
    14a8:	76 01       	movw	r14, r12
    14aa:	8b 01       	movw	r16, r22
    14ac:	b1 2c       	mov	r11, r1
    14ae:	0a c0       	rjmp	.+20     	; 0x14c4 <oled_write_line_to_SRAM+0x4a>
    14b0:	0f 5f       	subi	r16, 0xFF	; 255
    14b2:	1f 4f       	sbci	r17, 0xFF	; 255
    14b4:	a8 e0       	ldi	r26, 0x08	; 8
    14b6:	ea 0e       	add	r14, r26
    14b8:	f1 1c       	adc	r15, r1
    14ba:	f8 01       	movw	r30, r16
    14bc:	80 81       	ld	r24, Z
    14be:	88 23       	and	r24, r24
    14c0:	09 f4       	brne	.+2      	; 0x14c4 <oled_write_line_to_SRAM+0x4a>
    14c2:	3a c0       	rjmp	.+116    	; 0x1538 <oled_write_line_to_SRAM+0xbe>
    14c4:	c0 e0       	ldi	r28, 0x00	; 0
    14c6:	d0 e0       	ldi	r29, 0x00	; 0
			break;  // Avslutt hvis vi når slutten av data
		}
		for (uint8_t j = 0; j < 8; j++) {
			SRAM_write(sram_address + (i * 8) + j, pgm_read_byte(&font8x8_basic[(data[i] - 32) * 8 + j]));
    14c8:	d8 01       	movw	r26, r16
    14ca:	ec 91       	ld	r30, X
    14cc:	f0 e0       	ldi	r31, 0x00	; 0
    14ce:	b0 97       	sbiw	r30, 0x20	; 32
    14d0:	ee 0f       	add	r30, r30
    14d2:	ff 1f       	adc	r31, r31
    14d4:	ee 0f       	add	r30, r30
    14d6:	ff 1f       	adc	r31, r31
    14d8:	ee 0f       	add	r30, r30
    14da:	ff 1f       	adc	r31, r31
    14dc:	ec 0f       	add	r30, r28
    14de:	fd 1f       	adc	r31, r29
    14e0:	e0 59       	subi	r30, 0x90	; 144
    14e2:	fa 4f       	sbci	r31, 0xFA	; 250
    14e4:	64 91       	lpm	r22, Z
    14e6:	c7 01       	movw	r24, r14
    14e8:	8c 0f       	add	r24, r28
    14ea:	9d 1f       	adc	r25, r29
    14ec:	0e 94 94 0c 	call	0x1928	; 0x1928 <SRAM_write>
    14f0:	21 96       	adiw	r28, 0x01	; 1
	// Skriv karakterene til SRAM, men ikke mer enn 16
	for (; i < max_chars_per_line; i++) {
		if (data[i] == '\0') {
			break;  // Avslutt hvis vi når slutten av data
		}
		for (uint8_t j = 0; j < 8; j++) {
    14f2:	c8 30       	cpi	r28, 0x08	; 8
    14f4:	d1 05       	cpc	r29, r1
    14f6:	41 f7       	brne	.-48     	; 0x14c8 <oled_write_line_to_SRAM+0x4e>
	}
	uint8_t max_chars_per_line = 16;
	uint16_t sram_address = line * 128;  // Hver linje er 128 bytes, 16 karakterer à 8 pixels
	uint8_t i = 0; // så den ikkje døyr når vi går ut av forloopen (brukast igjen)
	// Skriv karakterene til SRAM, men ikke mer enn 16
	for (; i < max_chars_per_line; i++) {
    14f8:	b3 94       	inc	r11
    14fa:	b0 e1       	ldi	r27, 0x10	; 16
    14fc:	bb 12       	cpse	r11, r27
    14fe:	d8 cf       	rjmp	.-80     	; 0x14b0 <oled_write_line_to_SRAM+0x36>
    1500:	28 c0       	rjmp	.+80     	; 0x1552 <oled_write_line_to_SRAM+0xd8>
		}
	}
	// Fyll resten av linjen med tomrom (mellomrom) etter slutten av data
	for (; i < max_chars_per_line; i++) {
		for (uint8_t j = 0; j < 8; j++) {
			SRAM_write(sram_address + (i * 8) + j, pgm_read_byte(&font8x8_basic[(' ' - 32) * 8 + j]));
    1502:	fe 01       	movw	r30, r28
    1504:	64 91       	lpm	r22, Z
    1506:	c8 01       	movw	r24, r16
    1508:	8c 0f       	add	r24, r28
    150a:	9d 1f       	adc	r25, r29
    150c:	0e 94 94 0c 	call	0x1928	; 0x1928 <SRAM_write>
    1510:	21 96       	adiw	r28, 0x01	; 1
			SRAM_write(sram_address + (i * 8) + j, pgm_read_byte(&font8x8_basic[(data[i] - 32) * 8 + j]));
		}
	}
	// Fyll resten av linjen med tomrom (mellomrom) etter slutten av data
	for (; i < max_chars_per_line; i++) {
		for (uint8_t j = 0; j < 8; j++) {
    1512:	ce 15       	cp	r28, r14
    1514:	df 05       	cpc	r29, r15
    1516:	a9 f7       	brne	.-22     	; 0x1502 <oled_write_line_to_SRAM+0x88>
		for (uint8_t j = 0; j < 8; j++) {
			SRAM_write(sram_address + (i * 8) + j, pgm_read_byte(&font8x8_basic[(data[i] - 32) * 8 + j]));
		}
	}
	// Fyll resten av linjen med tomrom (mellomrom) etter slutten av data
	for (; i < max_chars_per_line; i++) {
    1518:	b3 94       	inc	r11
    151a:	ff e0       	ldi	r31, 0x0F	; 15
    151c:	fb 15       	cp	r31, r11
    151e:	c8 f0       	brcs	.+50     	; 0x1552 <oled_write_line_to_SRAM+0xd8>
		for (uint8_t j = 0; j < 8; j++) {
			SRAM_write(sram_address + (i * 8) + j, pgm_read_byte(&font8x8_basic[(' ' - 32) * 8 + j]));
    1520:	c0 e7       	ldi	r28, 0x70	; 112
    1522:	d5 e0       	ldi	r29, 0x05	; 5
    1524:	86 01       	movw	r16, r12
    1526:	88 e0       	ldi	r24, 0x08	; 8
    1528:	b8 9e       	mul	r11, r24
    152a:	00 0d       	add	r16, r0
    152c:	11 1d       	adc	r17, r1
    152e:	11 24       	eor	r1, r1
    1530:	08 19       	sub	r16, r8
    1532:	19 09       	sbc	r17, r9
    1534:	e6 cf       	rjmp	.-52     	; 0x1502 <oled_write_line_to_SRAM+0x88>
	if (line >= 8) {
		return; 
	}
	uint8_t max_chars_per_line = 16;
	uint16_t sram_address = line * 128;  // Hver linje er 128 bytes, 16 karakterer à 8 pixels
	uint8_t i = 0; // så den ikkje døyr når vi går ut av forloopen (brukast igjen)
    1536:	b1 2c       	mov	r11, r1
    1538:	0f 2e       	mov	r0, r31
    153a:	f0 e7       	ldi	r31, 0x70	; 112
    153c:	8f 2e       	mov	r8, r31
    153e:	f5 e0       	ldi	r31, 0x05	; 5
    1540:	9f 2e       	mov	r9, r31
    1542:	f0 2d       	mov	r31, r0
    1544:	0f 2e       	mov	r0, r31
    1546:	f8 e7       	ldi	r31, 0x78	; 120
    1548:	ef 2e       	mov	r14, r31
    154a:	f5 e0       	ldi	r31, 0x05	; 5
    154c:	ff 2e       	mov	r15, r31
    154e:	f0 2d       	mov	r31, r0
    1550:	e7 cf       	rjmp	.-50     	; 0x1520 <oled_write_line_to_SRAM+0xa6>
	for (; i < max_chars_per_line; i++) {
		for (uint8_t j = 0; j < 8; j++) {
			SRAM_write(sram_address + (i * 8) + j, pgm_read_byte(&font8x8_basic[(' ' - 32) * 8 + j]));
		}
	}
}
    1552:	df 91       	pop	r29
    1554:	cf 91       	pop	r28
    1556:	1f 91       	pop	r17
    1558:	0f 91       	pop	r16
    155a:	ff 90       	pop	r15
    155c:	ef 90       	pop	r14
    155e:	df 90       	pop	r13
    1560:	cf 90       	pop	r12
    1562:	bf 90       	pop	r11
    1564:	9f 90       	pop	r9
    1566:	8f 90       	pop	r8
    1568:	08 95       	ret

0000156a <oled_write_char_to_SRAM>:
//Nyttig for menyen trur eg, lar deg spesifisere nøyaktig kor på skjermen du vil overskrive
void oled_write_char_to_SRAM(uint8_t row, uint8_t col, char c) {
    156a:	ef 92       	push	r14
    156c:	ff 92       	push	r15
    156e:	0f 93       	push	r16
    1570:	1f 93       	push	r17
    1572:	cf 93       	push	r28
    1574:	df 93       	push	r29
	if (row >= 8 || col >= 16) {
    1576:	88 30       	cpi	r24, 0x08	; 8
    1578:	70 f5       	brcc	.+92     	; 0x15d6 <oled_write_char_to_SRAM+0x6c>
    157a:	60 31       	cpi	r22, 0x10	; 16
    157c:	60 f5       	brcc	.+88     	; 0x15d6 <oled_write_char_to_SRAM+0x6c>
    157e:	28 2f       	mov	r18, r24
		return; 
	}
	uint16_t sram_address = row * 128 + (col * 8); 
    1580:	86 2f       	mov	r24, r22
    1582:	90 e0       	ldi	r25, 0x00	; 0
    1584:	30 e1       	ldi	r19, 0x10	; 16
    1586:	23 9f       	mul	r18, r19
    1588:	80 0d       	add	r24, r0
    158a:	91 1d       	adc	r25, r1
    158c:	11 24       	eor	r1, r1
    158e:	88 0f       	add	r24, r24
    1590:	99 1f       	adc	r25, r25
    1592:	88 0f       	add	r24, r24
    1594:	99 1f       	adc	r25, r25
    1596:	88 0f       	add	r24, r24
    1598:	99 1f       	adc	r25, r25
	for (uint8_t i = 0; i < 8; i++) {
		SRAM_write(sram_address + i, pgm_read_byte(&font8x8_basic[(c - 32) * 8 + i]));
    159a:	04 2f       	mov	r16, r20
    159c:	10 e0       	ldi	r17, 0x00	; 0
    159e:	00 52       	subi	r16, 0x20	; 32
    15a0:	11 09       	sbc	r17, r1
    15a2:	00 0f       	add	r16, r16
    15a4:	11 1f       	adc	r17, r17
    15a6:	00 0f       	add	r16, r16
    15a8:	11 1f       	adc	r17, r17
    15aa:	00 0f       	add	r16, r16
    15ac:	11 1f       	adc	r17, r17
    15ae:	7c 01       	movw	r14, r24
    15b0:	28 e0       	ldi	r18, 0x08	; 8
    15b2:	e2 0e       	add	r14, r18
    15b4:	f1 1c       	adc	r15, r1
    15b6:	ec 01       	movw	r28, r24
    15b8:	08 1b       	sub	r16, r24
    15ba:	19 0b       	sbc	r17, r25
    15bc:	f8 01       	movw	r30, r16
    15be:	ec 0f       	add	r30, r28
    15c0:	fd 1f       	adc	r31, r29
    15c2:	e0 59       	subi	r30, 0x90	; 144
    15c4:	fa 4f       	sbci	r31, 0xFA	; 250
    15c6:	64 91       	lpm	r22, Z
    15c8:	ce 01       	movw	r24, r28
    15ca:	0e 94 94 0c 	call	0x1928	; 0x1928 <SRAM_write>
    15ce:	21 96       	adiw	r28, 0x01	; 1
void oled_write_char_to_SRAM(uint8_t row, uint8_t col, char c) {
	if (row >= 8 || col >= 16) {
		return; 
	}
	uint16_t sram_address = row * 128 + (col * 8); 
	for (uint8_t i = 0; i < 8; i++) {
    15d0:	ce 15       	cp	r28, r14
    15d2:	df 05       	cpc	r29, r15
    15d4:	99 f7       	brne	.-26     	; 0x15bc <oled_write_char_to_SRAM+0x52>
		SRAM_write(sram_address + i, pgm_read_byte(&font8x8_basic[(c - 32) * 8 + i]));
	}
}
    15d6:	df 91       	pop	r29
    15d8:	cf 91       	pop	r28
    15da:	1f 91       	pop	r17
    15dc:	0f 91       	pop	r16
    15de:	ff 90       	pop	r15
    15e0:	ef 90       	pop	r14
    15e2:	08 95       	ret

000015e4 <oled_write_pixel_to_SRAM>:

void oled_write_pixel_to_SRAM(uint8_t row, uint8_t col, uint8_t value) {
    15e4:	0f 93       	push	r16
    15e6:	1f 93       	push	r17
    15e8:	cf 93       	push	r28
    15ea:	df 93       	push	r29
	if (row >= 64 || col >= 128) {
    15ec:	80 34       	cpi	r24, 0x40	; 64
    15ee:	48 f5       	brcc	.+82     	; 0x1642 <oled_write_pixel_to_SRAM+0x5e>
    15f0:	66 23       	and	r22, r22
    15f2:	3c f1       	brlt	.+78     	; 0x1642 <oled_write_pixel_to_SRAM+0x5e>
    15f4:	04 2f       	mov	r16, r20
    15f6:	18 2f       	mov	r17, r24
		return;
	}
	
	// Finn korrekt byte i SRAM for å justere pikslen
	uint16_t sram_address = (row / 8) * 128 + col;
    15f8:	86 95       	lsr	r24
    15fa:	86 95       	lsr	r24
    15fc:	86 95       	lsr	r24
    15fe:	c6 2f       	mov	r28, r22
    1600:	d0 e0       	ldi	r29, 0x00	; 0
    1602:	90 e8       	ldi	r25, 0x80	; 128
    1604:	89 9f       	mul	r24, r25
    1606:	c0 0d       	add	r28, r0
    1608:	d1 1d       	adc	r29, r1
    160a:	11 24       	eor	r1, r1
	uint8_t current_byte = SRAM_read(sram_address);
    160c:	ce 01       	movw	r24, r28
    160e:	0e 94 a4 0c 	call	0x1948	; 0x1948 <SRAM_read>
	uint8_t bit_position = row % 8;
    1612:	17 70       	andi	r17, 0x07	; 7

	// Sett eller nullstill den ønskede biten
	if (value) {
    1614:	00 23       	and	r16, r16
    1616:	49 f0       	breq	.+18     	; 0x162a <oled_write_pixel_to_SRAM+0x46>
		current_byte |= (1 << bit_position);  // Sett bit til 1
    1618:	61 e0       	ldi	r22, 0x01	; 1
    161a:	70 e0       	ldi	r23, 0x00	; 0
    161c:	02 c0       	rjmp	.+4      	; 0x1622 <oled_write_pixel_to_SRAM+0x3e>
    161e:	66 0f       	add	r22, r22
    1620:	77 1f       	adc	r23, r23
    1622:	1a 95       	dec	r17
    1624:	e2 f7       	brpl	.-8      	; 0x161e <oled_write_pixel_to_SRAM+0x3a>
    1626:	68 2b       	or	r22, r24
    1628:	09 c0       	rjmp	.+18     	; 0x163c <oled_write_pixel_to_SRAM+0x58>
		} else {
		current_byte &= ~(1 << bit_position);  // Nullstill bit til 0
    162a:	61 e0       	ldi	r22, 0x01	; 1
    162c:	70 e0       	ldi	r23, 0x00	; 0
    162e:	02 c0       	rjmp	.+4      	; 0x1634 <oled_write_pixel_to_SRAM+0x50>
    1630:	66 0f       	add	r22, r22
    1632:	77 1f       	adc	r23, r23
    1634:	1a 95       	dec	r17
    1636:	e2 f7       	brpl	.-8      	; 0x1630 <oled_write_pixel_to_SRAM+0x4c>
    1638:	60 95       	com	r22
    163a:	68 23       	and	r22, r24
	}
	
	SRAM_write(sram_address, current_byte);
    163c:	ce 01       	movw	r24, r28
    163e:	0e 94 94 0c 	call	0x1928	; 0x1928 <SRAM_write>
}
    1642:	df 91       	pop	r29
    1644:	cf 91       	pop	r28
    1646:	1f 91       	pop	r17
    1648:	0f 91       	pop	r16
    164a:	08 95       	ret

0000164c <oled_clear_screen>:

void oled_clear_screen(void) {
    164c:	cf 93       	push	r28
    164e:	df 93       	push	r29
	// Lag en tom buffer fylt med nuller eller mellomrom (0 er nok, fordi funksjonen oversetter til ' ')
	char empty_buffer[128] = {0};  // Heile skjermen, 128 tegn

	// Skriv den tomme bufferen til SRAM, som vil tømme skjermen
	oled_write_screen_to_SRAM(empty_buffer);*/
	for(int i = 0; i < 1024; i++){
    1650:	c0 e0       	ldi	r28, 0x00	; 0
    1652:	d0 e0       	ldi	r29, 0x00	; 0
		SRAM_write(i, 0);
    1654:	60 e0       	ldi	r22, 0x00	; 0
    1656:	ce 01       	movw	r24, r28
    1658:	0e 94 94 0c 	call	0x1928	; 0x1928 <SRAM_write>
	// Lag en tom buffer fylt med nuller eller mellomrom (0 er nok, fordi funksjonen oversetter til ' ')
	char empty_buffer[128] = {0};  // Heile skjermen, 128 tegn

	// Skriv den tomme bufferen til SRAM, som vil tømme skjermen
	oled_write_screen_to_SRAM(empty_buffer);*/
	for(int i = 0; i < 1024; i++){
    165c:	21 96       	adiw	r28, 0x01	; 1
    165e:	c1 15       	cp	r28, r1
    1660:	84 e0       	ldi	r24, 0x04	; 4
    1662:	d8 07       	cpc	r29, r24
    1664:	b9 f7       	brne	.-18     	; 0x1654 <oled_clear_screen+0x8>
		SRAM_write(i, 0);
	}
}
    1666:	df 91       	pop	r29
    1668:	cf 91       	pop	r28
    166a:	08 95       	ret

0000166c <oled_draw_line>:

void oled_draw_line(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1) {
    166c:	6f 92       	push	r6
    166e:	7f 92       	push	r7
    1670:	8f 92       	push	r8
    1672:	9f 92       	push	r9
    1674:	af 92       	push	r10
    1676:	bf 92       	push	r11
    1678:	cf 92       	push	r12
    167a:	df 92       	push	r13
    167c:	ef 92       	push	r14
    167e:	ff 92       	push	r15
    1680:	0f 93       	push	r16
    1682:	1f 93       	push	r17
    1684:	cf 93       	push	r28
    1686:	df 93       	push	r29
    1688:	c8 2f       	mov	r28, r24
    168a:	d6 2f       	mov	r29, r22
    168c:	94 2e       	mov	r9, r20
    168e:	62 2e       	mov	r6, r18
	int dx = abs(x1 - x0);
    1690:	84 2f       	mov	r24, r20
    1692:	90 e0       	ldi	r25, 0x00	; 0
    1694:	8c 1b       	sub	r24, r28
    1696:	91 09       	sbc	r25, r1
    1698:	7c 01       	movw	r14, r24
    169a:	22 f4       	brpl	.+8      	; 0x16a4 <oled_draw_line+0x38>
    169c:	ee 24       	eor	r14, r14
    169e:	ff 24       	eor	r15, r15
    16a0:	e8 1a       	sub	r14, r24
    16a2:	f9 0a       	sbc	r15, r25
	int dy = abs(y1 - y0);
    16a4:	86 2d       	mov	r24, r6
    16a6:	90 e0       	ldi	r25, 0x00	; 0
    16a8:	8d 1b       	sub	r24, r29
    16aa:	91 09       	sbc	r25, r1
    16ac:	5c 01       	movw	r10, r24
    16ae:	22 f4       	brpl	.+8      	; 0x16b8 <oled_draw_line+0x4c>
    16b0:	aa 24       	eor	r10, r10
    16b2:	bb 24       	eor	r11, r11
    16b4:	a8 1a       	sub	r10, r24
    16b6:	b9 0a       	sbc	r11, r25
	int sx = (x0 < x1) ? 1 : -1;
    16b8:	c9 15       	cp	r28, r9
    16ba:	18 f0       	brcs	.+6      	; 0x16c2 <oled_draw_line+0x56>
    16bc:	88 24       	eor	r8, r8
    16be:	8a 94       	dec	r8
    16c0:	02 c0       	rjmp	.+4      	; 0x16c6 <oled_draw_line+0x5a>
    16c2:	88 24       	eor	r8, r8
    16c4:	83 94       	inc	r8
	int sy = (y0 < y1) ? 1 : -1;
    16c6:	d6 15       	cp	r29, r6
    16c8:	18 f0       	brcs	.+6      	; 0x16d0 <oled_draw_line+0x64>
    16ca:	77 24       	eor	r7, r7
    16cc:	7a 94       	dec	r7
    16ce:	02 c0       	rjmp	.+4      	; 0x16d4 <oled_draw_line+0x68>
    16d0:	77 24       	eor	r7, r7
    16d2:	73 94       	inc	r7
	int err = dx - dy;
    16d4:	87 01       	movw	r16, r14
    16d6:	0a 19       	sub	r16, r10
    16d8:	1b 09       	sbc	r17, r11
	while (1) {
		oled_write_pixel_to_SRAM(y0, x0, 1);  // Tegn piksel

		if (x0 == x1 && y0 == y1) break;
		int e2 = 2 * err;
		if (e2 > -dy) {
    16da:	cc 24       	eor	r12, r12
    16dc:	dd 24       	eor	r13, r13
    16de:	ca 18       	sub	r12, r10
    16e0:	db 08       	sbc	r13, r11
	int sx = (x0 < x1) ? 1 : -1;
	int sy = (y0 < y1) ? 1 : -1;
	int err = dx - dy;

	while (1) {
		oled_write_pixel_to_SRAM(y0, x0, 1);  // Tegn piksel
    16e2:	41 e0       	ldi	r20, 0x01	; 1
    16e4:	6c 2f       	mov	r22, r28
    16e6:	8d 2f       	mov	r24, r29
    16e8:	0e 94 f2 0a 	call	0x15e4	; 0x15e4 <oled_write_pixel_to_SRAM>

		if (x0 == x1 && y0 == y1) break;
    16ec:	c9 11       	cpse	r28, r9
    16ee:	02 c0       	rjmp	.+4      	; 0x16f4 <oled_draw_line+0x88>
    16f0:	d6 15       	cp	r29, r6
    16f2:	81 f0       	breq	.+32     	; 0x1714 <oled_draw_line+0xa8>
		int e2 = 2 * err;
    16f4:	c8 01       	movw	r24, r16
    16f6:	88 0f       	add	r24, r24
    16f8:	99 1f       	adc	r25, r25
		if (e2 > -dy) {
    16fa:	c8 16       	cp	r12, r24
    16fc:	d9 06       	cpc	r13, r25
    16fe:	1c f4       	brge	.+6      	; 0x1706 <oled_draw_line+0x9a>
			err -= dy;
    1700:	0a 19       	sub	r16, r10
    1702:	1b 09       	sbc	r17, r11
			x0 += sx;
    1704:	c8 0d       	add	r28, r8
		}
		if (e2 < dx) {
    1706:	8e 15       	cp	r24, r14
    1708:	9f 05       	cpc	r25, r15
    170a:	5c f7       	brge	.-42     	; 0x16e2 <oled_draw_line+0x76>
			err += dx;
    170c:	0e 0d       	add	r16, r14
    170e:	1f 1d       	adc	r17, r15
			y0 += sy;
    1710:	d7 0d       	add	r29, r7
    1712:	e7 cf       	rjmp	.-50     	; 0x16e2 <oled_draw_line+0x76>
		}
	}
}
    1714:	df 91       	pop	r29
    1716:	cf 91       	pop	r28
    1718:	1f 91       	pop	r17
    171a:	0f 91       	pop	r16
    171c:	ff 90       	pop	r15
    171e:	ef 90       	pop	r14
    1720:	df 90       	pop	r13
    1722:	cf 90       	pop	r12
    1724:	bf 90       	pop	r11
    1726:	af 90       	pop	r10
    1728:	9f 90       	pop	r9
    172a:	8f 90       	pop	r8
    172c:	7f 90       	pop	r7
    172e:	6f 90       	pop	r6
    1730:	08 95       	ret

00001732 <oled_draw_circle>:

void oled_draw_circle(uint8_t x0, uint8_t y0, uint8_t radius) {
    1732:	9f 92       	push	r9
    1734:	af 92       	push	r10
    1736:	bf 92       	push	r11
    1738:	cf 92       	push	r12
    173a:	df 92       	push	r13
    173c:	ef 92       	push	r14
    173e:	ff 92       	push	r15
    1740:	0f 93       	push	r16
    1742:	1f 93       	push	r17
    1744:	cf 93       	push	r28
    1746:	df 93       	push	r29
    1748:	98 2e       	mov	r9, r24
    174a:	c6 2e       	mov	r12, r22
	int x = radius;
    174c:	c4 2f       	mov	r28, r20
    174e:	d0 e0       	ldi	r29, 0x00	; 0
    1750:	a1 2c       	mov	r10, r1
    1752:	b1 2c       	mov	r11, r1
    1754:	00 e0       	ldi	r16, 0x00	; 0
    1756:	10 e0       	ldi	r17, 0x00	; 0
	int y = 0;
	int err = 0;

	while (x >= y) {
		oled_write_pixel_to_SRAM(y0 + y, x0 + x, 1);
    1758:	41 e0       	ldi	r20, 0x01	; 1
    175a:	fc 2e       	mov	r15, r28
    175c:	f9 0c       	add	r15, r9
    175e:	6f 2d       	mov	r22, r15
    1760:	dc 2c       	mov	r13, r12
    1762:	d0 0e       	add	r13, r16
    1764:	8d 2d       	mov	r24, r13
    1766:	0e 94 f2 0a 	call	0x15e4	; 0x15e4 <oled_write_pixel_to_SRAM>
		oled_write_pixel_to_SRAM(y0 + y, x0 - x, 1);
    176a:	41 e0       	ldi	r20, 0x01	; 1
    176c:	e9 2c       	mov	r14, r9
    176e:	ec 1a       	sub	r14, r28
    1770:	6e 2d       	mov	r22, r14
    1772:	8d 2d       	mov	r24, r13
    1774:	0e 94 f2 0a 	call	0x15e4	; 0x15e4 <oled_write_pixel_to_SRAM>
		oled_write_pixel_to_SRAM(y0 - y, x0 + x, 1);
    1778:	41 e0       	ldi	r20, 0x01	; 1
    177a:	6f 2d       	mov	r22, r15
    177c:	fc 2c       	mov	r15, r12
    177e:	f0 1a       	sub	r15, r16
    1780:	8f 2d       	mov	r24, r15
    1782:	0e 94 f2 0a 	call	0x15e4	; 0x15e4 <oled_write_pixel_to_SRAM>
		oled_write_pixel_to_SRAM(y0 - y, x0 - x, 1);
    1786:	41 e0       	ldi	r20, 0x01	; 1
    1788:	6e 2d       	mov	r22, r14
    178a:	8f 2d       	mov	r24, r15
    178c:	0e 94 f2 0a 	call	0x15e4	; 0x15e4 <oled_write_pixel_to_SRAM>
		oled_write_pixel_to_SRAM(y0 + x, x0 + y, 1);
    1790:	41 e0       	ldi	r20, 0x01	; 1
    1792:	f9 2c       	mov	r15, r9
    1794:	f0 0e       	add	r15, r16
    1796:	6f 2d       	mov	r22, r15
    1798:	dc 2e       	mov	r13, r28
    179a:	dc 0c       	add	r13, r12
    179c:	8d 2d       	mov	r24, r13
    179e:	0e 94 f2 0a 	call	0x15e4	; 0x15e4 <oled_write_pixel_to_SRAM>
		oled_write_pixel_to_SRAM(y0 + x, x0 - y, 1);
    17a2:	41 e0       	ldi	r20, 0x01	; 1
    17a4:	e9 2c       	mov	r14, r9
    17a6:	e0 1a       	sub	r14, r16
    17a8:	6e 2d       	mov	r22, r14
    17aa:	8d 2d       	mov	r24, r13
    17ac:	0e 94 f2 0a 	call	0x15e4	; 0x15e4 <oled_write_pixel_to_SRAM>
		oled_write_pixel_to_SRAM(y0 - x, x0 + y, 1);
    17b0:	41 e0       	ldi	r20, 0x01	; 1
    17b2:	6f 2d       	mov	r22, r15
    17b4:	fc 2c       	mov	r15, r12
    17b6:	fc 1a       	sub	r15, r28
    17b8:	8f 2d       	mov	r24, r15
    17ba:	0e 94 f2 0a 	call	0x15e4	; 0x15e4 <oled_write_pixel_to_SRAM>
		oled_write_pixel_to_SRAM(y0 - x, x0 - y, 1);
    17be:	41 e0       	ldi	r20, 0x01	; 1
    17c0:	6e 2d       	mov	r22, r14
    17c2:	8f 2d       	mov	r24, r15
    17c4:	0e 94 f2 0a 	call	0x15e4	; 0x15e4 <oled_write_pixel_to_SRAM>

		if (err <= 0) {
    17c8:	1a 14       	cp	r1, r10
    17ca:	1b 04       	cpc	r1, r11
    17cc:	5c f0       	brlt	.+22     	; 0x17e4 <oled_draw_circle+0xb2>
			y += 1;
    17ce:	0f 5f       	subi	r16, 0xFF	; 255
    17d0:	1f 4f       	sbci	r17, 0xFF	; 255
			err += 2 * y + 1;
    17d2:	c8 01       	movw	r24, r16
    17d4:	88 0f       	add	r24, r24
    17d6:	99 1f       	adc	r25, r25
    17d8:	01 96       	adiw	r24, 0x01	; 1
    17da:	a8 0e       	add	r10, r24
    17dc:	b9 1e       	adc	r11, r25
		}
		if (err > 0) {
    17de:	1a 14       	cp	r1, r10
    17e0:	1b 04       	cpc	r1, r11
    17e2:	3c f4       	brge	.+14     	; 0x17f2 <oled_draw_circle+0xc0>
			x -= 1;
    17e4:	21 97       	sbiw	r28, 0x01	; 1
			err -= 2 * x + 1;
    17e6:	ce 01       	movw	r24, r28
    17e8:	88 0f       	add	r24, r24
    17ea:	99 1f       	adc	r25, r25
    17ec:	01 96       	adiw	r24, 0x01	; 1
    17ee:	a8 1a       	sub	r10, r24
    17f0:	b9 0a       	sbc	r11, r25
void oled_draw_circle(uint8_t x0, uint8_t y0, uint8_t radius) {
	int x = radius;
	int y = 0;
	int err = 0;

	while (x >= y) {
    17f2:	c0 17       	cp	r28, r16
    17f4:	d1 07       	cpc	r29, r17
    17f6:	0c f0       	brlt	.+2      	; 0x17fa <oled_draw_circle+0xc8>
    17f8:	af cf       	rjmp	.-162    	; 0x1758 <oled_draw_circle+0x26>
		if (err > 0) {
			x -= 1;
			err -= 2 * x + 1;
		}
	}
}
    17fa:	df 91       	pop	r29
    17fc:	cf 91       	pop	r28
    17fe:	1f 91       	pop	r17
    1800:	0f 91       	pop	r16
    1802:	ff 90       	pop	r15
    1804:	ef 90       	pop	r14
    1806:	df 90       	pop	r13
    1808:	cf 90       	pop	r12
    180a:	bf 90       	pop	r11
    180c:	af 90       	pop	r10
    180e:	9f 90       	pop	r9
    1810:	08 95       	ret

00001812 <oled_draw_square>:

void oled_draw_square(uint8_t x0, uint8_t y0, uint8_t width, uint8_t height) {
    1812:	0f 93       	push	r16
    1814:	1f 93       	push	r17
    1816:	cf 93       	push	r28
    1818:	df 93       	push	r29
    181a:	08 2f       	mov	r16, r24
    181c:	16 2f       	mov	r17, r22
    181e:	d2 2f       	mov	r29, r18
	oled_draw_line(x0, y0, x0 + width, y0);           // Øvre linje
    1820:	c8 2f       	mov	r28, r24
    1822:	c4 0f       	add	r28, r20
    1824:	26 2f       	mov	r18, r22
    1826:	4c 2f       	mov	r20, r28
    1828:	0e 94 36 0b 	call	0x166c	; 0x166c <oled_draw_line>
	oled_draw_line(x0, y0 + height, x0 + width, y0 + height);  // Nedre linje
    182c:	d1 0f       	add	r29, r17
    182e:	2d 2f       	mov	r18, r29
    1830:	4c 2f       	mov	r20, r28
    1832:	6d 2f       	mov	r22, r29
    1834:	80 2f       	mov	r24, r16
    1836:	0e 94 36 0b 	call	0x166c	; 0x166c <oled_draw_line>
	oled_draw_line(x0, y0, x0, y0 + height);           // Venstre linje
    183a:	2d 2f       	mov	r18, r29
    183c:	40 2f       	mov	r20, r16
    183e:	61 2f       	mov	r22, r17
    1840:	80 2f       	mov	r24, r16
    1842:	0e 94 36 0b 	call	0x166c	; 0x166c <oled_draw_line>
	oled_draw_line(x0 + width, y0, x0 + width, y0 + height);   // Høyre linje
    1846:	2d 2f       	mov	r18, r29
    1848:	4c 2f       	mov	r20, r28
    184a:	61 2f       	mov	r22, r17
    184c:	8c 2f       	mov	r24, r28
    184e:	0e 94 36 0b 	call	0x166c	; 0x166c <oled_draw_line>
}
    1852:	df 91       	pop	r29
    1854:	cf 91       	pop	r28
    1856:	1f 91       	pop	r17
    1858:	0f 91       	pop	r16
    185a:	08 95       	ret

0000185c <__vector_15>:

// Definer den globale variabelen for å telje millisekund
volatile uint32_t overflow_count = 0;

// Timer-overflyt interrupt service rutine
ISR(TIMER1_OVF_vect) {
    185c:	1f 92       	push	r1
    185e:	0f 92       	push	r0
    1860:	0f b6       	in	r0, 0x3f	; 63
    1862:	0f 92       	push	r0
    1864:	11 24       	eor	r1, r1
    1866:	8f 93       	push	r24
    1868:	9f 93       	push	r25
    186a:	af 93       	push	r26
    186c:	bf 93       	push	r27
	overflow_count++;
    186e:	80 91 f9 01 	lds	r24, 0x01F9	; 0x8001f9 <overflow_count>
    1872:	90 91 fa 01 	lds	r25, 0x01FA	; 0x8001fa <overflow_count+0x1>
    1876:	a0 91 fb 01 	lds	r26, 0x01FB	; 0x8001fb <overflow_count+0x2>
    187a:	b0 91 fc 01 	lds	r27, 0x01FC	; 0x8001fc <overflow_count+0x3>
    187e:	01 96       	adiw	r24, 0x01	; 1
    1880:	a1 1d       	adc	r26, r1
    1882:	b1 1d       	adc	r27, r1
    1884:	80 93 f9 01 	sts	0x01F9, r24	; 0x8001f9 <overflow_count>
    1888:	90 93 fa 01 	sts	0x01FA, r25	; 0x8001fa <overflow_count+0x1>
    188c:	a0 93 fb 01 	sts	0x01FB, r26	; 0x8001fb <overflow_count+0x2>
    1890:	b0 93 fc 01 	sts	0x01FC, r27	; 0x8001fc <overflow_count+0x3>
}
    1894:	bf 91       	pop	r27
    1896:	af 91       	pop	r26
    1898:	9f 91       	pop	r25
    189a:	8f 91       	pop	r24
    189c:	0f 90       	pop	r0
    189e:	0f be       	out	0x3f, r0	; 63
    18a0:	0f 90       	pop	r0
    18a2:	1f 90       	pop	r1
    18a4:	18 95       	reti

000018a6 <get_time_in_cycles>:
}

uint32_t get_time_in_cycles(void) {
	// Returner tiden i klokkesykluser
	// Hver gang timeren overflyter, har vi telt 65536 klokkesykluser
	return (overflow_count * 65536UL) + TCNT1;
    18a6:	80 91 f9 01 	lds	r24, 0x01F9	; 0x8001f9 <overflow_count>
    18aa:	90 91 fa 01 	lds	r25, 0x01FA	; 0x8001fa <overflow_count+0x1>
    18ae:	a0 91 fb 01 	lds	r26, 0x01FB	; 0x8001fb <overflow_count+0x2>
    18b2:	b0 91 fc 01 	lds	r27, 0x01FC	; 0x8001fc <overflow_count+0x3>
    18b6:	2c b5       	in	r18, 0x2c	; 44
    18b8:	3d b5       	in	r19, 0x2d	; 45
    18ba:	dc 01       	movw	r26, r24
    18bc:	99 27       	eor	r25, r25
    18be:	88 27       	eor	r24, r24
    18c0:	bc 01       	movw	r22, r24
    18c2:	cd 01       	movw	r24, r26
    18c4:	62 0f       	add	r22, r18
    18c6:	73 1f       	adc	r23, r19
    18c8:	81 1d       	adc	r24, r1
    18ca:	91 1d       	adc	r25, r1
}
    18cc:	08 95       	ret

000018ce <get_time_in_ms>:
	overflow_count++;
}

// Funksjon som returnerer tida i millisekund sidan programstart
uint32_t get_time_in_ms(void){
	return get_time_in_cycles()/(4915200UL/1000);
    18ce:	0e 94 53 0c 	call	0x18a6	; 0x18a6 <get_time_in_cycles>
    18d2:	23 e3       	ldi	r18, 0x33	; 51
    18d4:	33 e1       	ldi	r19, 0x13	; 19
    18d6:	40 e0       	ldi	r20, 0x00	; 0
    18d8:	50 e0       	ldi	r21, 0x00	; 0
    18da:	0e 94 e8 0c 	call	0x19d0	; 0x19d0 <__udivmodsi4>
}
    18de:	ca 01       	movw	r24, r20
    18e0:	b9 01       	movw	r22, r18
    18e2:	08 95       	ret

000018e4 <setup_timer>:
}

// Funksjon for å setje opp Timer1 til å generere 1 ms avbrot
void setup_timer() {
	// Sett normal modus (WGM12 = 0)
	TCCR1A = 0;      // Normal mode
    18e4:	1f bc       	out	0x2f, r1	; 47
	TCCR1B = (1 << CS10); // Prescaler = 1 (ingen prescaling, f_CPU direkte)
    18e6:	81 e0       	ldi	r24, 0x01	; 1
    18e8:	8e bd       	out	0x2e, r24	; 46

	// Aktiver Timer1 overflow interrupt
	TIMSK = (1 << TOIE1);
    18ea:	80 e8       	ldi	r24, 0x80	; 128
    18ec:	89 bf       	out	0x39, r24	; 57

	// Nullstill Timer/Counter1
	TCNT1 = 0;
    18ee:	1d bc       	out	0x2d, r1	; 45
    18f0:	1c bc       	out	0x2c, r1	; 44
    18f2:	08 95       	ret

000018f4 <restart_timer>:
}
void restart_timer(){
	// Nullstill Timer/Counter1
	TCNT1 = 0;
    18f4:	1d bc       	out	0x2d, r1	; 45
    18f6:	1c bc       	out	0x2c, r1	; 44
	overflow_count = 0;
    18f8:	10 92 f9 01 	sts	0x01F9, r1	; 0x8001f9 <overflow_count>
    18fc:	10 92 fa 01 	sts	0x01FA, r1	; 0x8001fa <overflow_count+0x1>
    1900:	10 92 fb 01 	sts	0x01FB, r1	; 0x8001fb <overflow_count+0x2>
    1904:	10 92 fc 01 	sts	0x01FC, r1	; 0x8001fc <overflow_count+0x3>
    1908:	08 95       	ret

0000190a <externalMemoryInit>:
 */ 
#include "XMEM_Decode.h"
// Funksjon for ï¿½ initialisere det eksterne minnet (SRAM + latch)
void externalMemoryInit(void) {
	// Set Port A (AD0-AD7) og Port C (A8-A15) som utgang for adresse- og databuss
	DDRA = 0xFF;  // PA0-PA7 som utgang
    190a:	8f ef       	ldi	r24, 0xFF	; 255
    190c:	8a bb       	out	0x1a, r24	; 26
	DDRC = 0x0F ;  // PC0-PC3 som utgang
    190e:	8f e0       	ldi	r24, 0x0F	; 15
    1910:	84 bb       	out	0x14, r24	; 20
	
	// Set Port D (PD6 og PD7) som utgang for WR og RD signal
	setBit(DDRD, PD6);  // WR
    1912:	8e 9a       	sbi	0x11, 6	; 17
	setBit(DDRD, PD7);  // RD
    1914:	8f 9a       	sbi	0x11, 7	; 17

	// Set Port E (PE1) som utgang for ALE
	setBit(DDRE, PE1);  // ALE
    1916:	31 9a       	sbi	0x06, 1	; 6

	// Aktivere ekstern minnegrensesnitt
	setBit(MCUCR, SRE);   // Enable external SRAM interface
    1918:	85 b7       	in	r24, 0x35	; 53
    191a:	80 68       	ori	r24, 0x80	; 128
    191c:	85 bf       	out	0x35, r24	; 53
	SFIOR = 0x00;         // No wait state
    191e:	10 be       	out	0x30, r1	; 48
	
	//Maskes pc4-pc7 (disables as output) (s32 ATmega datasheet)
	setBit(SFIOR, XMM2);
    1920:	80 b7       	in	r24, 0x30	; 48
    1922:	80 62       	ori	r24, 0x20	; 32
    1924:	80 bf       	out	0x30, r24	; 48
    1926:	08 95       	ret

00001928 <SRAM_write>:
}


// Funksjon for ï¿½ skrive data til SRAM
void SRAM_write(volatile uint16_t addr, uint8_t data) {
    1928:	cf 93       	push	r28
    192a:	df 93       	push	r29
    192c:	00 d0       	rcall	.+0      	; 0x192e <SRAM_write+0x6>
    192e:	cd b7       	in	r28, 0x3d	; 61
    1930:	de b7       	in	r29, 0x3e	; 62
    1932:	9a 83       	std	Y+2, r25	; 0x02
    1934:	89 83       	std	Y+1, r24	; 0x01
	volatile char *ext_ram = (char *) SRAM_START; // Startadresse for SRAM
	uint16_t ext_ram_size = SRAM_SIZE; // Stï¿½rrelsen pï¿½ SRAM (2 KB)
	ext_ram[addr] = data;
    1936:	e9 81       	ldd	r30, Y+1	; 0x01
    1938:	fa 81       	ldd	r31, Y+2	; 0x02
    193a:	f8 5e       	subi	r31, 0xE8	; 232
    193c:	60 83       	st	Z, r22
}
    193e:	0f 90       	pop	r0
    1940:	0f 90       	pop	r0
    1942:	df 91       	pop	r29
    1944:	cf 91       	pop	r28
    1946:	08 95       	ret

00001948 <SRAM_read>:

// Funksjon for ï¿½ lese data frï¿½ SRAM
uint8_t SRAM_read(volatile uint16_t addr) {
    1948:	cf 93       	push	r28
    194a:	df 93       	push	r29
    194c:	00 d0       	rcall	.+0      	; 0x194e <SRAM_read+0x6>
    194e:	cd b7       	in	r28, 0x3d	; 61
    1950:	de b7       	in	r29, 0x3e	; 62
    1952:	9a 83       	std	Y+2, r25	; 0x02
    1954:	89 83       	std	Y+1, r24	; 0x01
	volatile char *ext_ram = (char *) SRAM_START; // Startadresse for SRAM
	uint16_t ext_ram_size = SRAM_SIZE; // Stï¿½rrelsen pï¿½ SRAM (2 KB)
	uint8_t data = ext_ram[addr];
    1956:	e9 81       	ldd	r30, Y+1	; 0x01
    1958:	fa 81       	ldd	r31, Y+2	; 0x02
    195a:	f8 5e       	subi	r31, 0xE8	; 232
    195c:	80 81       	ld	r24, Z
	
	return data;
}
    195e:	0f 90       	pop	r0
    1960:	0f 90       	pop	r0
    1962:	df 91       	pop	r29
    1964:	cf 91       	pop	r28
    1966:	08 95       	ret

00001968 <Universal_write>:

// Funksjon for ï¿½ skrive data til SRAM
void Universal_write(volatile uint16_t addr, uint8_t data) {
    1968:	cf 93       	push	r28
    196a:	df 93       	push	r29
    196c:	00 d0       	rcall	.+0      	; 0x196e <Universal_write+0x6>
    196e:	cd b7       	in	r28, 0x3d	; 61
    1970:	de b7       	in	r29, 0x3e	; 62
    1972:	9a 83       	std	Y+2, r25	; 0x02
    1974:	89 83       	std	Y+1, r24	; 0x01
	volatile char *ext_ram = (char *) OLED_START; // Startadresse for SRAM
	ext_ram[addr] = data;
    1976:	e9 81       	ldd	r30, Y+1	; 0x01
    1978:	fa 81       	ldd	r31, Y+2	; 0x02
    197a:	f0 5f       	subi	r31, 0xF0	; 240
    197c:	60 83       	st	Z, r22
		
}
    197e:	0f 90       	pop	r0
    1980:	0f 90       	pop	r0
    1982:	df 91       	pop	r29
    1984:	cf 91       	pop	r28
    1986:	08 95       	ret

00001988 <Universal_read>:

// Funksjon for ï¿½ lese data frï¿½ SRAM
uint8_t Universal_read(volatile uint16_t addr) {
    1988:	cf 93       	push	r28
    198a:	df 93       	push	r29
    198c:	00 d0       	rcall	.+0      	; 0x198e <Universal_read+0x6>
    198e:	cd b7       	in	r28, 0x3d	; 61
    1990:	de b7       	in	r29, 0x3e	; 62
    1992:	9a 83       	std	Y+2, r25	; 0x02
    1994:	89 83       	std	Y+1, r24	; 0x01
	volatile char *ext_ram = (char *) OLED_START; // Startadresse for SRAM
	uint8_t data = ext_ram[addr];
    1996:	e9 81       	ldd	r30, Y+1	; 0x01
    1998:	fa 81       	ldd	r31, Y+2	; 0x02
    199a:	f0 5f       	subi	r31, 0xF0	; 240
    199c:	80 81       	ld	r24, Z
	
	return data;
}
    199e:	0f 90       	pop	r0
    19a0:	0f 90       	pop	r0
    19a2:	df 91       	pop	r29
    19a4:	cf 91       	pop	r28
    19a6:	08 95       	ret

000019a8 <__divmodhi4>:
    19a8:	97 fb       	bst	r25, 7
    19aa:	07 2e       	mov	r0, r23
    19ac:	16 f4       	brtc	.+4      	; 0x19b2 <__divmodhi4+0xa>
    19ae:	00 94       	com	r0
    19b0:	07 d0       	rcall	.+14     	; 0x19c0 <__divmodhi4_neg1>
    19b2:	77 fd       	sbrc	r23, 7
    19b4:	09 d0       	rcall	.+18     	; 0x19c8 <__divmodhi4_neg2>
    19b6:	0e 94 0a 0d 	call	0x1a14	; 0x1a14 <__udivmodhi4>
    19ba:	07 fc       	sbrc	r0, 7
    19bc:	05 d0       	rcall	.+10     	; 0x19c8 <__divmodhi4_neg2>
    19be:	3e f4       	brtc	.+14     	; 0x19ce <__divmodhi4_exit>

000019c0 <__divmodhi4_neg1>:
    19c0:	90 95       	com	r25
    19c2:	81 95       	neg	r24
    19c4:	9f 4f       	sbci	r25, 0xFF	; 255
    19c6:	08 95       	ret

000019c8 <__divmodhi4_neg2>:
    19c8:	70 95       	com	r23
    19ca:	61 95       	neg	r22
    19cc:	7f 4f       	sbci	r23, 0xFF	; 255

000019ce <__divmodhi4_exit>:
    19ce:	08 95       	ret

000019d0 <__udivmodsi4>:
    19d0:	a1 e2       	ldi	r26, 0x21	; 33
    19d2:	1a 2e       	mov	r1, r26
    19d4:	aa 1b       	sub	r26, r26
    19d6:	bb 1b       	sub	r27, r27
    19d8:	fd 01       	movw	r30, r26
    19da:	0d c0       	rjmp	.+26     	; 0x19f6 <__udivmodsi4_ep>

000019dc <__udivmodsi4_loop>:
    19dc:	aa 1f       	adc	r26, r26
    19de:	bb 1f       	adc	r27, r27
    19e0:	ee 1f       	adc	r30, r30
    19e2:	ff 1f       	adc	r31, r31
    19e4:	a2 17       	cp	r26, r18
    19e6:	b3 07       	cpc	r27, r19
    19e8:	e4 07       	cpc	r30, r20
    19ea:	f5 07       	cpc	r31, r21
    19ec:	20 f0       	brcs	.+8      	; 0x19f6 <__udivmodsi4_ep>
    19ee:	a2 1b       	sub	r26, r18
    19f0:	b3 0b       	sbc	r27, r19
    19f2:	e4 0b       	sbc	r30, r20
    19f4:	f5 0b       	sbc	r31, r21

000019f6 <__udivmodsi4_ep>:
    19f6:	66 1f       	adc	r22, r22
    19f8:	77 1f       	adc	r23, r23
    19fa:	88 1f       	adc	r24, r24
    19fc:	99 1f       	adc	r25, r25
    19fe:	1a 94       	dec	r1
    1a00:	69 f7       	brne	.-38     	; 0x19dc <__udivmodsi4_loop>
    1a02:	60 95       	com	r22
    1a04:	70 95       	com	r23
    1a06:	80 95       	com	r24
    1a08:	90 95       	com	r25
    1a0a:	9b 01       	movw	r18, r22
    1a0c:	ac 01       	movw	r20, r24
    1a0e:	bd 01       	movw	r22, r26
    1a10:	cf 01       	movw	r24, r30
    1a12:	08 95       	ret

00001a14 <__udivmodhi4>:
    1a14:	aa 1b       	sub	r26, r26
    1a16:	bb 1b       	sub	r27, r27
    1a18:	51 e1       	ldi	r21, 0x11	; 17
    1a1a:	07 c0       	rjmp	.+14     	; 0x1a2a <__udivmodhi4_ep>

00001a1c <__udivmodhi4_loop>:
    1a1c:	aa 1f       	adc	r26, r26
    1a1e:	bb 1f       	adc	r27, r27
    1a20:	a6 17       	cp	r26, r22
    1a22:	b7 07       	cpc	r27, r23
    1a24:	10 f0       	brcs	.+4      	; 0x1a2a <__udivmodhi4_ep>
    1a26:	a6 1b       	sub	r26, r22
    1a28:	b7 0b       	sbc	r27, r23

00001a2a <__udivmodhi4_ep>:
    1a2a:	88 1f       	adc	r24, r24
    1a2c:	99 1f       	adc	r25, r25
    1a2e:	5a 95       	dec	r21
    1a30:	a9 f7       	brne	.-22     	; 0x1a1c <__udivmodhi4_loop>
    1a32:	80 95       	com	r24
    1a34:	90 95       	com	r25
    1a36:	bc 01       	movw	r22, r24
    1a38:	cd 01       	movw	r24, r26
    1a3a:	08 95       	ret

00001a3c <strncpy_P>:
    1a3c:	fb 01       	movw	r30, r22
    1a3e:	dc 01       	movw	r26, r24
    1a40:	41 50       	subi	r20, 0x01	; 1
    1a42:	50 40       	sbci	r21, 0x00	; 0
    1a44:	48 f0       	brcs	.+18     	; 0x1a58 <strncpy_P+0x1c>
    1a46:	05 90       	lpm	r0, Z+
    1a48:	0d 92       	st	X+, r0
    1a4a:	00 20       	and	r0, r0
    1a4c:	c9 f7       	brne	.-14     	; 0x1a40 <strncpy_P+0x4>
    1a4e:	01 c0       	rjmp	.+2      	; 0x1a52 <strncpy_P+0x16>
    1a50:	1d 92       	st	X+, r1
    1a52:	41 50       	subi	r20, 0x01	; 1
    1a54:	50 40       	sbci	r21, 0x00	; 0
    1a56:	e0 f7       	brcc	.-8      	; 0x1a50 <strncpy_P+0x14>
    1a58:	08 95       	ret

00001a5a <strncpy>:
    1a5a:	fb 01       	movw	r30, r22
    1a5c:	dc 01       	movw	r26, r24
    1a5e:	41 50       	subi	r20, 0x01	; 1
    1a60:	50 40       	sbci	r21, 0x00	; 0
    1a62:	48 f0       	brcs	.+18     	; 0x1a76 <strncpy+0x1c>
    1a64:	01 90       	ld	r0, Z+
    1a66:	0d 92       	st	X+, r0
    1a68:	00 20       	and	r0, r0
    1a6a:	c9 f7       	brne	.-14     	; 0x1a5e <strncpy+0x4>
    1a6c:	01 c0       	rjmp	.+2      	; 0x1a70 <strncpy+0x16>
    1a6e:	1d 92       	st	X+, r1
    1a70:	41 50       	subi	r20, 0x01	; 1
    1a72:	50 40       	sbci	r21, 0x00	; 0
    1a74:	e0 f7       	brcc	.-8      	; 0x1a6e <strncpy+0x14>
    1a76:	08 95       	ret

00001a78 <_exit>:
    1a78:	f8 94       	cli

00001a7a <__stop_program>:
    1a7a:	ff cf       	rjmp	.-2      	; 0x1a7a <__stop_program>
