
ATmega162.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000ba  00800100  000014be  00001552  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000014be  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000001f  008001ba  008001ba  0000160c  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000160c  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  0000163c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000290  00000000  00000000  00001678  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000327d  00000000  00000000  00001908  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000011bf  00000000  00000000  00004b85  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000153b  00000000  00000000  00005d44  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000007a8  00000000  00000000  00007280  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000ac6  00000000  00000000  00007a28  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000020b8  00000000  00000000  000084ee  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000298  00000000  00000000  0000a5a6  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 34 02 	jmp	0x468	; 0x468 <__ctors_end>
       4:	0c 94 51 02 	jmp	0x4a2	; 0x4a2 <__bad_interrupt>
       8:	0c 94 51 02 	jmp	0x4a2	; 0x4a2 <__bad_interrupt>
       c:	0c 94 51 02 	jmp	0x4a2	; 0x4a2 <__bad_interrupt>
      10:	0c 94 51 02 	jmp	0x4a2	; 0x4a2 <__bad_interrupt>
      14:	0c 94 51 02 	jmp	0x4a2	; 0x4a2 <__bad_interrupt>
      18:	0c 94 51 02 	jmp	0x4a2	; 0x4a2 <__bad_interrupt>
      1c:	0c 94 51 02 	jmp	0x4a2	; 0x4a2 <__bad_interrupt>
      20:	0c 94 51 02 	jmp	0x4a2	; 0x4a2 <__bad_interrupt>
      24:	0c 94 51 02 	jmp	0x4a2	; 0x4a2 <__bad_interrupt>
      28:	0c 94 51 02 	jmp	0x4a2	; 0x4a2 <__bad_interrupt>
      2c:	0c 94 51 02 	jmp	0x4a2	; 0x4a2 <__bad_interrupt>
      30:	0c 94 51 02 	jmp	0x4a2	; 0x4a2 <__bad_interrupt>
      34:	0c 94 51 02 	jmp	0x4a2	; 0x4a2 <__bad_interrupt>
      38:	0c 94 51 02 	jmp	0x4a2	; 0x4a2 <__bad_interrupt>
      3c:	0c 94 6d 09 	jmp	0x12da	; 0x12da <__vector_15>
      40:	0c 94 51 02 	jmp	0x4a2	; 0x4a2 <__bad_interrupt>
      44:	0c 94 51 02 	jmp	0x4a2	; 0x4a2 <__bad_interrupt>
      48:	0c 94 51 02 	jmp	0x4a2	; 0x4a2 <__bad_interrupt>
      4c:	0c 94 7e 02 	jmp	0x4fc	; 0x4fc <__vector_19>
      50:	0c 94 51 02 	jmp	0x4a2	; 0x4a2 <__bad_interrupt>
      54:	0c 94 51 02 	jmp	0x4a2	; 0x4a2 <__bad_interrupt>
      58:	0c 94 51 02 	jmp	0x4a2	; 0x4a2 <__bad_interrupt>
      5c:	0c 94 51 02 	jmp	0x4a2	; 0x4a2 <__bad_interrupt>
      60:	0c 94 51 02 	jmp	0x4a2	; 0x4a2 <__bad_interrupt>
      64:	0c 94 51 02 	jmp	0x4a2	; 0x4a2 <__bad_interrupt>
      68:	0c 94 51 02 	jmp	0x4a2	; 0x4a2 <__bad_interrupt>
      6c:	0c 94 51 02 	jmp	0x4a2	; 0x4a2 <__bad_interrupt>

00000070 <__trampolines_end>:
      70:	20 53       	subi	r18, 0x30	; 48
      72:	74 61       	ori	r23, 0x14	; 20
      74:	72 74       	andi	r23, 0x42	; 66
      76:	20 47       	sbci	r18, 0x70	; 112
      78:	61 6d       	ori	r22, 0xD1	; 209
      7a:	65 20       	and	r6, r5
      7c:	20 20       	and	r2, r0
      7e:	20 20       	and	r2, r0
      80:	20 53       	subi	r18, 0x30	; 48
      82:	65 74       	andi	r22, 0x45	; 69
      84:	74 69       	ori	r23, 0x94	; 148
      86:	6e 67       	ori	r22, 0x7E	; 126
      88:	73 20       	and	r7, r3
      8a:	20 20       	and	r2, r0
      8c:	20 20       	and	r2, r0
      8e:	20 20       	and	r2, r0
      90:	20 48       	sbci	r18, 0x80	; 128
      92:	69 67       	ori	r22, 0x79	; 121
      94:	68 20       	and	r6, r8
      96:	53 63       	ori	r21, 0x33	; 51
      98:	6f 72       	andi	r22, 0x2F	; 47
      9a:	65 73       	andi	r22, 0x35	; 53
      9c:	20 20       	and	r2, r0
      9e:	20 20       	and	r2, r0
      a0:	20 43       	sbci	r18, 0x30	; 48
      a2:	72 65       	ori	r23, 0x52	; 82
      a4:	64 69       	ori	r22, 0x94	; 148
      a6:	74 73       	andi	r23, 0x34	; 52
      a8:	20 20       	and	r2, r0
      aa:	20 20       	and	r2, r0
      ac:	20 20       	and	r2, r0
      ae:	20 20       	and	r2, r0
      b0:	20 45       	sbci	r18, 0x50	; 80
      b2:	78 69       	ori	r23, 0x98	; 152
      b4:	74 20       	and	r7, r4
      b6:	20 20       	and	r2, r0
      b8:	20 20       	and	r2, r0
      ba:	20 20       	and	r2, r0
      bc:	20 20       	and	r2, r0
      be:	20 20       	and	r2, r0
	...

000000f0 <solkors>:
      f0:	20 20 20 79 61 70 40 40 40 2a 20 20 20 20 20 20        yap@@@*      
     100:	20 20 20 23 40 40 40 23 20 20 20 2a 23 20 20 20        #@@@#   *#   
     110:	20 20 23 40 40 40 2a 20 20 2a 40 40 40 40 23 20       #@@@*  *@@@@# 
     120:	2a 20 20 2b 23 40 40 40 40 40 40 20 20 40 40 40     *  +#@@@@@@  @@@
     130:	40 40 20 20 20 2b 40 40 40 40 2a 20 20 20 40 40     @@   +@@@@*   @@
     140:	40 40 40 25 25 40 40 40 40 40 40 20 2b 20 20 2a     @@@%%@@@@@@ +  *
     150:	20 23 40 40 40 40 2a 20 20 2a 40 40 40 23 20 20      #@@@@*  *@@@#  
     160:	20 20 20 23 23 20 20 20 23 40 40 40 23 20 20 20        ##   #@@@#   

00000170 <font8x8_basic>:
	...
     178:	00 00 5f 00 00 00 00 00 00 07 00 07 00 00 00 00     .._.............
     188:	14 7f 14 7f 14 00 00 00 24 2a 7f 2a 12 00 00 00     ........$*.*....
     198:	23 13 08 64 62 00 00 00 36 49 56 20 50 00 00 00     #..db...6IV P...
     1a8:	00 08 07 03 00 00 00 00 00 1c 22 41 00 00 00 00     .........."A....
     1b8:	00 41 22 1c 00 00 00 00 14 08 3e 08 14 00 00 00     .A".......>.....
     1c8:	08 08 3e 08 08 00 00 00 00 50 30 00 00 00 00 00     ..>......P0.....
     1d8:	08 08 08 08 08 00 00 00 00 60 60 00 00 00 00 00     .........``.....
     1e8:	20 10 08 04 02 00 00 00 3e 51 49 45 3e 00 00 00      .......>QIE>...
     1f8:	00 42 7f 40 00 00 00 00 42 61 51 49 46 00 00 00     .B.@....BaQIF...
     208:	21 41 45 4b 31 00 00 00 18 14 12 7f 10 00 00 00     !AEK1...........
     218:	27 45 45 45 39 00 00 00 3c 4a 49 49 30 00 00 00     'EEE9...<JII0...
     228:	01 71 09 05 03 00 00 00 36 49 49 49 36 00 00 00     .q......6III6...
     238:	06 49 49 29 1e 00 00 00 00 36 36 00 00 00 00 00     .II).....66.....
     248:	00 56 36 00 00 00 00 00 08 14 22 41 00 00 00 00     .V6......."A....
     258:	14 14 14 14 14 14 00 00 41 22 14 08 00 00 00 00     ........A"......
     268:	02 01 51 09 06 00 00 00 3e 41 5d 5d 1e 00 00 00     ..Q.....>A]]....
     278:	7e 11 11 11 7e 00 00 00 7f 49 49 49 36 00 00 00     ~...~....III6...
     288:	3e 41 41 41 22 00 00 00 7f 41 41 22 1c 00 00 00     >AAA"....AA"....
     298:	7f 49 49 49 41 00 00 00 7f 09 09 09 01 00 00 00     .IIIA...........
     2a8:	3e 41 49 49 7a 00 00 00 7f 08 08 08 7f 00 00 00     >AIIz...........
     2b8:	00 41 7f 41 00 00 00 00 20 40 41 3f 01 00 00 00     .A.A.... @A?....
     2c8:	7f 08 14 22 41 00 00 00 7f 40 40 40 40 00 00 00     ..."A....@@@@...
     2d8:	7f 02 04 02 7f 00 00 00 7f 02 04 08 7f 00 00 00     ................
     2e8:	3e 41 41 41 3e 00 00 00 7f 09 09 09 06 00 00 00     >AAA>...........
     2f8:	3e 41 51 21 5e 00 00 00 7f 09 19 29 46 00 00 00     >AQ!^......)F...
     308:	46 49 49 49 31 00 00 00 01 01 7f 01 01 00 00 00     FIII1...........
     318:	3f 40 40 40 3f 00 00 00 1f 20 40 20 1f 00 00 00     ?@@@?.... @ ....
     328:	7f 20 18 20 7f 00 00 00 63 14 08 14 63 00 00 00     . . ....c...c...
     338:	03 04 78 04 03 00 00 00 61 51 49 45 43 00 00 00     ..x.....aQIEC...
     348:	00 3e 41 41 00 00 00 00 02 04 08 10 20 00 00 00     .>AA........ ...
     358:	00 41 41 3e 00 00 00 00 04 02 01 02 04 00 00 00     .AA>............
     368:	40 40 40 40 40 40 00 00 00 00 03 07 00 00 00 00     @@@@@@..........
     378:	20 54 54 54 78 00 00 00 7f 48 44 44 38 00 00 00      TTTx....HDD8...
     388:	38 44 44 44 20 00 00 00 38 44 44 48 7f 00 00 00     8DDD ...8DDH....
     398:	38 54 54 54 18 00 00 00 08 7e 09 01 02 00 00 00     8TTT.....~......
     3a8:	08 14 54 54 3c 00 00 00 7f 08 04 04 78 00 00 00     ..TT<.......x...
     3b8:	00 44 7d 40 00 00 00 00 20 40 44 3d 00 00 00 00     .D}@.... @D=....
     3c8:	00 7f 10 28 44 00 00 00 00 41 7f 40 00 00 00 00     ...(D....A.@....
     3d8:	7c 04 18 04 78 00 00 00 7c 08 04 04 78 00 00 00     |...x...|...x...
     3e8:	38 44 44 44 38 00 00 00 7c 14 14 14 08 00 00 00     8DDD8...|.......
     3f8:	08 14 14 18 7c 00 00 00 7c 08 04 04 08 00 00 00     ....|...|.......
     408:	48 54 54 54 20 00 00 00 04 3f 44 40 20 00 00 00     HTTT ....?D@ ...
     418:	3c 40 40 20 7c 00 00 00 1c 20 40 20 1c 00 00 00     <@@ |.... @ ....
     428:	3c 40 30 40 3c 00 00 00 44 28 10 28 44 00 00 00     <@0@<...D(.(D...
     438:	0c 50 50 50 3c 00 00 00 44 64 54 4c 44 00 00 00     .PPP<...DdTLD...
     448:	00 08 36 41 00 00 00 00 00 00 7f 00 00 00 00 00     ..6A............
     458:	00 41 36 08 00 00 00 00 08 04 08 10 08 00 00 00     .A6.............

00000468 <__ctors_end>:
     468:	11 24       	eor	r1, r1
     46a:	1f be       	out	0x3f, r1	; 63
     46c:	cf ef       	ldi	r28, 0xFF	; 255
     46e:	d4 e0       	ldi	r29, 0x04	; 4
     470:	de bf       	out	0x3e, r29	; 62
     472:	cd bf       	out	0x3d, r28	; 61

00000474 <__do_copy_data>:
     474:	11 e0       	ldi	r17, 0x01	; 1
     476:	a0 e0       	ldi	r26, 0x00	; 0
     478:	b1 e0       	ldi	r27, 0x01	; 1
     47a:	ee eb       	ldi	r30, 0xBE	; 190
     47c:	f4 e1       	ldi	r31, 0x14	; 20
     47e:	02 c0       	rjmp	.+4      	; 0x484 <__do_copy_data+0x10>
     480:	05 90       	lpm	r0, Z+
     482:	0d 92       	st	X+, r0
     484:	aa 3b       	cpi	r26, 0xBA	; 186
     486:	b1 07       	cpc	r27, r17
     488:	d9 f7       	brne	.-10     	; 0x480 <__do_copy_data+0xc>

0000048a <__do_clear_bss>:
     48a:	21 e0       	ldi	r18, 0x01	; 1
     48c:	aa eb       	ldi	r26, 0xBA	; 186
     48e:	b1 e0       	ldi	r27, 0x01	; 1
     490:	01 c0       	rjmp	.+2      	; 0x494 <.do_clear_bss_start>

00000492 <.do_clear_bss_loop>:
     492:	1d 92       	st	X+, r1

00000494 <.do_clear_bss_start>:
     494:	a9 3d       	cpi	r26, 0xD9	; 217
     496:	b2 07       	cpc	r27, r18
     498:	e1 f7       	brne	.-8      	; 0x492 <.do_clear_bss_loop>
     49a:	0e 94 8b 02 	call	0x516	; 0x516 <main>
     49e:	0c 94 5d 0a 	jmp	0x14ba	; 0x14ba <_exit>

000004a2 <__bad_interrupt>:
     4a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000004a6 <UART_Init>:
	setBit(UCSR0B, RXCIE0);
}

// Deaktiver avbrot for når data blir mottatt
void UART_DisableReceiveInterrupt(void) {
	clearBit(UCSR0B, RXCIE0);
     4a6:	90 bd       	out	0x20, r25	; 32
     4a8:	89 b9       	out	0x09, r24	; 9
     4aa:	54 9a       	sbi	0x0a, 4	; 10
     4ac:	53 9a       	sbi	0x0a, 3	; 10
     4ae:	8e e8       	ldi	r24, 0x8E	; 142
     4b0:	80 bd       	out	0x20, r24	; 32
     4b2:	08 95       	ret

000004b4 <UART_SendChar>:
     4b4:	5d 9b       	sbis	0x0b, 5	; 11
     4b6:	fe cf       	rjmp	.-4      	; 0x4b4 <UART_SendChar>
     4b8:	8c b9       	out	0x0c, r24	; 12
     4ba:	08 95       	ret

000004bc <UART_putChar>:
     4bc:	0e 94 5a 02 	call	0x4b4	; 0x4b4 <UART_SendChar>
     4c0:	80 e0       	ldi	r24, 0x00	; 0
     4c2:	90 e0       	ldi	r25, 0x00	; 0
     4c4:	08 95       	ret

000004c6 <UART_ReceiveChar>:
     4c6:	5f 9b       	sbis	0x0b, 7	; 11
     4c8:	fe cf       	rjmp	.-4      	; 0x4c6 <UART_ReceiveChar>
     4ca:	8c b1       	in	r24, 0x0c	; 12
     4cc:	08 95       	ret

000004ce <UART_getChar>:
     4ce:	cf 93       	push	r28
     4d0:	0e 94 63 02 	call	0x4c6	; 0x4c6 <UART_ReceiveChar>
     4d4:	c8 2f       	mov	r28, r24
     4d6:	0e 94 5a 02 	call	0x4b4	; 0x4b4 <UART_SendChar>
     4da:	8c 2f       	mov	r24, r28
     4dc:	90 e0       	ldi	r25, 0x00	; 0
     4de:	cf 91       	pop	r28
     4e0:	08 95       	ret

000004e2 <URAT_initStudio>:
     4e2:	e3 ed       	ldi	r30, 0xD3	; 211
     4e4:	f1 e0       	ldi	r31, 0x01	; 1
     4e6:	8e e0       	ldi	r24, 0x0E	; 14
     4e8:	91 e0       	ldi	r25, 0x01	; 1
     4ea:	93 83       	std	Z+3, r25	; 0x03
     4ec:	82 83       	std	Z+2, r24	; 0x02
     4ee:	80 e0       	ldi	r24, 0x00	; 0
     4f0:	91 e0       	ldi	r25, 0x01	; 1
     4f2:	91 83       	std	Z+1, r25	; 0x01
     4f4:	80 83       	st	Z, r24
     4f6:	08 95       	ret

000004f8 <UART_EnableReceiveInterrupt>:
     4f8:	57 9a       	sbi	0x0a, 7	; 10
     4fa:	08 95       	ret

000004fc <__vector_19>:
}

// UART mottaksavbrotvektor USART0_RX_vect
ISR(USART0_RXC_vect) {
     4fc:	1f 92       	push	r1
     4fe:	0f 92       	push	r0
     500:	0f b6       	in	r0, 0x3f	; 63
     502:	0f 92       	push	r0
     504:	11 24       	eor	r1, r1
     506:	8f 93       	push	r24
	// Handter mottatt data
	char received = UDR0;
     508:	8c b1       	in	r24, 0x0c	; 12
}
     50a:	8f 91       	pop	r24
     50c:	0f 90       	pop	r0
     50e:	0f be       	out	0x3f, r0	; 63
     510:	0f 90       	pop	r0
     512:	1f 90       	pop	r1
     514:	18 95       	reti

00000516 <main>:

#include "DriverUART.h"
#include "SRAM.h"
#include "Menu_init.h"

int main(void) {
     516:	cf 93       	push	r28
     518:	df 93       	push	r29
     51a:	cd b7       	in	r28, 0x3d	; 61
     51c:	de b7       	in	r29, 0x3e	; 62
     51e:	2f 97       	sbiw	r28, 0x0f	; 15
     520:	0f b6       	in	r0, 0x3f	; 63
     522:	f8 94       	cli
     524:	de bf       	out	0x3e, r29	; 62
     526:	0f be       	out	0x3f, r0	; 63
     528:	cd bf       	out	0x3d, r28	; 61
	/*_________________INITIALISERINGER START______________________*/
	// Initialiser UART med baudrate 9600
	UART_Init(MYUBBR);
     52a:	8f e1       	ldi	r24, 0x1F	; 31
     52c:	90 e0       	ldi	r25, 0x00	; 0
     52e:	0e 94 53 02 	call	0x4a6	; 0x4a6 <UART_Init>
	URAT_initStudio();
     532:	0e 94 71 02 	call	0x4e2	; 0x4e2 <URAT_initStudio>
	UART_EnableReceiveInterrupt();
     536:	0e 94 7c 02 	call	0x4f8	; 0x4f8 <UART_EnableReceiveInterrupt>
    setup_timer();						// Start millisekundteljinga
     53a:	0e 94 b1 09 	call	0x1362	; 0x1362 <setup_timer>
	sei();								// Aktiver globale avbrot
     53e:	78 94       	sei
	externalMemoryInit();				// Initialiser eksternt minne må vere etter sei
     540:	0e 94 c4 09 	call	0x1388	; 0x1388 <externalMemoryInit>
	initialize_menus();
     544:	0e 94 cf 04 	call	0x99e	; 0x99e <initialize_menus>
	MultiBoard board;
	MultiBoard_Init(&board);			// Initialiser MultiBoard og kalibrer joystickens origo
     548:	ce 01       	movw	r24, r28
     54a:	01 96       	adiw	r24, 0x01	; 1
     54c:	0e 94 70 05 	call	0xae0	; 0xae0 <MultiBoard_Init>
	oled_init();						// Initialiser OLED-skjermen
     550:	0e 94 7c 06 	call	0xcf8	; 0xcf8 <oled_init>
		//oled_write_screen_to_SRAM(smiley);
		//oled_data_from_SRAM();
		//_delay_ms(1000); //smile litt før start
		
		//linje og slikt
		oled_clear_screen();
     554:	0e 94 65 08 	call	0x10ca	; 0x10ca <oled_clear_screen>
		oled_draw_line(10, 10, 100, 50);
     558:	22 e3       	ldi	r18, 0x32	; 50
     55a:	44 e6       	ldi	r20, 0x64	; 100
     55c:	6a e0       	ldi	r22, 0x0A	; 10
     55e:	8a e0       	ldi	r24, 0x0A	; 10
     560:	0e 94 75 08 	call	0x10ea	; 0x10ea <oled_draw_line>
		oled_draw_circle(64, 32, 20);
     564:	44 e1       	ldi	r20, 0x14	; 20
     566:	50 e0       	ldi	r21, 0x00	; 0
     568:	60 e2       	ldi	r22, 0x20	; 32
     56a:	70 e0       	ldi	r23, 0x00	; 0
     56c:	80 e4       	ldi	r24, 0x40	; 64
     56e:	90 e0       	ldi	r25, 0x00	; 0
     570:	0e 94 d8 08 	call	0x11b0	; 0x11b0 <oled_draw_circle>
		oled_draw_square(20, 20, 40, 30);
     574:	2e e1       	ldi	r18, 0x1E	; 30
     576:	48 e2       	ldi	r20, 0x28	; 40
     578:	64 e1       	ldi	r22, 0x14	; 20
     57a:	84 e1       	ldi	r24, 0x14	; 20
     57c:	0e 94 48 09 	call	0x1290	; 0x1290 <oled_draw_square>
		oled_data_from_SRAM();
     580:	0e 94 bf 06 	call	0xd7e	; 0xd7e <oled_data_from_SRAM>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     584:	2f ef       	ldi	r18, 0xFF	; 255
     586:	8f e7       	ldi	r24, 0x7F	; 127
     588:	97 e0       	ldi	r25, 0x07	; 7
     58a:	21 50       	subi	r18, 0x01	; 1
     58c:	80 40       	sbci	r24, 0x00	; 0
     58e:	90 40       	sbci	r25, 0x00	; 0
     590:	e1 f7       	brne	.-8      	; 0x58a <main+0x74>
     592:	00 c0       	rjmp	.+0      	; 0x594 <main+0x7e>
     594:	00 00       	nop
		_delay_ms(500);
	/*______MENY______*/
	current_menu = &mainMenu;
     596:	87 ec       	ldi	r24, 0xC7	; 199
     598:	91 e0       	ldi	r25, 0x01	; 1
     59a:	90 93 bb 01 	sts	0x01BB, r25	; 0x8001bb <__data_end+0x1>
     59e:	80 93 ba 01 	sts	0x01BA, r24	; 0x8001ba <__data_end>
	write_menu_oled_to_SRAM(current_menu);
     5a2:	0e 94 38 03 	call	0x670	; 0x670 <write_menu_oled_to_SRAM>
	
	/*_______HOVUDLØKKE______*/
	 while (1) {

        menu_navigate(&board, current_menu);  // Kallar `menu_navigate` med referanse til gjeldande meny
     5a6:	60 91 ba 01 	lds	r22, 0x01BA	; 0x8001ba <__data_end>
     5aa:	70 91 bb 01 	lds	r23, 0x01BB	; 0x8001bb <__data_end+0x1>
     5ae:	ce 01       	movw	r24, r28
     5b0:	01 96       	adiw	r24, 0x01	; 1
     5b2:	0e 94 ab 04 	call	0x956	; 0x956 <menu_navigate>
		/*Så lenge vi ikkje har noko delay gåandes og ditta står her tenker eg 
		at den oppdateres automatisk med det minnet vi har skreve til sramen?
		Det kunne vert fornuftig med eit flag her då
		*/
		
		if (get_time_in_ms() >= 16) {
     5b6:	0e 94 a6 09 	call	0x134c	; 0x134c <get_time_in_ms>
     5ba:	60 31       	cpi	r22, 0x10	; 16
     5bc:	71 05       	cpc	r23, r1
     5be:	81 05       	cpc	r24, r1
     5c0:	91 05       	cpc	r25, r1
     5c2:	88 f3       	brcs	.-30     	; 0x5a6 <main+0x90>
			restart_timer();
     5c4:	0e 94 b9 09 	call	0x1372	; 0x1372 <restart_timer>
			oled_data_from_SRAM();
     5c8:	0e 94 bf 06 	call	0xd7e	; 0xd7e <oled_data_from_SRAM>
     5cc:	ec cf       	rjmp	.-40     	; 0x5a6 <main+0x90>

000005ce <update_menu_arrows>:
}

// Sjekker om joystick-knappen er trykt
uint8_t is_joystick_button_pressed(MultiBoard* board) {
	return (board->JoyBtn != 0);  // Anta at knappen er aktiv-høg (1 betyr trykt)
}
     5ce:	cf 93       	push	r28
     5d0:	c8 2f       	mov	r28, r24
     5d2:	86 2f       	mov	r24, r22
     5d4:	40 e2       	ldi	r20, 0x20	; 32
     5d6:	60 e0       	ldi	r22, 0x00	; 0
     5d8:	0e 94 f4 07 	call	0xfe8	; 0xfe8 <oled_write_char_to_SRAM>
     5dc:	4e e3       	ldi	r20, 0x3E	; 62
     5de:	60 e0       	ldi	r22, 0x00	; 0
     5e0:	8c 2f       	mov	r24, r28
     5e2:	0e 94 f4 07 	call	0xfe8	; 0xfe8 <oled_write_char_to_SRAM>
     5e6:	cf 91       	pop	r28
     5e8:	08 95       	ret

000005ea <update_menu_position_from_joystick>:
     5ea:	fb 01       	movw	r30, r22
     5ec:	dc 01       	movw	r26, r24
     5ee:	1b 96       	adiw	r26, 0x0b	; 11
     5f0:	8d 91       	ld	r24, X+
     5f2:	9c 91       	ld	r25, X
     5f4:	1c 97       	sbiw	r26, 0x0c	; 12
     5f6:	83 33       	cpi	r24, 0x33	; 51
     5f8:	91 05       	cpc	r25, r1
     5fa:	ac f0       	brlt	.+42     	; 0x626 <update_menu_position_from_joystick+0x3c>
     5fc:	82 81       	ldd	r24, Z+2	; 0x02
     5fe:	88 23       	and	r24, r24
     600:	b1 f1       	breq	.+108    	; 0x66e <update_menu_position_from_joystick+0x84>
     602:	83 83       	std	Z+3, r24	; 0x03
     604:	81 50       	subi	r24, 0x01	; 1
     606:	82 83       	std	Z+2, r24	; 0x02
     608:	94 81       	ldd	r25, Z+4	; 0x04
     60a:	89 17       	cp	r24, r25
     60c:	10 f4       	brcc	.+4      	; 0x612 <update_menu_position_from_joystick+0x28>
     60e:	91 50       	subi	r25, 0x01	; 1
     610:	94 83       	std	Z+4, r25	; 0x04
     612:	bf ef       	ldi	r27, 0xFF	; 255
     614:	2f e7       	ldi	r18, 0x7F	; 127
     616:	81 e0       	ldi	r24, 0x01	; 1
     618:	b1 50       	subi	r27, 0x01	; 1
     61a:	20 40       	sbci	r18, 0x00	; 0
     61c:	80 40       	sbci	r24, 0x00	; 0
     61e:	e1 f7       	brne	.-8      	; 0x618 <update_menu_position_from_joystick+0x2e>
     620:	00 c0       	rjmp	.+0      	; 0x622 <update_menu_position_from_joystick+0x38>
     622:	00 c0       	rjmp	.+0      	; 0x624 <update_menu_position_from_joystick+0x3a>
     624:	08 95       	ret
     626:	8e 3c       	cpi	r24, 0xCE	; 206
     628:	9f 4f       	sbci	r25, 0xFF	; 255
     62a:	0c f5       	brge	.+66     	; 0x66e <update_menu_position_from_joystick+0x84>
     62c:	82 81       	ldd	r24, Z+2	; 0x02
     62e:	48 2f       	mov	r20, r24
     630:	50 e0       	ldi	r21, 0x00	; 0
     632:	25 81       	ldd	r18, Z+5	; 0x05
     634:	30 e0       	ldi	r19, 0x00	; 0
     636:	21 50       	subi	r18, 0x01	; 1
     638:	31 09       	sbc	r19, r1
     63a:	42 17       	cp	r20, r18
     63c:	53 07       	cpc	r21, r19
     63e:	bc f4       	brge	.+46     	; 0x66e <update_menu_position_from_joystick+0x84>
     640:	83 83       	std	Z+3, r24	; 0x03
     642:	8f 5f       	subi	r24, 0xFF	; 255
     644:	82 83       	std	Z+2, r24	; 0x02
     646:	44 81       	ldd	r20, Z+4	; 0x04
     648:	90 e0       	ldi	r25, 0x00	; 0
     64a:	24 2f       	mov	r18, r20
     64c:	30 e0       	ldi	r19, 0x00	; 0
     64e:	28 5f       	subi	r18, 0xF8	; 248
     650:	3f 4f       	sbci	r19, 0xFF	; 255
     652:	82 17       	cp	r24, r18
     654:	93 07       	cpc	r25, r19
     656:	14 f0       	brlt	.+4      	; 0x65c <update_menu_position_from_joystick+0x72>
     658:	4f 5f       	subi	r20, 0xFF	; 255
     65a:	44 83       	std	Z+4, r20	; 0x04
     65c:	bf ef       	ldi	r27, 0xFF	; 255
     65e:	2f e7       	ldi	r18, 0x7F	; 127
     660:	81 e0       	ldi	r24, 0x01	; 1
     662:	b1 50       	subi	r27, 0x01	; 1
     664:	20 40       	sbci	r18, 0x00	; 0
     666:	80 40       	sbci	r24, 0x00	; 0
     668:	e1 f7       	brne	.-8      	; 0x662 <update_menu_position_from_joystick+0x78>
     66a:	00 c0       	rjmp	.+0      	; 0x66c <update_menu_position_from_joystick+0x82>
     66c:	00 c0       	rjmp	.+0      	; 0x66e <update_menu_position_from_joystick+0x84>
     66e:	08 95       	ret

00000670 <write_menu_oled_to_SRAM>:
	
	
	
}

void write_menu_oled_to_SRAM(Menu* menu){
     670:	2f 92       	push	r2
     672:	3f 92       	push	r3
     674:	4f 92       	push	r4
     676:	5f 92       	push	r5
     678:	6f 92       	push	r6
     67a:	7f 92       	push	r7
     67c:	8f 92       	push	r8
     67e:	9f 92       	push	r9
     680:	af 92       	push	r10
     682:	bf 92       	push	r11
     684:	cf 92       	push	r12
     686:	df 92       	push	r13
     688:	ef 92       	push	r14
     68a:	ff 92       	push	r15
     68c:	0f 93       	push	r16
     68e:	1f 93       	push	r17
     690:	cf 93       	push	r28
     692:	df 93       	push	r29
     694:	cd b7       	in	r28, 0x3d	; 61
     696:	de b7       	in	r29, 0x3e	; 62
     698:	2a 97       	sbiw	r28, 0x0a	; 10
     69a:	0f b6       	in	r0, 0x3f	; 63
     69c:	f8 94       	cli
     69e:	de bf       	out	0x3e, r29	; 62
     6a0:	0f be       	out	0x3f, r0	; 63
     6a2:	cd bf       	out	0x3d, r28	; 61
     6a4:	7c 01       	movw	r14, r24
	uint8_t menuSize = menu->num_items;
     6a6:	dc 01       	movw	r26, r24
     6a8:	15 96       	adiw	r26, 0x05	; 5
     6aa:	8c 91       	ld	r24, X
	
	//Om det er 8 eller mindre linjer
	if(menuSize <= 128){
     6ac:	81 38       	cpi	r24, 0x81	; 129
     6ae:	50 f0       	brcs	.+20     	; 0x6c4 <write_menu_oled_to_SRAM+0x54>
	
	
	//Om det er mer enn 8 linjer
	//litt usikker om scroll kan gå for høy her, men satser på nei
	else{
		for(uint16_t j = 0; j < menuSize*16; j++) {
     6b0:	20 e1       	ldi	r18, 0x10	; 16
     6b2:	82 9f       	mul	r24, r18
     6b4:	f0 01       	movw	r30, r0
     6b6:	11 24       	eor	r1, r1
     6b8:	fc 83       	std	Y+4, r31	; 0x04
     6ba:	eb 83       	std	Y+3, r30	; 0x03
     6bc:	ef 2b       	or	r30, r31
     6be:	09 f0       	breq	.+2      	; 0x6c2 <write_menu_oled_to_SRAM+0x52>
     6c0:	bb c0       	rjmp	.+374    	; 0x838 <write_menu_oled_to_SRAM+0x1c8>
     6c2:	30 c1       	rjmp	.+608    	; 0x924 <write_menu_oled_to_SRAM+0x2b4>
void write_menu_oled_to_SRAM(Menu* menu){
	uint8_t menuSize = menu->num_items;
	
	//Om det er 8 eller mindre linjer
	if(menuSize <= 128){
		for(uint16_t j = 0; j < menuSize*16; j++) {
     6c4:	a8 2f       	mov	r26, r24
     6c6:	b0 e0       	ldi	r27, 0x00	; 0
     6c8:	b8 87       	std	Y+8, r27	; 0x08
     6ca:	af 83       	std	Y+7, r26	; 0x07
     6cc:	a2 95       	swap	r26
     6ce:	b2 95       	swap	r27
     6d0:	b0 7f       	andi	r27, 0xF0	; 240
     6d2:	ba 27       	eor	r27, r26
     6d4:	a0 7f       	andi	r26, 0xF0	; 240
     6d6:	ba 27       	eor	r27, r26
     6d8:	bc 83       	std	Y+4, r27	; 0x04
     6da:	ab 83       	std	Y+3, r26	; 0x03
     6dc:	be 83       	std	Y+6, r27	; 0x06
     6de:	ad 83       	std	Y+5, r26	; 0x05
     6e0:	ab 2b       	or	r26, r27
     6e2:	09 f4       	brne	.+2      	; 0x6e6 <write_menu_oled_to_SRAM+0x76>
     6e4:	6c c0       	rjmp	.+216    	; 0x7be <write_menu_oled_to_SRAM+0x14e>
     6e6:	1a 82       	std	Y+2, r1	; 0x02
     6e8:	19 82       	std	Y+1, r1	; 0x01
     6ea:	41 2c       	mov	r4, r1
     6ec:	51 2c       	mov	r5, r1
     6ee:	0f 2e       	mov	r0, r31
     6f0:	f8 e6       	ldi	r31, 0x68	; 104
     6f2:	8f 2e       	mov	r8, r31
     6f4:	f2 e0       	ldi	r31, 0x02	; 2
     6f6:	9f 2e       	mov	r9, r31
     6f8:	f0 2d       	mov	r31, r0
			char c = pgm_read_byte(&menu->items[j]);
			for(int i = 0; i < 8; i++){
				if((j%16 == 0) & (j/16 == menu->current_position)){
     6fa:	33 24       	eor	r3, r3
     6fc:	33 94       	inc	r3
     6fe:	21 2c       	mov	r2, r1
	uint8_t menuSize = menu->num_items;
	
	//Om det er 8 eller mindre linjer
	if(menuSize <= 128){
		for(uint16_t j = 0; j < menuSize*16; j++) {
			char c = pgm_read_byte(&menu->items[j]);
     700:	d7 01       	movw	r26, r14
     702:	ed 91       	ld	r30, X+
     704:	fc 91       	ld	r31, X
     706:	e4 0d       	add	r30, r4
     708:	f5 1d       	adc	r31, r5
     70a:	c4 90       	lpm	r12, Z
			for(int i = 0; i < 8; i++){
				if((j%16 == 0) & (j/16 == menu->current_position)){
     70c:	32 01       	movw	r6, r4
     70e:	76 94       	lsr	r7
     710:	67 94       	ror	r6
     712:	76 94       	lsr	r7
     714:	67 94       	ror	r6
     716:	76 94       	lsr	r7
     718:	67 94       	ror	r6
     71a:	76 94       	lsr	r7
     71c:	67 94       	ror	r6
					SRAM_write(j*8 + i, pgm_read_byte(&font8x8_basic[('>'-32)*8 + i]));
				}
				else{
					SRAM_write(j*8 + i, pgm_read_byte(&font8x8_basic[(c-32)*8 + i]));	
     71e:	d1 2c       	mov	r13, r1
     720:	c6 01       	movw	r24, r12
     722:	88 0f       	add	r24, r24
     724:	99 1f       	adc	r25, r25
     726:	88 0f       	add	r24, r24
     728:	99 1f       	adc	r25, r25
     72a:	88 0f       	add	r24, r24
     72c:	99 1f       	adc	r25, r25
     72e:	e0 e6       	ldi	r30, 0x60	; 96
     730:	f2 e0       	ldi	r31, 0x02	; 2
     732:	fa 87       	std	Y+10, r31	; 0x0a
     734:	e9 87       	std	Y+9, r30	; 0x09
     736:	09 81       	ldd	r16, Y+1	; 0x01
     738:	1a 81       	ldd	r17, Y+2	; 0x02
	//Om det er 8 eller mindre linjer
	if(menuSize <= 128){
		for(uint16_t j = 0; j < menuSize*16; j++) {
			char c = pgm_read_byte(&menu->items[j]);
			for(int i = 0; i < 8; i++){
				if((j%16 == 0) & (j/16 == menu->current_position)){
     73a:	52 01       	movw	r10, r4
     73c:	ff e0       	ldi	r31, 0x0F	; 15
     73e:	af 22       	and	r10, r31
     740:	bb 24       	eor	r11, r11
					SRAM_write(j*8 + i, pgm_read_byte(&font8x8_basic[('>'-32)*8 + i]));
				}
				else{
					SRAM_write(j*8 + i, pgm_read_byte(&font8x8_basic[(c-32)*8 + i]));	
     742:	9c 01       	movw	r18, r24
     744:	20 5f       	subi	r18, 0xF0	; 240
     746:	31 40       	sbci	r19, 0x01	; 1
     748:	69 01       	movw	r12, r18
	//Om det er 8 eller mindre linjer
	if(menuSize <= 128){
		for(uint16_t j = 0; j < menuSize*16; j++) {
			char c = pgm_read_byte(&menu->items[j]);
			for(int i = 0; i < 8; i++){
				if((j%16 == 0) & (j/16 == menu->current_position)){
     74a:	83 2d       	mov	r24, r3
     74c:	a1 14       	cp	r10, r1
     74e:	b1 04       	cpc	r11, r1
     750:	09 f0       	breq	.+2      	; 0x754 <write_menu_oled_to_SRAM+0xe4>
     752:	82 2d       	mov	r24, r2
     754:	88 23       	and	r24, r24
     756:	91 f0       	breq	.+36     	; 0x77c <write_menu_oled_to_SRAM+0x10c>
     758:	d7 01       	movw	r26, r14
     75a:	12 96       	adiw	r26, 0x02	; 2
     75c:	8c 91       	ld	r24, X
     75e:	90 e0       	ldi	r25, 0x00	; 0
     760:	23 2d       	mov	r18, r3
     762:	86 15       	cp	r24, r6
     764:	97 05       	cpc	r25, r7
     766:	09 f0       	breq	.+2      	; 0x76a <write_menu_oled_to_SRAM+0xfa>
     768:	22 2d       	mov	r18, r2
     76a:	22 23       	and	r18, r18
     76c:	39 f0       	breq	.+14     	; 0x77c <write_menu_oled_to_SRAM+0x10c>
					SRAM_write(j*8 + i, pgm_read_byte(&font8x8_basic[('>'-32)*8 + i]));
     76e:	e9 85       	ldd	r30, Y+9	; 0x09
     770:	fa 85       	ldd	r31, Y+10	; 0x0a
     772:	64 91       	lpm	r22, Z
     774:	c8 01       	movw	r24, r16
     776:	0e 94 d3 09 	call	0x13a6	; 0x13a6 <SRAM_write>
     77a:	08 c0       	rjmp	.+16     	; 0x78c <write_menu_oled_to_SRAM+0x11c>
				}
				else{
					SRAM_write(j*8 + i, pgm_read_byte(&font8x8_basic[(c-32)*8 + i]));	
     77c:	e9 85       	ldd	r30, Y+9	; 0x09
     77e:	fa 85       	ldd	r31, Y+10	; 0x0a
     780:	ec 0d       	add	r30, r12
     782:	fd 1d       	adc	r31, r13
     784:	64 91       	lpm	r22, Z
     786:	c8 01       	movw	r24, r16
     788:	0e 94 d3 09 	call	0x13a6	; 0x13a6 <SRAM_write>
     78c:	29 85       	ldd	r18, Y+9	; 0x09
     78e:	3a 85       	ldd	r19, Y+10	; 0x0a
     790:	2f 5f       	subi	r18, 0xFF	; 255
     792:	3f 4f       	sbci	r19, 0xFF	; 255
     794:	3a 87       	std	Y+10, r19	; 0x0a
     796:	29 87       	std	Y+9, r18	; 0x09
     798:	0f 5f       	subi	r16, 0xFF	; 255
     79a:	1f 4f       	sbci	r17, 0xFF	; 255
	
	//Om det er 8 eller mindre linjer
	if(menuSize <= 128){
		for(uint16_t j = 0; j < menuSize*16; j++) {
			char c = pgm_read_byte(&menu->items[j]);
			for(int i = 0; i < 8; i++){
     79c:	82 16       	cp	r8, r18
     79e:	93 06       	cpc	r9, r19
     7a0:	a1 f6       	brne	.-88     	; 0x74a <write_menu_oled_to_SRAM+0xda>
void write_menu_oled_to_SRAM(Menu* menu){
	uint8_t menuSize = menu->num_items;
	
	//Om det er 8 eller mindre linjer
	if(menuSize <= 128){
		for(uint16_t j = 0; j < menuSize*16; j++) {
     7a2:	3f ef       	ldi	r19, 0xFF	; 255
     7a4:	43 1a       	sub	r4, r19
     7a6:	53 0a       	sbc	r5, r19
     7a8:	89 81       	ldd	r24, Y+1	; 0x01
     7aa:	9a 81       	ldd	r25, Y+2	; 0x02
     7ac:	08 96       	adiw	r24, 0x08	; 8
     7ae:	9a 83       	std	Y+2, r25	; 0x02
     7b0:	89 83       	std	Y+1, r24	; 0x01
     7b2:	ad 81       	ldd	r26, Y+5	; 0x05
     7b4:	be 81       	ldd	r27, Y+6	; 0x06
     7b6:	4a 16       	cp	r4, r26
     7b8:	5b 06       	cpc	r5, r27
     7ba:	09 f0       	breq	.+2      	; 0x7be <write_menu_oled_to_SRAM+0x14e>
     7bc:	a1 cf       	rjmp	.-190    	; 0x700 <write_menu_oled_to_SRAM+0x90>
					SRAM_write(j*8 + i, pgm_read_byte(&font8x8_basic[(c-32)*8 + i]));	
				}	
			}	
		}
		//om menyen er mindre enn 8 linjer fyll resten med ' ' 
		for(uint8_t i = 0; i < 128-menuSize*16; i++){
     7be:	08 e0       	ldi	r16, 0x08	; 8
     7c0:	10 e0       	ldi	r17, 0x00	; 0
     7c2:	ef 81       	ldd	r30, Y+7	; 0x07
     7c4:	f8 85       	ldd	r31, Y+8	; 0x08
     7c6:	0e 1b       	sub	r16, r30
     7c8:	1f 0b       	sbc	r17, r31
     7ca:	02 95       	swap	r16
     7cc:	12 95       	swap	r17
     7ce:	10 7f       	andi	r17, 0xF0	; 240
     7d0:	10 27       	eor	r17, r16
     7d2:	00 7f       	andi	r16, 0xF0	; 240
     7d4:	10 27       	eor	r17, r16
     7d6:	10 16       	cp	r1, r16
     7d8:	11 06       	cpc	r1, r17
     7da:	c4 f0       	brlt	.+48     	; 0x80c <write_menu_oled_to_SRAM+0x19c>
     7dc:	a3 c0       	rjmp	.+326    	; 0x924 <write_menu_oled_to_SRAM+0x2b4>
			for(uint8_t j = 0; j < 8; j++){
				SRAM_write(menuSize*16*8+i*8+j, 0);
     7de:	60 e0       	ldi	r22, 0x00	; 0
     7e0:	89 81       	ldd	r24, Y+1	; 0x01
     7e2:	9a 81       	ldd	r25, Y+2	; 0x02
     7e4:	0e 94 d3 09 	call	0x13a6	; 0x13a6 <SRAM_write>
     7e8:	29 81       	ldd	r18, Y+1	; 0x01
     7ea:	3a 81       	ldd	r19, Y+2	; 0x02
     7ec:	2f 5f       	subi	r18, 0xFF	; 255
     7ee:	3f 4f       	sbci	r19, 0xFF	; 255
     7f0:	3a 83       	std	Y+2, r19	; 0x02
     7f2:	29 83       	std	Y+1, r18	; 0x01
				}	
			}	
		}
		//om menyen er mindre enn 8 linjer fyll resten med ' ' 
		for(uint8_t i = 0; i < 128-menuSize*16; i++){
			for(uint8_t j = 0; j < 8; j++){
     7f4:	2e 15       	cp	r18, r14
     7f6:	3f 05       	cpc	r19, r15
     7f8:	91 f7       	brne	.-28     	; 0x7de <write_menu_oled_to_SRAM+0x16e>
					SRAM_write(j*8 + i, pgm_read_byte(&font8x8_basic[(c-32)*8 + i]));	
				}	
			}	
		}
		//om menyen er mindre enn 8 linjer fyll resten med ' ' 
		for(uint8_t i = 0; i < 128-menuSize*16; i++){
     7fa:	d3 94       	inc	r13
     7fc:	8d 2d       	mov	r24, r13
     7fe:	90 e0       	ldi	r25, 0x00	; 0
     800:	9a 83       	std	Y+2, r25	; 0x02
     802:	89 83       	std	Y+1, r24	; 0x01
     804:	80 17       	cp	r24, r16
     806:	91 07       	cpc	r25, r17
     808:	24 f0       	brlt	.+8      	; 0x812 <write_menu_oled_to_SRAM+0x1a2>
     80a:	8c c0       	rjmp	.+280    	; 0x924 <write_menu_oled_to_SRAM+0x2b4>
     80c:	1a 82       	std	Y+2, r1	; 0x02
     80e:	19 82       	std	Y+1, r1	; 0x01
     810:	d1 2c       	mov	r13, r1
     812:	a9 81       	ldd	r26, Y+1	; 0x01
     814:	ba 81       	ldd	r27, Y+2	; 0x02
     816:	eb 81       	ldd	r30, Y+3	; 0x03
     818:	fc 81       	ldd	r31, Y+4	; 0x04
     81a:	ae 0f       	add	r26, r30
     81c:	bf 1f       	adc	r27, r31
     81e:	aa 0f       	add	r26, r26
     820:	bb 1f       	adc	r27, r27
     822:	aa 0f       	add	r26, r26
     824:	bb 1f       	adc	r27, r27
     826:	aa 0f       	add	r26, r26
     828:	bb 1f       	adc	r27, r27
     82a:	ba 83       	std	Y+2, r27	; 0x02
     82c:	a9 83       	std	Y+1, r26	; 0x01
     82e:	7d 01       	movw	r14, r26
     830:	f8 e0       	ldi	r31, 0x08	; 8
     832:	ef 0e       	add	r14, r31
     834:	f1 1c       	adc	r15, r1
     836:	d3 cf       	rjmp	.-90     	; 0x7de <write_menu_oled_to_SRAM+0x16e>
	
	
	//Om det er mer enn 8 linjer
	//litt usikker om scroll kan gå for høy her, men satser på nei
	else{
		for(uint16_t j = 0; j < menuSize*16; j++) {
     838:	1a 82       	std	Y+2, r1	; 0x02
     83a:	19 82       	std	Y+1, r1	; 0x01
     83c:	41 2c       	mov	r4, r1
     83e:	51 2c       	mov	r5, r1
     840:	0f 2e       	mov	r0, r31
     842:	f8 e6       	ldi	r31, 0x68	; 104
     844:	8f 2e       	mov	r8, r31
     846:	f2 e0       	ldi	r31, 0x02	; 2
     848:	9f 2e       	mov	r9, r31
     84a:	f0 2d       	mov	r31, r0
			char c = pgm_read_byte(&menu->items[menu->scroll_offset*16 + j]);
			for(int i = 0; i < 8; i++){
				if((j%16 == 0) & (j/16 == menu->current_position)){
     84c:	33 24       	eor	r3, r3
     84e:	33 94       	inc	r3
     850:	21 2c       	mov	r2, r1
	
	//Om det er mer enn 8 linjer
	//litt usikker om scroll kan gå for høy her, men satser på nei
	else{
		for(uint16_t j = 0; j < menuSize*16; j++) {
			char c = pgm_read_byte(&menu->items[menu->scroll_offset*16 + j]);
     852:	d7 01       	movw	r26, r14
     854:	14 96       	adiw	r26, 0x04	; 4
     856:	8c 91       	ld	r24, X
     858:	14 97       	sbiw	r26, 0x04	; 4
     85a:	f2 01       	movw	r30, r4
     85c:	20 e1       	ldi	r18, 0x10	; 16
     85e:	82 9f       	mul	r24, r18
     860:	e0 0d       	add	r30, r0
     862:	f1 1d       	adc	r31, r1
     864:	11 24       	eor	r1, r1
     866:	cf 01       	movw	r24, r30
     868:	ed 91       	ld	r30, X+
     86a:	fc 91       	ld	r31, X
     86c:	e8 0f       	add	r30, r24
     86e:	f9 1f       	adc	r31, r25
     870:	c4 90       	lpm	r12, Z
			for(int i = 0; i < 8; i++){
				if((j%16 == 0) & (j/16 == menu->current_position)){
     872:	32 01       	movw	r6, r4
     874:	76 94       	lsr	r7
     876:	67 94       	ror	r6
     878:	76 94       	lsr	r7
     87a:	67 94       	ror	r6
     87c:	76 94       	lsr	r7
     87e:	67 94       	ror	r6
     880:	76 94       	lsr	r7
     882:	67 94       	ror	r6
					SRAM_write(j*8 + i, pgm_read_byte(&font8x8_basic[('>'-32)*8 + i]));
				}
				else{
					SRAM_write(j*8 + i, pgm_read_byte(&font8x8_basic[(c-32)*8 + i]));
     884:	d1 2c       	mov	r13, r1
     886:	c6 01       	movw	r24, r12
     888:	88 0f       	add	r24, r24
     88a:	99 1f       	adc	r25, r25
     88c:	88 0f       	add	r24, r24
     88e:	99 1f       	adc	r25, r25
     890:	88 0f       	add	r24, r24
     892:	99 1f       	adc	r25, r25
     894:	a0 e6       	ldi	r26, 0x60	; 96
     896:	b2 e0       	ldi	r27, 0x02	; 2
     898:	be 83       	std	Y+6, r27	; 0x06
     89a:	ad 83       	std	Y+5, r26	; 0x05
     89c:	09 81       	ldd	r16, Y+1	; 0x01
     89e:	1a 81       	ldd	r17, Y+2	; 0x02
	//litt usikker om scroll kan gå for høy her, men satser på nei
	else{
		for(uint16_t j = 0; j < menuSize*16; j++) {
			char c = pgm_read_byte(&menu->items[menu->scroll_offset*16 + j]);
			for(int i = 0; i < 8; i++){
				if((j%16 == 0) & (j/16 == menu->current_position)){
     8a0:	52 01       	movw	r10, r4
     8a2:	bf e0       	ldi	r27, 0x0F	; 15
     8a4:	ab 22       	and	r10, r27
     8a6:	bb 24       	eor	r11, r11
					SRAM_write(j*8 + i, pgm_read_byte(&font8x8_basic[('>'-32)*8 + i]));
				}
				else{
					SRAM_write(j*8 + i, pgm_read_byte(&font8x8_basic[(c-32)*8 + i]));
     8a8:	fc 01       	movw	r30, r24
     8aa:	e0 5f       	subi	r30, 0xF0	; 240
     8ac:	f1 40       	sbci	r31, 0x01	; 1
     8ae:	6f 01       	movw	r12, r30
	//litt usikker om scroll kan gå for høy her, men satser på nei
	else{
		for(uint16_t j = 0; j < menuSize*16; j++) {
			char c = pgm_read_byte(&menu->items[menu->scroll_offset*16 + j]);
			for(int i = 0; i < 8; i++){
				if((j%16 == 0) & (j/16 == menu->current_position)){
     8b0:	83 2d       	mov	r24, r3
     8b2:	a1 14       	cp	r10, r1
     8b4:	b1 04       	cpc	r11, r1
     8b6:	09 f0       	breq	.+2      	; 0x8ba <write_menu_oled_to_SRAM+0x24a>
     8b8:	82 2d       	mov	r24, r2
     8ba:	88 23       	and	r24, r24
     8bc:	91 f0       	breq	.+36     	; 0x8e2 <write_menu_oled_to_SRAM+0x272>
     8be:	d7 01       	movw	r26, r14
     8c0:	12 96       	adiw	r26, 0x02	; 2
     8c2:	8c 91       	ld	r24, X
     8c4:	90 e0       	ldi	r25, 0x00	; 0
     8c6:	23 2d       	mov	r18, r3
     8c8:	86 15       	cp	r24, r6
     8ca:	97 05       	cpc	r25, r7
     8cc:	09 f0       	breq	.+2      	; 0x8d0 <write_menu_oled_to_SRAM+0x260>
     8ce:	22 2d       	mov	r18, r2
     8d0:	22 23       	and	r18, r18
     8d2:	39 f0       	breq	.+14     	; 0x8e2 <write_menu_oled_to_SRAM+0x272>
					SRAM_write(j*8 + i, pgm_read_byte(&font8x8_basic[('>'-32)*8 + i]));
     8d4:	ed 81       	ldd	r30, Y+5	; 0x05
     8d6:	fe 81       	ldd	r31, Y+6	; 0x06
     8d8:	64 91       	lpm	r22, Z
     8da:	c8 01       	movw	r24, r16
     8dc:	0e 94 d3 09 	call	0x13a6	; 0x13a6 <SRAM_write>
     8e0:	08 c0       	rjmp	.+16     	; 0x8f2 <write_menu_oled_to_SRAM+0x282>
				}
				else{
					SRAM_write(j*8 + i, pgm_read_byte(&font8x8_basic[(c-32)*8 + i]));
     8e2:	ed 81       	ldd	r30, Y+5	; 0x05
     8e4:	fe 81       	ldd	r31, Y+6	; 0x06
     8e6:	ec 0d       	add	r30, r12
     8e8:	fd 1d       	adc	r31, r13
     8ea:	64 91       	lpm	r22, Z
     8ec:	c8 01       	movw	r24, r16
     8ee:	0e 94 d3 09 	call	0x13a6	; 0x13a6 <SRAM_write>
     8f2:	2d 81       	ldd	r18, Y+5	; 0x05
     8f4:	3e 81       	ldd	r19, Y+6	; 0x06
     8f6:	2f 5f       	subi	r18, 0xFF	; 255
     8f8:	3f 4f       	sbci	r19, 0xFF	; 255
     8fa:	3e 83       	std	Y+6, r19	; 0x06
     8fc:	2d 83       	std	Y+5, r18	; 0x05
     8fe:	0f 5f       	subi	r16, 0xFF	; 255
     900:	1f 4f       	sbci	r17, 0xFF	; 255
	//Om det er mer enn 8 linjer
	//litt usikker om scroll kan gå for høy her, men satser på nei
	else{
		for(uint16_t j = 0; j < menuSize*16; j++) {
			char c = pgm_read_byte(&menu->items[menu->scroll_offset*16 + j]);
			for(int i = 0; i < 8; i++){
     902:	82 16       	cp	r8, r18
     904:	93 06       	cpc	r9, r19
     906:	a1 f6       	brne	.-88     	; 0x8b0 <write_menu_oled_to_SRAM+0x240>
	
	
	//Om det er mer enn 8 linjer
	//litt usikker om scroll kan gå for høy her, men satser på nei
	else{
		for(uint16_t j = 0; j < menuSize*16; j++) {
     908:	3f ef       	ldi	r19, 0xFF	; 255
     90a:	43 1a       	sub	r4, r19
     90c:	53 0a       	sbc	r5, r19
     90e:	89 81       	ldd	r24, Y+1	; 0x01
     910:	9a 81       	ldd	r25, Y+2	; 0x02
     912:	08 96       	adiw	r24, 0x08	; 8
     914:	9a 83       	std	Y+2, r25	; 0x02
     916:	89 83       	std	Y+1, r24	; 0x01
     918:	ab 81       	ldd	r26, Y+3	; 0x03
     91a:	bc 81       	ldd	r27, Y+4	; 0x04
     91c:	4a 16       	cp	r4, r26
     91e:	5b 06       	cpc	r5, r27
     920:	09 f0       	breq	.+2      	; 0x924 <write_menu_oled_to_SRAM+0x2b4>
     922:	97 cf       	rjmp	.-210    	; 0x852 <write_menu_oled_to_SRAM+0x1e2>
				}
			}
		}
	}
	
}
     924:	2a 96       	adiw	r28, 0x0a	; 10
     926:	0f b6       	in	r0, 0x3f	; 63
     928:	f8 94       	cli
     92a:	de bf       	out	0x3e, r29	; 62
     92c:	0f be       	out	0x3f, r0	; 63
     92e:	cd bf       	out	0x3d, r28	; 61
     930:	df 91       	pop	r29
     932:	cf 91       	pop	r28
     934:	1f 91       	pop	r17
     936:	0f 91       	pop	r16
     938:	ff 90       	pop	r15
     93a:	ef 90       	pop	r14
     93c:	df 90       	pop	r13
     93e:	cf 90       	pop	r12
     940:	bf 90       	pop	r11
     942:	af 90       	pop	r10
     944:	9f 90       	pop	r9
     946:	8f 90       	pop	r8
     948:	7f 90       	pop	r7
     94a:	6f 90       	pop	r6
     94c:	5f 90       	pop	r5
     94e:	4f 90       	pop	r4
     950:	3f 90       	pop	r3
     952:	2f 90       	pop	r2
     954:	08 95       	ret

00000956 <menu_navigate>:
tillater oss å modifisere pekeren som peker til den aktive menyen 
(f.eks. current_menu) inne i funksjonen. Dette er nyttig hvis vi trenger 
å bytte meny underveis, f.eks. fra hovedmeny til innstillingsmeny.
- Ganske fett
*/
void menu_navigate(MultiBoard* board, Menu* menu) {
     956:	0f 93       	push	r16
     958:	1f 93       	push	r17
     95a:	cf 93       	push	r28
     95c:	df 93       	push	r29
     95e:	8c 01       	movw	r16, r24
     960:	eb 01       	movw	r28, r22

	// Oppdater joystick- og menyposisjon
	MultiBoard_Update(board);
     962:	0e 94 06 06 	call	0xc0c	; 0xc0c <MultiBoard_Update>
	update_menu_position_from_joystick(board, menu);
     966:	be 01       	movw	r22, r28
     968:	c8 01       	movw	r24, r16
     96a:	0e 94 f5 02 	call	0x5ea	; 0x5ea <update_menu_position_from_joystick>



	// Sjekk om knappen er trykt for å bekrefte menyval
	if (is_joystick_button_pressed(board)) {
     96e:	f8 01       	movw	r30, r16
     970:	86 81       	ldd	r24, Z+6	; 0x06
     972:	88 23       	and	r24, r24
     974:	41 f0       	breq	.+16     	; 0x986 <menu_navigate+0x30>
		
		handleMenuSelection(board, menu);  // Behandlar menyvalet
     976:	be 01       	movw	r22, r28
     978:	c8 01       	movw	r24, r16
     97a:	0e 94 db 04 	call	0x9b6	; 0x9b6 <handleMenuSelection>
		//oled_display_menu(menu);
		write_menu_oled_to_SRAM(menu);
     97e:	ce 01       	movw	r24, r28
     980:	0e 94 38 03 	call	0x670	; 0x670 <write_menu_oled_to_SRAM>
     984:	07 c0       	rjmp	.+14     	; 0x994 <menu_navigate+0x3e>
	}else {
		update_menu_arrows(menu->current_position - menu->scroll_offset,menu->prev_position - menu->scroll_offset);
     986:	9c 81       	ldd	r25, Y+4	; 0x04
     988:	6b 81       	ldd	r22, Y+3	; 0x03
     98a:	69 1b       	sub	r22, r25
     98c:	8a 81       	ldd	r24, Y+2	; 0x02
     98e:	89 1b       	sub	r24, r25
     990:	0e 94 e7 02 	call	0x5ce	; 0x5ce <update_menu_arrows>
	}
	
	
	
}
     994:	df 91       	pop	r29
     996:	cf 91       	pop	r28
     998:	1f 91       	pop	r17
     99a:	0f 91       	pop	r16
     99c:	08 95       	ret

0000099e <initialize_menus>:
Menu scrollMenu;
Menu settingsMenu;

void initialize_menus() {
	
	mainMenu.items = &mainMenuItems;//" Start Game      Settings        High Scores     Credits         Exit                                                           ";
     99e:	e7 ec       	ldi	r30, 0xC7	; 199
     9a0:	f1 e0       	ldi	r31, 0x01	; 1
     9a2:	80 e7       	ldi	r24, 0x70	; 112
     9a4:	90 e0       	ldi	r25, 0x00	; 0
     9a6:	91 83       	std	Z+1, r25	; 0x01
     9a8:	80 83       	st	Z, r24
	mainMenu.num_items = 5;
     9aa:	85 e0       	ldi	r24, 0x05	; 5
     9ac:	85 83       	std	Z+5, r24	; 0x05
	mainMenu.current_position = 0;
     9ae:	12 82       	std	Z+2, r1	; 0x02
	mainMenu.prev_position = 0;
     9b0:	13 82       	std	Z+3, r1	; 0x03
	mainMenu.scroll_offset = 0;
     9b2:	14 82       	std	Z+4, r1	; 0x04
     9b4:	08 95       	ret

000009b6 <handleMenuSelection>:
	//settingsMenu.prev_position = 0;
	//settingsMenu.scroll_offset = 0;
}

void handleMenuSelection(MultiBoard* board, Menu* menu) {
	switch (currentMenuState) {
     9b6:	80 91 bc 01 	lds	r24, 0x01BC	; 0x8001bc <currentMenuState>
     9ba:	81 30       	cpi	r24, 0x01	; 1
     9bc:	09 f4       	brne	.+2      	; 0x9c0 <handleMenuSelection+0xa>
     9be:	6f c0       	rjmp	.+222    	; 0xa9e <handleMenuSelection+0xe8>
     9c0:	20 f0       	brcs	.+8      	; 0x9ca <handleMenuSelection+0x14>
     9c2:	82 30       	cpi	r24, 0x02	; 2
     9c4:	09 f4       	brne	.+2      	; 0x9c8 <handleMenuSelection+0x12>
     9c6:	40 c0       	rjmp	.+128    	; 0xa48 <handleMenuSelection+0x92>
     9c8:	08 95       	ret
		case MAIN_MENU:
		switch (menu->current_position) {
     9ca:	fb 01       	movw	r30, r22
     9cc:	82 81       	ldd	r24, Z+2	; 0x02
     9ce:	82 30       	cpi	r24, 0x02	; 2
     9d0:	d9 f0       	breq	.+54     	; 0xa08 <handleMenuSelection+0x52>
     9d2:	28 f4       	brcc	.+10     	; 0x9de <handleMenuSelection+0x28>
     9d4:	88 23       	and	r24, r24
     9d6:	41 f0       	breq	.+16     	; 0x9e8 <handleMenuSelection+0x32>
     9d8:	81 30       	cpi	r24, 0x01	; 1
     9da:	61 f0       	breq	.+24     	; 0x9f4 <handleMenuSelection+0x3e>
     9dc:	2f c0       	rjmp	.+94     	; 0xa3c <handleMenuSelection+0x86>
     9de:	83 30       	cpi	r24, 0x03	; 3
     9e0:	e9 f0       	breq	.+58     	; 0xa1c <handleMenuSelection+0x66>
     9e2:	84 30       	cpi	r24, 0x04	; 4
     9e4:	29 f1       	breq	.+74     	; 0xa30 <handleMenuSelection+0x7a>
     9e6:	2a c0       	rjmp	.+84     	; 0xa3c <handleMenuSelection+0x86>
			case 0:
			oled_write_line_to_SRAM(0, "Startar spelet...");
     9e8:	6c e1       	ldi	r22, 0x1C	; 28
     9ea:	71 e0       	ldi	r23, 0x01	; 1
     9ec:	80 e0       	ldi	r24, 0x00	; 0
     9ee:	0e 94 7c 07 	call	0xef8	; 0xef8 <oled_write_line_to_SRAM>
			break;
     9f2:	08 95       	ret
			case 1:
			// Gå til innstillingar
			currentMenuState = SETTINGS_MENU;
     9f4:	82 e0       	ldi	r24, 0x02	; 2
     9f6:	80 93 bc 01 	sts	0x01BC, r24	; 0x8001bc <currentMenuState>
			current_menu = &settingsMenu;  // Oppdater til innstillingsmeny
     9fa:	81 ec       	ldi	r24, 0xC1	; 193
     9fc:	91 e0       	ldi	r25, 0x01	; 1
     9fe:	90 93 bb 01 	sts	0x01BB, r25	; 0x8001bb <__data_end+0x1>
     a02:	80 93 ba 01 	sts	0x01BA, r24	; 0x8001ba <__data_end>
			break;
     a06:	08 95       	ret
			case 2:
			// Gå til scrollemeny
			currentMenuState = SCROLL_MENU;
     a08:	81 e0       	ldi	r24, 0x01	; 1
     a0a:	80 93 bc 01 	sts	0x01BC, r24	; 0x8001bc <currentMenuState>
			current_menu = &scrollMenu;  // Oppdater til scrollemeny
     a0e:	8d ec       	ldi	r24, 0xCD	; 205
     a10:	91 e0       	ldi	r25, 0x01	; 1
     a12:	90 93 bb 01 	sts	0x01BB, r25	; 0x8001bb <__data_end+0x1>
     a16:	80 93 ba 01 	sts	0x01BA, r24	; 0x8001ba <__data_end>
			break;
     a1a:	08 95       	ret
			case 3:
			oled_write_line_to_SRAM(0, "Viser kredittar...");
     a1c:	6e e2       	ldi	r22, 0x2E	; 46
     a1e:	71 e0       	ldi	r23, 0x01	; 1
     a20:	80 e0       	ldi	r24, 0x00	; 0
     a22:	0e 94 7c 07 	call	0xef8	; 0xef8 <oled_write_line_to_SRAM>
			oled_write_screen_to_SRAM(solkors);  // Vis kredittar på skjermen
     a26:	80 ef       	ldi	r24, 0xF0	; 240
     a28:	90 e0       	ldi	r25, 0x00	; 0
     a2a:	0e 94 11 07 	call	0xe22	; 0xe22 <oled_write_screen_to_SRAM>
			break;
     a2e:	08 95       	ret
			case 4:
			oled_write_line_to_SRAM(0, "Avsluttar...");
     a30:	61 e4       	ldi	r22, 0x41	; 65
     a32:	71 e0       	ldi	r23, 0x01	; 1
     a34:	80 e0       	ldi	r24, 0x00	; 0
     a36:	0e 94 7c 07 	call	0xef8	; 0xef8 <oled_write_line_to_SRAM>
			// Legg eventuelt til funksjonalitet for å avslutte
			break;
     a3a:	08 95       	ret
			default:
			oled_write_line_to_SRAM(0, "Ugyldig valg");
     a3c:	6e e4       	ldi	r22, 0x4E	; 78
     a3e:	71 e0       	ldi	r23, 0x01	; 1
     a40:	80 e0       	ldi	r24, 0x00	; 0
     a42:	0e 94 7c 07 	call	0xef8	; 0xef8 <oled_write_line_to_SRAM>
			break;
     a46:	08 95       	ret
		}
		break;

		case SETTINGS_MENU:
		// Håndter valg i innstillingsmenyen
		switch (menu->current_position) {
     a48:	fb 01       	movw	r30, r22
     a4a:	82 81       	ldd	r24, Z+2	; 0x02
     a4c:	81 30       	cpi	r24, 0x01	; 1
     a4e:	61 f0       	breq	.+24     	; 0xa68 <handleMenuSelection+0xb2>
     a50:	28 f0       	brcs	.+10     	; 0xa5c <handleMenuSelection+0xa6>
     a52:	82 30       	cpi	r24, 0x02	; 2
     a54:	79 f0       	breq	.+30     	; 0xa74 <handleMenuSelection+0xbe>
     a56:	83 30       	cpi	r24, 0x03	; 3
     a58:	99 f0       	breq	.+38     	; 0xa80 <handleMenuSelection+0xca>
     a5a:	1b c0       	rjmp	.+54     	; 0xa92 <handleMenuSelection+0xdc>
			case 0:
			oled_write_line_to_SRAM(0, "Endrer lydinnstillingar...");
     a5c:	6b e5       	ldi	r22, 0x5B	; 91
     a5e:	71 e0       	ldi	r23, 0x01	; 1
     a60:	80 e0       	ldi	r24, 0x00	; 0
     a62:	0e 94 7c 07 	call	0xef8	; 0xef8 <oled_write_line_to_SRAM>
			break;
     a66:	08 95       	ret
			case 1:
			oled_write_line_to_SRAM(0, "Endrer lysstyrke...");
     a68:	66 e7       	ldi	r22, 0x76	; 118
     a6a:	71 e0       	ldi	r23, 0x01	; 1
     a6c:	80 e0       	ldi	r24, 0x00	; 0
     a6e:	0e 94 7c 07 	call	0xef8	; 0xef8 <oled_write_line_to_SRAM>
			break;
     a72:	08 95       	ret
			case 2:
			oled_write_line_to_SRAM(0, "Endrer kontrollar...");
     a74:	6a e8       	ldi	r22, 0x8A	; 138
     a76:	71 e0       	ldi	r23, 0x01	; 1
     a78:	80 e0       	ldi	r24, 0x00	; 0
     a7a:	0e 94 7c 07 	call	0xef8	; 0xef8 <oled_write_line_to_SRAM>
			break;
     a7e:	08 95       	ret
			case 3:
			// Gå tilbake til hovudmenyen
			currentMenuState = MAIN_MENU;
     a80:	10 92 bc 01 	sts	0x01BC, r1	; 0x8001bc <currentMenuState>
			current_menu = &mainMenu;
     a84:	87 ec       	ldi	r24, 0xC7	; 199
     a86:	91 e0       	ldi	r25, 0x01	; 1
     a88:	90 93 bb 01 	sts	0x01BB, r25	; 0x8001bb <__data_end+0x1>
     a8c:	80 93 ba 01 	sts	0x01BA, r24	; 0x8001ba <__data_end>
			break;
     a90:	08 95       	ret
			default:
			oled_write_line_to_SRAM(0, "Ugyldig valg");
     a92:	6e e4       	ldi	r22, 0x4E	; 78
     a94:	71 e0       	ldi	r23, 0x01	; 1
     a96:	80 e0       	ldi	r24, 0x00	; 0
     a98:	0e 94 7c 07 	call	0xef8	; 0xef8 <oled_write_line_to_SRAM>
			break;
     a9c:	08 95       	ret
		}
		break;

		case SCROLL_MENU:
		// Håndter valg i scrollemenyen
		switch (menu->current_position) {
     a9e:	fb 01       	movw	r30, r22
     aa0:	82 81       	ldd	r24, Z+2	; 0x02
     aa2:	88 23       	and	r24, r24
     aa4:	19 f0       	breq	.+6      	; 0xaac <handleMenuSelection+0xf6>
     aa6:	81 30       	cpi	r24, 0x01	; 1
     aa8:	79 f0       	breq	.+30     	; 0xac8 <handleMenuSelection+0x112>
     aaa:	14 c0       	rjmp	.+40     	; 0xad4 <handleMenuSelection+0x11e>
			case 0:
			oled_write_line_to_SRAM(0, "Item 1 valgt");
     aac:	6f e9       	ldi	r22, 0x9F	; 159
     aae:	71 e0       	ldi	r23, 0x01	; 1
     ab0:	80 e0       	ldi	r24, 0x00	; 0
     ab2:	0e 94 7c 07 	call	0xef8	; 0xef8 <oled_write_line_to_SRAM>
			currentMenuState = MAIN_MENU;
     ab6:	10 92 bc 01 	sts	0x01BC, r1	; 0x8001bc <currentMenuState>
			current_menu = &mainMenu;
     aba:	87 ec       	ldi	r24, 0xC7	; 199
     abc:	91 e0       	ldi	r25, 0x01	; 1
     abe:	90 93 bb 01 	sts	0x01BB, r25	; 0x8001bb <__data_end+0x1>
     ac2:	80 93 ba 01 	sts	0x01BA, r24	; 0x8001ba <__data_end>
			break;
     ac6:	08 95       	ret
			case 1:
			oled_write_line_to_SRAM(0, "Item 2 valgt");
     ac8:	6c ea       	ldi	r22, 0xAC	; 172
     aca:	71 e0       	ldi	r23, 0x01	; 1
     acc:	80 e0       	ldi	r24, 0x00	; 0
     ace:	0e 94 7c 07 	call	0xef8	; 0xef8 <oled_write_line_to_SRAM>
			break;
     ad2:	08 95       	ret
			default:
			oled_write_line_to_SRAM(0, "Ugyldig valg");
     ad4:	6e e4       	ldi	r22, 0x4E	; 78
     ad6:	71 e0       	ldi	r23, 0x01	; 1
     ad8:	80 e0       	ldi	r24, 0x00	; 0
     ada:	0e 94 7c 07 	call	0xef8	; 0xef8 <oled_write_line_to_SRAM>
     ade:	08 95       	ret

00000ae0 <MultiBoard_Init>:
 * Created: 14.09.2024 11:00:59
 *  Author: ravneb
 */ 
#include "MultiBoard.h"

void MultiBoard_Init(MultiBoard* board) {
     ae0:	cf 93       	push	r28
     ae2:	df 93       	push	r29
     ae4:	ec 01       	movw	r28, r24
	// Set pinner for knapper som input
	clearBit(DDRB, LEFT_BUTTON_PIN);  // Set Left button pin as input
     ae6:	bc 98       	cbi	0x17, 4	; 23
	clearBit(DDRB, RIGHT_BUTTON_PIN); // Set Right button pin as input
     ae8:	bb 98       	cbi	0x17, 3	; 23
	clearBit(DDRB, JOY_BUTTON_PIN);   // Set Joystick button pin as input
     aea:	ba 98       	cbi	0x17, 2	; 23
	clearBit(DDRB, BUSY_PIN);         // Set BUSY pin as input
     aec:	b9 98       	cbi	0x17, 1	; 23
	
	// Aktiver pullup
	setBit(PORTB, JOY_BUTTON_PIN);
     aee:	c2 9a       	sbi	0x18, 2	; 24
	

	// Kalibrer joysticken (finn origo)
	Universal_write(ADC_START, 0x80); // For Chip Enable til ADC, (data her er irrelevant)
     af0:	60 e8       	ldi	r22, 0x80	; 128
     af2:	80 e0       	ldi	r24, 0x00	; 0
     af4:	94 e1       	ldi	r25, 0x14	; 20
     af6:	0e 94 f3 09 	call	0x13e6	; 0x13e6 <Universal_write>
	loopUntilBitIsClear(PINB, BUSY_PIN);    // Vent til BUSY gï¿½r lav
     afa:	b1 99       	sbic	0x16, 1	; 22
     afc:	fe cf       	rjmp	.-4      	; 0xafa <MultiBoard_Init+0x1a>
	board->JoyYOrigo = Universal_read(ADC_START); //CH0
     afe:	80 e0       	ldi	r24, 0x00	; 0
     b00:	94 e1       	ldi	r25, 0x14	; 20
     b02:	0e 94 03 0a 	call	0x1406	; 0x1406 <Universal_read>
     b06:	88 87       	std	Y+8, r24	; 0x08
	board->JoyXOrigo = Universal_read(ADC_START); //CH1
     b08:	80 e0       	ldi	r24, 0x00	; 0
     b0a:	94 e1       	ldi	r25, 0x14	; 20
     b0c:	0e 94 03 0a 	call	0x1406	; 0x1406 <Universal_read>
     b10:	8f 83       	std	Y+7, r24	; 0x07
	
	// Initialiser alle andre verdier
	board->LSpos = 0;
     b12:	1a 82       	std	Y+2, r1	; 0x02
	board->RSpos = 0;
     b14:	1b 82       	std	Y+3, r1	; 0x03
	board->LBtn = 0;
     b16:	1c 82       	std	Y+4, r1	; 0x04
	board->RBtn = 0;
     b18:	1d 82       	std	Y+5, r1	; 0x05
	board->JoyXpos = 0;
     b1a:	19 82       	std	Y+1, r1	; 0x01
	board->JoyYpos = 0;
     b1c:	18 82       	st	Y, r1
	board->JoyXposCal = 0;
     b1e:	1a 86       	std	Y+10, r1	; 0x0a
     b20:	19 86       	std	Y+9, r1	; 0x09
	board->JoyYposCal = 0;
     b22:	1c 86       	std	Y+12, r1	; 0x0c
     b24:	1b 86       	std	Y+11, r1	; 0x0b
	board->JoyAngle = 0;
     b26:	1e 86       	std	Y+14, r1	; 0x0e
     b28:	1d 86       	std	Y+13, r1	; 0x0d
	board->JoyBtn = 0;  // Endra fra en, vi bruker fortsatt 0 for av basert pÃ¥ logikk i MB_Update()
     b2a:	1e 82       	std	Y+6, r1	; 0x06
}
     b2c:	df 91       	pop	r29
     b2e:	cf 91       	pop	r28
     b30:	08 95       	ret

00000b32 <MultiBoard_UpdateJoystickAngle>:
	///IKKJE TESTA
	MultiBoard_UpdateJoystickAngle(board);
}

/// IKKJE TESTA 
void MultiBoard_UpdateJoystickAngle(MultiBoard* board) {
     b32:	fc 01       	movw	r30, r24
	int16_t x = board->JoyXposCal;
     b34:	61 85       	ldd	r22, Z+9	; 0x09
     b36:	72 85       	ldd	r23, Z+10	; 0x0a
	int16_t y = board->JoyYposCal;
     b38:	43 85       	ldd	r20, Z+11	; 0x0b
     b3a:	54 85       	ldd	r21, Z+12	; 0x0c

	// Unngï¿½ divisjon med 0 (nï¿½r senterpunkt) + hysterese
	if (!(abs(x) > JOY_ANGLE_HYSTERESIS || abs(y) >  JOY_ANGLE_HYSTERESIS)) {
     b3c:	cb 01       	movw	r24, r22
     b3e:	05 96       	adiw	r24, 0x05	; 5
     b40:	0b 97       	sbiw	r24, 0x0b	; 11
     b42:	38 f4       	brcc	.+14     	; 0xb52 <MultiBoard_UpdateJoystickAngle+0x20>
     b44:	ca 01       	movw	r24, r20
     b46:	05 96       	adiw	r24, 0x05	; 5
     b48:	0b 97       	sbiw	r24, 0x0b	; 11
     b4a:	18 f4       	brcc	.+6      	; 0xb52 <MultiBoard_UpdateJoystickAngle+0x20>
		board->JoyAngle = 0;  // Midtpunkt, sett vinkelen til 0
     b4c:	16 86       	std	Z+14, r1	; 0x0e
     b4e:	15 86       	std	Z+13, r1	; 0x0d
     b50:	08 95       	ret
		} else {
		// Bestem kvadrant basert pï¿½ verdiane til x og y
		switch ((x >= 0) << 1 | (y >= 0)) {
     b52:	87 2f       	mov	r24, r23
     b54:	80 95       	com	r24
     b56:	88 1f       	adc	r24, r24
     b58:	88 27       	eor	r24, r24
     b5a:	88 1f       	adc	r24, r24
     b5c:	90 e0       	ldi	r25, 0x00	; 0
     b5e:	88 0f       	add	r24, r24
     b60:	99 1f       	adc	r25, r25
     b62:	25 2f       	mov	r18, r21
     b64:	20 95       	com	r18
     b66:	22 1f       	adc	r18, r18
     b68:	22 27       	eor	r18, r18
     b6a:	22 1f       	adc	r18, r18
     b6c:	82 2b       	or	r24, r18
     b6e:	81 30       	cpi	r24, 0x01	; 1
     b70:	91 05       	cpc	r25, r1
     b72:	b9 f0       	breq	.+46     	; 0xba2 <MultiBoard_UpdateJoystickAngle+0x70>
     b74:	1c f4       	brge	.+6      	; 0xb7c <MultiBoard_UpdateJoystickAngle+0x4a>
     b76:	89 2b       	or	r24, r25
     b78:	29 f1       	breq	.+74     	; 0xbc4 <MultiBoard_UpdateJoystickAngle+0x92>
     b7a:	45 c0       	rjmp	.+138    	; 0xc06 <MultiBoard_UpdateJoystickAngle+0xd4>
     b7c:	82 30       	cpi	r24, 0x02	; 2
     b7e:	91 05       	cpc	r25, r1
     b80:	99 f1       	breq	.+102    	; 0xbe8 <MultiBoard_UpdateJoystickAngle+0xb6>
     b82:	03 97       	sbiw	r24, 0x03	; 3
     b84:	09 f0       	breq	.+2      	; 0xb88 <MultiBoard_UpdateJoystickAngle+0x56>
     b86:	3f c0       	rjmp	.+126    	; 0xc06 <MultiBoard_UpdateJoystickAngle+0xd4>
			case 0b11:  // Fï¿½rste kvadrant (x >= 0, y >= 0)
			board->JoyAngle = (y * 90) / (x + y);
     b88:	2a e5       	ldi	r18, 0x5A	; 90
     b8a:	24 9f       	mul	r18, r20
     b8c:	c0 01       	movw	r24, r0
     b8e:	25 9f       	mul	r18, r21
     b90:	90 0d       	add	r25, r0
     b92:	11 24       	eor	r1, r1
     b94:	64 0f       	add	r22, r20
     b96:	75 1f       	adc	r23, r21
     b98:	0e 94 13 0a 	call	0x1426	; 0x1426 <__divmodhi4>
     b9c:	76 87       	std	Z+14, r23	; 0x0e
     b9e:	65 87       	std	Z+13, r22	; 0x0d
			break;
     ba0:	08 95       	ret
			case 0b01:  // Andre kvadrant (x < 0, y >= 0)
			board->JoyAngle = 90 + ((-x * 90) / (-x + y));
     ba2:	26 ea       	ldi	r18, 0xA6	; 166
     ba4:	26 03       	mulsu	r18, r22
     ba6:	c0 01       	movw	r24, r0
     ba8:	27 9f       	mul	r18, r23
     baa:	90 0d       	add	r25, r0
     bac:	11 24       	eor	r1, r1
     bae:	9a 01       	movw	r18, r20
     bb0:	26 1b       	sub	r18, r22
     bb2:	37 0b       	sbc	r19, r23
     bb4:	b9 01       	movw	r22, r18
     bb6:	0e 94 13 0a 	call	0x1426	; 0x1426 <__divmodhi4>
     bba:	66 5a       	subi	r22, 0xA6	; 166
     bbc:	7f 4f       	sbci	r23, 0xFF	; 255
     bbe:	76 87       	std	Z+14, r23	; 0x0e
     bc0:	65 87       	std	Z+13, r22	; 0x0d
			break;
     bc2:	08 95       	ret
			case 0b00:  // Tredje kvadrant (x < 0, y < 0)
			board->JoyAngle = 180 + ((-y * 90) / (-x - y));
     bc4:	26 ea       	ldi	r18, 0xA6	; 166
     bc6:	24 03       	mulsu	r18, r20
     bc8:	c0 01       	movw	r24, r0
     bca:	25 9f       	mul	r18, r21
     bcc:	90 0d       	add	r25, r0
     bce:	11 24       	eor	r1, r1
     bd0:	71 95       	neg	r23
     bd2:	61 95       	neg	r22
     bd4:	71 09       	sbc	r23, r1
     bd6:	64 1b       	sub	r22, r20
     bd8:	75 0b       	sbc	r23, r21
     bda:	0e 94 13 0a 	call	0x1426	; 0x1426 <__divmodhi4>
     bde:	6c 54       	subi	r22, 0x4C	; 76
     be0:	7f 4f       	sbci	r23, 0xFF	; 255
     be2:	76 87       	std	Z+14, r23	; 0x0e
     be4:	65 87       	std	Z+13, r22	; 0x0d
			break;
     be6:	08 95       	ret
			case 0b10:  // Fjerde kvadrant (x >= 0, y < 0)
			board->JoyAngle = 270 + ((x * 90) / (x - y));
     be8:	2a e5       	ldi	r18, 0x5A	; 90
     bea:	26 9f       	mul	r18, r22
     bec:	c0 01       	movw	r24, r0
     bee:	27 9f       	mul	r18, r23
     bf0:	90 0d       	add	r25, r0
     bf2:	11 24       	eor	r1, r1
     bf4:	64 1b       	sub	r22, r20
     bf6:	75 0b       	sbc	r23, r21
     bf8:	0e 94 13 0a 	call	0x1426	; 0x1426 <__divmodhi4>
     bfc:	62 5f       	subi	r22, 0xF2	; 242
     bfe:	7e 4f       	sbci	r23, 0xFE	; 254
     c00:	76 87       	std	Z+14, r23	; 0x0e
     c02:	65 87       	std	Z+13, r22	; 0x0d
			break;
     c04:	08 95       	ret
			default:
			board->JoyAngle = 0;  // Feiltilfelle, skal ikkje skje
     c06:	16 86       	std	Z+14, r1	; 0x0e
     c08:	15 86       	std	Z+13, r1	; 0x0d
     c0a:	08 95       	ret

00000c0c <MultiBoard_Update>:
	board->JoyAngle = 0;
	board->JoyBtn = 0;  // Endra fra en, vi bruker fortsatt 0 for av basert pÃ¥ logikk i MB_Update()
}


void MultiBoard_Update(MultiBoard* board) {
     c0c:	cf 93       	push	r28
     c0e:	df 93       	push	r29
     c10:	ec 01       	movw	r28, r24
	// Velg kanal for venstre skyvebryter (LSpos)
	Universal_write(ADC_START, 0x00);
     c12:	60 e0       	ldi	r22, 0x00	; 0
     c14:	80 e0       	ldi	r24, 0x00	; 0
     c16:	94 e1       	ldi	r25, 0x14	; 20
     c18:	0e 94 f3 09 	call	0x13e6	; 0x13e6 <Universal_write>
	loopUntilBitIsClear(PINB, BUSY_PIN);		// Vent til BUSY gï¿½r lav - klar for ï¿½ sende pï¿½ ny
     c1c:	b1 99       	sbic	0x16, 1	; 22
     c1e:	fe cf       	rjmp	.-4      	; 0xc1c <MultiBoard_Update+0x10>
	board->JoyYpos = Universal_read(ADC_START); //  - CH0 fï¿½rste RD low gir channel 0
     c20:	80 e0       	ldi	r24, 0x00	; 0
     c22:	94 e1       	ldi	r25, 0x14	; 20
     c24:	0e 94 03 0a 	call	0x1406	; 0x1406 <Universal_read>
     c28:	88 83       	st	Y, r24
	board->JoyXpos = Universal_read(ADC_START); //	- CH1 andre RD low gir channel 1
     c2a:	80 e0       	ldi	r24, 0x00	; 0
     c2c:	94 e1       	ldi	r25, 0x14	; 20
     c2e:	0e 94 03 0a 	call	0x1406	; 0x1406 <Universal_read>
     c32:	89 83       	std	Y+1, r24	; 0x01
	board->RSpos = Universal_read(ADC_START);	//	- CH2
     c34:	80 e0       	ldi	r24, 0x00	; 0
     c36:	94 e1       	ldi	r25, 0x14	; 20
     c38:	0e 94 03 0a 	call	0x1406	; 0x1406 <Universal_read>
     c3c:	8b 83       	std	Y+3, r24	; 0x03
	board->LSpos = Universal_read(ADC_START);	//	- CH3
     c3e:	80 e0       	ldi	r24, 0x00	; 0
     c40:	94 e1       	ldi	r25, 0x14	; 20
     c42:	0e 94 03 0a 	call	0x1406	; 0x1406 <Universal_read>
     c46:	8a 83       	std	Y+2, r24	; 0x02
	// Les knappestatus
	board->LBtn = 0<testBit(PINB, LEFT_BUTTON_PIN);
     c48:	81 e0       	ldi	r24, 0x01	; 1
     c4a:	b4 9b       	sbis	0x16, 4	; 22
     c4c:	80 e0       	ldi	r24, 0x00	; 0
     c4e:	8c 83       	std	Y+4, r24	; 0x04
	board->RBtn = 0<testBit(PINB, RIGHT_BUTTON_PIN);
     c50:	81 e0       	ldi	r24, 0x01	; 1
     c52:	b3 9b       	sbis	0x16, 3	; 22
     c54:	80 e0       	ldi	r24, 0x00	; 0
     c56:	8d 83       	std	Y+5, r24	; 0x05
	board->JoyBtn = !(0<testBit(PINB, JOY_BUTTON_PIN));
     c58:	81 e0       	ldi	r24, 0x01	; 1
     c5a:	b2 99       	sbic	0x16, 2	; 22
     c5c:	80 e0       	ldi	r24, 0x00	; 0
     c5e:	8e 83       	std	Y+6, r24	; 0x06
	// Opretter ein int med pluss og minus slik at vi kan finne riktig vinkel med _UpdateJoystickAngel
	board->JoyYposCal = (int16_t)(board->JoyYpos) - (int16_t)(board->JoyYOrigo);
     c60:	88 81       	ld	r24, Y
     c62:	90 e0       	ldi	r25, 0x00	; 0
     c64:	28 85       	ldd	r18, Y+8	; 0x08
     c66:	82 1b       	sub	r24, r18
     c68:	91 09       	sbc	r25, r1
     c6a:	9c 87       	std	Y+12, r25	; 0x0c
     c6c:	8b 87       	std	Y+11, r24	; 0x0b
	board->JoyXposCal = (int16_t)(board->JoyXpos) - (int16_t)(board->JoyXOrigo);
     c6e:	89 81       	ldd	r24, Y+1	; 0x01
     c70:	90 e0       	ldi	r25, 0x00	; 0
     c72:	2f 81       	ldd	r18, Y+7	; 0x07
     c74:	82 1b       	sub	r24, r18
     c76:	91 09       	sbc	r25, r1
     c78:	9a 87       	std	Y+10, r25	; 0x0a
     c7a:	89 87       	std	Y+9, r24	; 0x09
	///IKKJE TESTA
	MultiBoard_UpdateJoystickAngle(board);
     c7c:	ce 01       	movw	r24, r28
     c7e:	0e 94 99 05 	call	0xb32	; 0xb32 <MultiBoard_UpdateJoystickAngle>
}
     c82:	df 91       	pop	r29
     c84:	cf 91       	pop	r28
     c86:	08 95       	ret

00000c88 <oled_write_command>:
	for (uint16_t i = 0; i < 1024; i++) {
		// Les byte direkte frå Flash og skriv til SRAM
		uint8_t byte_from_flash = pgm_read_byte(&screen_1024[i]);
		SRAM_write(i, byte_from_flash);
	}
}
     c88:	68 2f       	mov	r22, r24
     c8a:	80 e0       	ldi	r24, 0x00	; 0
     c8c:	90 e0       	ldi	r25, 0x00	; 0
     c8e:	0e 94 f3 09 	call	0x13e6	; 0x13e6 <Universal_write>
     c92:	08 95       	ret

00000c94 <oled_write_data>:
     c94:	ef 92       	push	r14
     c96:	ff 92       	push	r15
     c98:	0f 93       	push	r16
     c9a:	1f 93       	push	r17
     c9c:	cf 93       	push	r28
     c9e:	df 93       	push	r29
     ca0:	61 15       	cp	r22, r1
     ca2:	71 05       	cpc	r23, r1
     ca4:	81 f0       	breq	.+32     	; 0xcc6 <oled_write_data+0x32>
     ca6:	7c 01       	movw	r14, r24
     ca8:	8c 01       	movw	r16, r24
     caa:	e6 0e       	add	r14, r22
     cac:	f7 1e       	adc	r15, r23
     cae:	c0 e0       	ldi	r28, 0x00	; 0
     cb0:	d2 e0       	ldi	r29, 0x02	; 2
     cb2:	f8 01       	movw	r30, r16
     cb4:	61 91       	ld	r22, Z+
     cb6:	8f 01       	movw	r16, r30
     cb8:	ce 01       	movw	r24, r28
     cba:	0e 94 f3 09 	call	0x13e6	; 0x13e6 <Universal_write>
     cbe:	21 96       	adiw	r28, 0x01	; 1
     cc0:	0e 15       	cp	r16, r14
     cc2:	1f 05       	cpc	r17, r15
     cc4:	b1 f7       	brne	.-20     	; 0xcb2 <oled_write_data+0x1e>
     cc6:	df 91       	pop	r29
     cc8:	cf 91       	pop	r28
     cca:	1f 91       	pop	r17
     ccc:	0f 91       	pop	r16
     cce:	ff 90       	pop	r15
     cd0:	ef 90       	pop	r14
     cd2:	08 95       	ret

00000cd4 <oled_set_page>:
     cd4:	87 70       	andi	r24, 0x07	; 7
     cd6:	80 6b       	ori	r24, 0xB0	; 176
     cd8:	0e 94 44 06 	call	0xc88	; 0xc88 <oled_write_command>
     cdc:	08 95       	ret

00000cde <oled_set_column>:
     cde:	cf 93       	push	r28
     ce0:	c8 2f       	mov	r28, r24
     ce2:	82 95       	swap	r24
     ce4:	8f 70       	andi	r24, 0x0F	; 15
     ce6:	80 61       	ori	r24, 0x10	; 16
     ce8:	0e 94 44 06 	call	0xc88	; 0xc88 <oled_write_command>
     cec:	8c 2f       	mov	r24, r28
     cee:	8f 70       	andi	r24, 0x0F	; 15
     cf0:	0e 94 44 06 	call	0xc88	; 0xc88 <oled_write_command>
     cf4:	cf 91       	pop	r28
     cf6:	08 95       	ret

00000cf8 <oled_init>:
     cf8:	8e ea       	ldi	r24, 0xAE	; 174
     cfa:	0e 94 44 06 	call	0xc88	; 0xc88 <oled_write_command>
     cfe:	81 ea       	ldi	r24, 0xA1	; 161
     d00:	0e 94 44 06 	call	0xc88	; 0xc88 <oled_write_command>
     d04:	8a ed       	ldi	r24, 0xDA	; 218
     d06:	0e 94 44 06 	call	0xc88	; 0xc88 <oled_write_command>
     d0a:	82 e1       	ldi	r24, 0x12	; 18
     d0c:	0e 94 44 06 	call	0xc88	; 0xc88 <oled_write_command>
     d10:	88 ec       	ldi	r24, 0xC8	; 200
     d12:	0e 94 44 06 	call	0xc88	; 0xc88 <oled_write_command>
     d16:	88 ea       	ldi	r24, 0xA8	; 168
     d18:	0e 94 44 06 	call	0xc88	; 0xc88 <oled_write_command>
     d1c:	8f e3       	ldi	r24, 0x3F	; 63
     d1e:	0e 94 44 06 	call	0xc88	; 0xc88 <oled_write_command>
     d22:	85 ed       	ldi	r24, 0xD5	; 213
     d24:	0e 94 44 06 	call	0xc88	; 0xc88 <oled_write_command>
     d28:	80 e8       	ldi	r24, 0x80	; 128
     d2a:	0e 94 44 06 	call	0xc88	; 0xc88 <oled_write_command>
     d2e:	81 e8       	ldi	r24, 0x81	; 129
     d30:	0e 94 44 06 	call	0xc88	; 0xc88 <oled_write_command>
     d34:	80 e5       	ldi	r24, 0x50	; 80
     d36:	0e 94 44 06 	call	0xc88	; 0xc88 <oled_write_command>
     d3a:	89 ed       	ldi	r24, 0xD9	; 217
     d3c:	0e 94 44 06 	call	0xc88	; 0xc88 <oled_write_command>
     d40:	81 e2       	ldi	r24, 0x21	; 33
     d42:	0e 94 44 06 	call	0xc88	; 0xc88 <oled_write_command>
     d46:	80 e2       	ldi	r24, 0x20	; 32
     d48:	0e 94 44 06 	call	0xc88	; 0xc88 <oled_write_command>
     d4c:	82 e0       	ldi	r24, 0x02	; 2
     d4e:	0e 94 44 06 	call	0xc88	; 0xc88 <oled_write_command>
     d52:	8b ed       	ldi	r24, 0xDB	; 219
     d54:	0e 94 44 06 	call	0xc88	; 0xc88 <oled_write_command>
     d58:	80 e3       	ldi	r24, 0x30	; 48
     d5a:	0e 94 44 06 	call	0xc88	; 0xc88 <oled_write_command>
     d5e:	8d ea       	ldi	r24, 0xAD	; 173
     d60:	0e 94 44 06 	call	0xc88	; 0xc88 <oled_write_command>
     d64:	80 e0       	ldi	r24, 0x00	; 0
     d66:	0e 94 44 06 	call	0xc88	; 0xc88 <oled_write_command>
     d6a:	84 ea       	ldi	r24, 0xA4	; 164
     d6c:	0e 94 44 06 	call	0xc88	; 0xc88 <oled_write_command>
     d70:	86 ea       	ldi	r24, 0xA6	; 166
     d72:	0e 94 44 06 	call	0xc88	; 0xc88 <oled_write_command>
     d76:	8f ea       	ldi	r24, 0xAF	; 175
     d78:	0e 94 44 06 	call	0xc88	; 0xc88 <oled_write_command>
     d7c:	08 95       	ret

00000d7e <oled_data_from_SRAM>:
     d7e:	8f 92       	push	r8
     d80:	9f 92       	push	r9
     d82:	bf 92       	push	r11
     d84:	cf 92       	push	r12
     d86:	df 92       	push	r13
     d88:	ef 92       	push	r14
     d8a:	ff 92       	push	r15
     d8c:	0f 93       	push	r16
     d8e:	1f 93       	push	r17
     d90:	cf 93       	push	r28
     d92:	df 93       	push	r29
     d94:	cd b7       	in	r28, 0x3d	; 61
     d96:	de b7       	in	r29, 0x3e	; 62
     d98:	c0 58       	subi	r28, 0x80	; 128
     d9a:	d1 09       	sbc	r29, r1
     d9c:	0f b6       	in	r0, 0x3f	; 63
     d9e:	f8 94       	cli
     da0:	de bf       	out	0x3e, r29	; 62
     da2:	0f be       	out	0x3f, r0	; 63
     da4:	cd bf       	out	0x3d, r28	; 61
     da6:	ce 01       	movw	r24, r28
     da8:	01 96       	adiw	r24, 0x01	; 1
     daa:	4c 01       	movw	r8, r24
     dac:	ee 24       	eor	r14, r14
     dae:	ff 24       	eor	r15, r15
     db0:	e8 1a       	sub	r14, r24
     db2:	f9 0a       	sbc	r15, r25
     db4:	b1 2c       	mov	r11, r1
     db6:	6e 01       	movw	r12, r28
     db8:	91 e8       	ldi	r25, 0x81	; 129
     dba:	c9 0e       	add	r12, r25
     dbc:	d1 1c       	adc	r13, r1
     dbe:	8b 2d       	mov	r24, r11
     dc0:	0e 94 6a 06 	call	0xcd4	; 0xcd4 <oled_set_page>
     dc4:	80 e0       	ldi	r24, 0x00	; 0
     dc6:	0e 94 6f 06 	call	0xcde	; 0xcde <oled_set_column>
     dca:	84 01       	movw	r16, r8
     dcc:	c8 01       	movw	r24, r16
     dce:	8e 0d       	add	r24, r14
     dd0:	9f 1d       	adc	r25, r15
     dd2:	0e 94 e3 09 	call	0x13c6	; 0x13c6 <SRAM_read>
     dd6:	f8 01       	movw	r30, r16
     dd8:	81 93       	st	Z+, r24
     dda:	8f 01       	movw	r16, r30
     ddc:	ec 15       	cp	r30, r12
     dde:	fd 05       	cpc	r31, r13
     de0:	a9 f7       	brne	.-22     	; 0xdcc <oled_data_from_SRAM+0x4e>
     de2:	60 e8       	ldi	r22, 0x80	; 128
     de4:	70 e0       	ldi	r23, 0x00	; 0
     de6:	ce 01       	movw	r24, r28
     de8:	01 96       	adiw	r24, 0x01	; 1
     dea:	0e 94 4a 06 	call	0xc94	; 0xc94 <oled_write_data>
     dee:	b3 94       	inc	r11
     df0:	f0 e8       	ldi	r31, 0x80	; 128
     df2:	ef 0e       	add	r14, r31
     df4:	f1 1c       	adc	r15, r1
     df6:	88 e0       	ldi	r24, 0x08	; 8
     df8:	b8 12       	cpse	r11, r24
     dfa:	e1 cf       	rjmp	.-62     	; 0xdbe <oled_data_from_SRAM+0x40>
     dfc:	c0 58       	subi	r28, 0x80	; 128
     dfe:	df 4f       	sbci	r29, 0xFF	; 255
     e00:	0f b6       	in	r0, 0x3f	; 63
     e02:	f8 94       	cli
     e04:	de bf       	out	0x3e, r29	; 62
     e06:	0f be       	out	0x3f, r0	; 63
     e08:	cd bf       	out	0x3d, r28	; 61
     e0a:	df 91       	pop	r29
     e0c:	cf 91       	pop	r28
     e0e:	1f 91       	pop	r17
     e10:	0f 91       	pop	r16
     e12:	ff 90       	pop	r15
     e14:	ef 90       	pop	r14
     e16:	df 90       	pop	r13
     e18:	cf 90       	pop	r12
     e1a:	bf 90       	pop	r11
     e1c:	9f 90       	pop	r9
     e1e:	8f 90       	pop	r8
     e20:	08 95       	ret

00000e22 <oled_write_screen_to_SRAM>:
     e22:	6f 92       	push	r6
     e24:	7f 92       	push	r7
     e26:	8f 92       	push	r8
     e28:	9f 92       	push	r9
     e2a:	af 92       	push	r10
     e2c:	bf 92       	push	r11
     e2e:	cf 92       	push	r12
     e30:	df 92       	push	r13
     e32:	ef 92       	push	r14
     e34:	ff 92       	push	r15
     e36:	0f 93       	push	r16
     e38:	1f 93       	push	r17
     e3a:	cf 93       	push	r28
     e3c:	df 93       	push	r29
     e3e:	4c 01       	movw	r8, r24
     e40:	e1 2c       	mov	r14, r1
     e42:	f1 2c       	mov	r15, r1
     e44:	0f 2e       	mov	r0, r31
     e46:	f0 e7       	ldi	r31, 0x70	; 112
     e48:	6f 2e       	mov	r6, r31
     e4a:	f1 e0       	ldi	r31, 0x01	; 1
     e4c:	7f 2e       	mov	r7, r31
     e4e:	f0 2d       	mov	r31, r0
     e50:	0f 2e       	mov	r0, r31
     e52:	f8 e7       	ldi	r31, 0x78	; 120
     e54:	af 2e       	mov	r10, r31
     e56:	f1 e0       	ldi	r31, 0x01	; 1
     e58:	bf 2e       	mov	r11, r31
     e5a:	f0 2d       	mov	r31, r0
     e5c:	f4 01       	movw	r30, r8
     e5e:	04 91       	lpm	r16, Z
     e60:	80 ee       	ldi	r24, 0xE0	; 224
     e62:	80 0f       	add	r24, r16
     e64:	80 36       	cpi	r24, 0x60	; 96
     e66:	f0 f4       	brcc	.+60     	; 0xea4 <oled_write_screen_to_SRAM+0x82>
     e68:	10 e0       	ldi	r17, 0x00	; 0
     e6a:	00 52       	subi	r16, 0x20	; 32
     e6c:	11 09       	sbc	r17, r1
     e6e:	00 0f       	add	r16, r16
     e70:	11 1f       	adc	r17, r17
     e72:	00 0f       	add	r16, r16
     e74:	11 1f       	adc	r17, r17
     e76:	00 0f       	add	r16, r16
     e78:	11 1f       	adc	r17, r17
     e7a:	67 01       	movw	r12, r14
     e7c:	f8 e0       	ldi	r31, 0x08	; 8
     e7e:	cf 0e       	add	r12, r31
     e80:	d1 1c       	adc	r13, r1
     e82:	e7 01       	movw	r28, r14
     e84:	0e 19       	sub	r16, r14
     e86:	1f 09       	sbc	r17, r15
     e88:	f8 01       	movw	r30, r16
     e8a:	ec 0f       	add	r30, r28
     e8c:	fd 1f       	adc	r31, r29
     e8e:	e0 59       	subi	r30, 0x90	; 144
     e90:	fe 4f       	sbci	r31, 0xFE	; 254
     e92:	64 91       	lpm	r22, Z
     e94:	ce 01       	movw	r24, r28
     e96:	0e 94 d3 09 	call	0x13a6	; 0x13a6 <SRAM_write>
     e9a:	21 96       	adiw	r28, 0x01	; 1
     e9c:	cc 16       	cp	r12, r28
     e9e:	dd 06       	cpc	r13, r29
     ea0:	99 f7       	brne	.-26     	; 0xe88 <oled_write_screen_to_SRAM+0x66>
     ea2:	10 c0       	rjmp	.+32     	; 0xec4 <oled_write_screen_to_SRAM+0xa2>
     ea4:	c0 e7       	ldi	r28, 0x70	; 112
     ea6:	d1 e0       	ldi	r29, 0x01	; 1
     ea8:	87 01       	movw	r16, r14
     eaa:	06 19       	sub	r16, r6
     eac:	17 09       	sbc	r17, r7
     eae:	fe 01       	movw	r30, r28
     eb0:	64 91       	lpm	r22, Z
     eb2:	c8 01       	movw	r24, r16
     eb4:	8c 0f       	add	r24, r28
     eb6:	9d 1f       	adc	r25, r29
     eb8:	0e 94 d3 09 	call	0x13a6	; 0x13a6 <SRAM_write>
     ebc:	21 96       	adiw	r28, 0x01	; 1
     ebe:	ca 15       	cp	r28, r10
     ec0:	db 05       	cpc	r29, r11
     ec2:	a9 f7       	brne	.-22     	; 0xeae <oled_write_screen_to_SRAM+0x8c>
     ec4:	ff ef       	ldi	r31, 0xFF	; 255
     ec6:	8f 1a       	sub	r8, r31
     ec8:	9f 0a       	sbc	r9, r31
     eca:	88 e0       	ldi	r24, 0x08	; 8
     ecc:	e8 0e       	add	r14, r24
     ece:	f1 1c       	adc	r15, r1
     ed0:	e1 14       	cp	r14, r1
     ed2:	e4 e0       	ldi	r30, 0x04	; 4
     ed4:	fe 06       	cpc	r15, r30
     ed6:	09 f0       	breq	.+2      	; 0xeda <oled_write_screen_to_SRAM+0xb8>
     ed8:	c1 cf       	rjmp	.-126    	; 0xe5c <oled_write_screen_to_SRAM+0x3a>
     eda:	df 91       	pop	r29
     edc:	cf 91       	pop	r28
     ede:	1f 91       	pop	r17
     ee0:	0f 91       	pop	r16
     ee2:	ff 90       	pop	r15
     ee4:	ef 90       	pop	r14
     ee6:	df 90       	pop	r13
     ee8:	cf 90       	pop	r12
     eea:	bf 90       	pop	r11
     eec:	af 90       	pop	r10
     eee:	9f 90       	pop	r9
     ef0:	8f 90       	pop	r8
     ef2:	7f 90       	pop	r7
     ef4:	6f 90       	pop	r6
     ef6:	08 95       	ret

00000ef8 <oled_write_line_to_SRAM>:


void oled_write_line_to_SRAM(uint8_t line, const char* data) {
     ef8:	8f 92       	push	r8
     efa:	9f 92       	push	r9
     efc:	bf 92       	push	r11
     efe:	cf 92       	push	r12
     f00:	df 92       	push	r13
     f02:	ef 92       	push	r14
     f04:	ff 92       	push	r15
     f06:	0f 93       	push	r16
     f08:	1f 93       	push	r17
     f0a:	cf 93       	push	r28
     f0c:	df 93       	push	r29
	if (line >= 8) {
     f0e:	88 30       	cpi	r24, 0x08	; 8
     f10:	08 f0       	brcs	.+2      	; 0xf14 <oled_write_line_to_SRAM+0x1c>
     f12:	5e c0       	rjmp	.+188    	; 0xfd0 <oled_write_line_to_SRAM+0xd8>
     f14:	fb 01       	movw	r30, r22
		return; 
	}
	uint8_t max_chars_per_line = 16;
	uint16_t sram_address = line * 128;  // Hver linje er 128 bytes, 16 karakterer à 8 pixels
     f16:	90 e8       	ldi	r25, 0x80	; 128
     f18:	89 9f       	mul	r24, r25
     f1a:	60 01       	movw	r12, r0
     f1c:	11 24       	eor	r1, r1
	uint8_t i = 0; // så den ikkje døyr når vi går ut av forloopen (brukast igjen)
	// Skriv karakterene til SRAM, men ikke mer enn 16
	for (; i < max_chars_per_line; i++) {
		if (data[i] == '\0') {
     f1e:	80 81       	ld	r24, Z
     f20:	88 23       	and	r24, r24
     f22:	09 f4       	brne	.+2      	; 0xf26 <oled_write_line_to_SRAM+0x2e>
     f24:	47 c0       	rjmp	.+142    	; 0xfb4 <oled_write_line_to_SRAM+0xbc>
     f26:	76 01       	movw	r14, r12
     f28:	8b 01       	movw	r16, r22
     f2a:	b1 2c       	mov	r11, r1
     f2c:	0a c0       	rjmp	.+20     	; 0xf42 <oled_write_line_to_SRAM+0x4a>
     f2e:	0f 5f       	subi	r16, 0xFF	; 255
     f30:	1f 4f       	sbci	r17, 0xFF	; 255
     f32:	a8 e0       	ldi	r26, 0x08	; 8
     f34:	ea 0e       	add	r14, r26
     f36:	f1 1c       	adc	r15, r1
     f38:	f8 01       	movw	r30, r16
     f3a:	80 81       	ld	r24, Z
     f3c:	88 23       	and	r24, r24
     f3e:	09 f4       	brne	.+2      	; 0xf42 <oled_write_line_to_SRAM+0x4a>
     f40:	3a c0       	rjmp	.+116    	; 0xfb6 <oled_write_line_to_SRAM+0xbe>
     f42:	c0 e0       	ldi	r28, 0x00	; 0
     f44:	d0 e0       	ldi	r29, 0x00	; 0
			break;  // Avslutt hvis vi når slutten av data
		}
		for (uint8_t j = 0; j < 8; j++) {
			SRAM_write(sram_address + (i * 8) + j, pgm_read_byte(&font8x8_basic[(data[i] - 32) * 8 + j]));
     f46:	d8 01       	movw	r26, r16
     f48:	ec 91       	ld	r30, X
     f4a:	f0 e0       	ldi	r31, 0x00	; 0
     f4c:	b0 97       	sbiw	r30, 0x20	; 32
     f4e:	ee 0f       	add	r30, r30
     f50:	ff 1f       	adc	r31, r31
     f52:	ee 0f       	add	r30, r30
     f54:	ff 1f       	adc	r31, r31
     f56:	ee 0f       	add	r30, r30
     f58:	ff 1f       	adc	r31, r31
     f5a:	ec 0f       	add	r30, r28
     f5c:	fd 1f       	adc	r31, r29
     f5e:	e0 59       	subi	r30, 0x90	; 144
     f60:	fe 4f       	sbci	r31, 0xFE	; 254
     f62:	64 91       	lpm	r22, Z
     f64:	c7 01       	movw	r24, r14
     f66:	8c 0f       	add	r24, r28
     f68:	9d 1f       	adc	r25, r29
     f6a:	0e 94 d3 09 	call	0x13a6	; 0x13a6 <SRAM_write>
     f6e:	21 96       	adiw	r28, 0x01	; 1
	// Skriv karakterene til SRAM, men ikke mer enn 16
	for (; i < max_chars_per_line; i++) {
		if (data[i] == '\0') {
			break;  // Avslutt hvis vi når slutten av data
		}
		for (uint8_t j = 0; j < 8; j++) {
     f70:	c8 30       	cpi	r28, 0x08	; 8
     f72:	d1 05       	cpc	r29, r1
     f74:	41 f7       	brne	.-48     	; 0xf46 <oled_write_line_to_SRAM+0x4e>
	}
	uint8_t max_chars_per_line = 16;
	uint16_t sram_address = line * 128;  // Hver linje er 128 bytes, 16 karakterer à 8 pixels
	uint8_t i = 0; // så den ikkje døyr når vi går ut av forloopen (brukast igjen)
	// Skriv karakterene til SRAM, men ikke mer enn 16
	for (; i < max_chars_per_line; i++) {
     f76:	b3 94       	inc	r11
     f78:	b0 e1       	ldi	r27, 0x10	; 16
     f7a:	bb 12       	cpse	r11, r27
     f7c:	d8 cf       	rjmp	.-80     	; 0xf2e <oled_write_line_to_SRAM+0x36>
     f7e:	28 c0       	rjmp	.+80     	; 0xfd0 <oled_write_line_to_SRAM+0xd8>
		}
	}
	// Fyll resten av linjen med tomrom (mellomrom) etter slutten av data
	for (; i < max_chars_per_line; i++) {
		for (uint8_t j = 0; j < 8; j++) {
			SRAM_write(sram_address + (i * 8) + j, pgm_read_byte(&font8x8_basic[(' ' - 32) * 8 + j]));
     f80:	fe 01       	movw	r30, r28
     f82:	64 91       	lpm	r22, Z
     f84:	c8 01       	movw	r24, r16
     f86:	8c 0f       	add	r24, r28
     f88:	9d 1f       	adc	r25, r29
     f8a:	0e 94 d3 09 	call	0x13a6	; 0x13a6 <SRAM_write>
     f8e:	21 96       	adiw	r28, 0x01	; 1
			SRAM_write(sram_address + (i * 8) + j, pgm_read_byte(&font8x8_basic[(data[i] - 32) * 8 + j]));
		}
	}
	// Fyll resten av linjen med tomrom (mellomrom) etter slutten av data
	for (; i < max_chars_per_line; i++) {
		for (uint8_t j = 0; j < 8; j++) {
     f90:	ce 15       	cp	r28, r14
     f92:	df 05       	cpc	r29, r15
     f94:	a9 f7       	brne	.-22     	; 0xf80 <oled_write_line_to_SRAM+0x88>
		for (uint8_t j = 0; j < 8; j++) {
			SRAM_write(sram_address + (i * 8) + j, pgm_read_byte(&font8x8_basic[(data[i] - 32) * 8 + j]));
		}
	}
	// Fyll resten av linjen med tomrom (mellomrom) etter slutten av data
	for (; i < max_chars_per_line; i++) {
     f96:	b3 94       	inc	r11
     f98:	ff e0       	ldi	r31, 0x0F	; 15
     f9a:	fb 15       	cp	r31, r11
     f9c:	c8 f0       	brcs	.+50     	; 0xfd0 <oled_write_line_to_SRAM+0xd8>
		for (uint8_t j = 0; j < 8; j++) {
			SRAM_write(sram_address + (i * 8) + j, pgm_read_byte(&font8x8_basic[(' ' - 32) * 8 + j]));
     f9e:	c0 e7       	ldi	r28, 0x70	; 112
     fa0:	d1 e0       	ldi	r29, 0x01	; 1
     fa2:	86 01       	movw	r16, r12
     fa4:	88 e0       	ldi	r24, 0x08	; 8
     fa6:	b8 9e       	mul	r11, r24
     fa8:	00 0d       	add	r16, r0
     faa:	11 1d       	adc	r17, r1
     fac:	11 24       	eor	r1, r1
     fae:	08 19       	sub	r16, r8
     fb0:	19 09       	sbc	r17, r9
     fb2:	e6 cf       	rjmp	.-52     	; 0xf80 <oled_write_line_to_SRAM+0x88>
	if (line >= 8) {
		return; 
	}
	uint8_t max_chars_per_line = 16;
	uint16_t sram_address = line * 128;  // Hver linje er 128 bytes, 16 karakterer à 8 pixels
	uint8_t i = 0; // så den ikkje døyr når vi går ut av forloopen (brukast igjen)
     fb4:	b1 2c       	mov	r11, r1
     fb6:	0f 2e       	mov	r0, r31
     fb8:	f0 e7       	ldi	r31, 0x70	; 112
     fba:	8f 2e       	mov	r8, r31
     fbc:	f1 e0       	ldi	r31, 0x01	; 1
     fbe:	9f 2e       	mov	r9, r31
     fc0:	f0 2d       	mov	r31, r0
     fc2:	0f 2e       	mov	r0, r31
     fc4:	f8 e7       	ldi	r31, 0x78	; 120
     fc6:	ef 2e       	mov	r14, r31
     fc8:	f1 e0       	ldi	r31, 0x01	; 1
     fca:	ff 2e       	mov	r15, r31
     fcc:	f0 2d       	mov	r31, r0
     fce:	e7 cf       	rjmp	.-50     	; 0xf9e <oled_write_line_to_SRAM+0xa6>
	for (; i < max_chars_per_line; i++) {
		for (uint8_t j = 0; j < 8; j++) {
			SRAM_write(sram_address + (i * 8) + j, pgm_read_byte(&font8x8_basic[(' ' - 32) * 8 + j]));
		}
	}
}
     fd0:	df 91       	pop	r29
     fd2:	cf 91       	pop	r28
     fd4:	1f 91       	pop	r17
     fd6:	0f 91       	pop	r16
     fd8:	ff 90       	pop	r15
     fda:	ef 90       	pop	r14
     fdc:	df 90       	pop	r13
     fde:	cf 90       	pop	r12
     fe0:	bf 90       	pop	r11
     fe2:	9f 90       	pop	r9
     fe4:	8f 90       	pop	r8
     fe6:	08 95       	ret

00000fe8 <oled_write_char_to_SRAM>:
//Nyttig for menyen trur eg, lar deg spesifisere nøyaktig kor på skjermen du vil overskrive
void oled_write_char_to_SRAM(uint8_t row, uint8_t col, char c) {
     fe8:	ef 92       	push	r14
     fea:	ff 92       	push	r15
     fec:	0f 93       	push	r16
     fee:	1f 93       	push	r17
     ff0:	cf 93       	push	r28
     ff2:	df 93       	push	r29
	if (row >= 8 || col >= 16) {
     ff4:	88 30       	cpi	r24, 0x08	; 8
     ff6:	70 f5       	brcc	.+92     	; 0x1054 <oled_write_char_to_SRAM+0x6c>
     ff8:	60 31       	cpi	r22, 0x10	; 16
     ffa:	60 f5       	brcc	.+88     	; 0x1054 <oled_write_char_to_SRAM+0x6c>
     ffc:	28 2f       	mov	r18, r24
		return; 
	}
	uint16_t sram_address = row * 128 + (col * 8); 
     ffe:	86 2f       	mov	r24, r22
    1000:	90 e0       	ldi	r25, 0x00	; 0
    1002:	30 e1       	ldi	r19, 0x10	; 16
    1004:	23 9f       	mul	r18, r19
    1006:	80 0d       	add	r24, r0
    1008:	91 1d       	adc	r25, r1
    100a:	11 24       	eor	r1, r1
    100c:	88 0f       	add	r24, r24
    100e:	99 1f       	adc	r25, r25
    1010:	88 0f       	add	r24, r24
    1012:	99 1f       	adc	r25, r25
    1014:	88 0f       	add	r24, r24
    1016:	99 1f       	adc	r25, r25
	for (uint8_t i = 0; i < 8; i++) {
		SRAM_write(sram_address + i, pgm_read_byte(&font8x8_basic[(c - 32) * 8 + i]));
    1018:	04 2f       	mov	r16, r20
    101a:	10 e0       	ldi	r17, 0x00	; 0
    101c:	00 52       	subi	r16, 0x20	; 32
    101e:	11 09       	sbc	r17, r1
    1020:	00 0f       	add	r16, r16
    1022:	11 1f       	adc	r17, r17
    1024:	00 0f       	add	r16, r16
    1026:	11 1f       	adc	r17, r17
    1028:	00 0f       	add	r16, r16
    102a:	11 1f       	adc	r17, r17
    102c:	7c 01       	movw	r14, r24
    102e:	28 e0       	ldi	r18, 0x08	; 8
    1030:	e2 0e       	add	r14, r18
    1032:	f1 1c       	adc	r15, r1
    1034:	ec 01       	movw	r28, r24
    1036:	08 1b       	sub	r16, r24
    1038:	19 0b       	sbc	r17, r25
    103a:	f8 01       	movw	r30, r16
    103c:	ec 0f       	add	r30, r28
    103e:	fd 1f       	adc	r31, r29
    1040:	e0 59       	subi	r30, 0x90	; 144
    1042:	fe 4f       	sbci	r31, 0xFE	; 254
    1044:	64 91       	lpm	r22, Z
    1046:	ce 01       	movw	r24, r28
    1048:	0e 94 d3 09 	call	0x13a6	; 0x13a6 <SRAM_write>
    104c:	21 96       	adiw	r28, 0x01	; 1
void oled_write_char_to_SRAM(uint8_t row, uint8_t col, char c) {
	if (row >= 8 || col >= 16) {
		return; 
	}
	uint16_t sram_address = row * 128 + (col * 8); 
	for (uint8_t i = 0; i < 8; i++) {
    104e:	ce 15       	cp	r28, r14
    1050:	df 05       	cpc	r29, r15
    1052:	99 f7       	brne	.-26     	; 0x103a <oled_write_char_to_SRAM+0x52>
		SRAM_write(sram_address + i, pgm_read_byte(&font8x8_basic[(c - 32) * 8 + i]));
	}
}
    1054:	df 91       	pop	r29
    1056:	cf 91       	pop	r28
    1058:	1f 91       	pop	r17
    105a:	0f 91       	pop	r16
    105c:	ff 90       	pop	r15
    105e:	ef 90       	pop	r14
    1060:	08 95       	ret

00001062 <oled_write_pixel_to_SRAM>:

void oled_write_pixel_to_SRAM(uint8_t row, uint8_t col, uint8_t value) {
    1062:	0f 93       	push	r16
    1064:	1f 93       	push	r17
    1066:	cf 93       	push	r28
    1068:	df 93       	push	r29
	if (row >= 64 || col >= 128) {
    106a:	80 34       	cpi	r24, 0x40	; 64
    106c:	48 f5       	brcc	.+82     	; 0x10c0 <oled_write_pixel_to_SRAM+0x5e>
    106e:	66 23       	and	r22, r22
    1070:	3c f1       	brlt	.+78     	; 0x10c0 <oled_write_pixel_to_SRAM+0x5e>
    1072:	04 2f       	mov	r16, r20
    1074:	18 2f       	mov	r17, r24
		return;
	}
	
	// Finn korrekt byte i SRAM for å justere pikslen
	uint16_t sram_address = (row / 8) * 128 + col;
    1076:	86 95       	lsr	r24
    1078:	86 95       	lsr	r24
    107a:	86 95       	lsr	r24
    107c:	c6 2f       	mov	r28, r22
    107e:	d0 e0       	ldi	r29, 0x00	; 0
    1080:	90 e8       	ldi	r25, 0x80	; 128
    1082:	89 9f       	mul	r24, r25
    1084:	c0 0d       	add	r28, r0
    1086:	d1 1d       	adc	r29, r1
    1088:	11 24       	eor	r1, r1
	uint8_t current_byte = SRAM_read(sram_address);
    108a:	ce 01       	movw	r24, r28
    108c:	0e 94 e3 09 	call	0x13c6	; 0x13c6 <SRAM_read>
	uint8_t bit_position = row % 8;
    1090:	17 70       	andi	r17, 0x07	; 7

	// Sett eller nullstill den ønskede biten
	if (value) {
    1092:	00 23       	and	r16, r16
    1094:	49 f0       	breq	.+18     	; 0x10a8 <oled_write_pixel_to_SRAM+0x46>
		current_byte |= (1 << bit_position);  // Sett bit til 1
    1096:	61 e0       	ldi	r22, 0x01	; 1
    1098:	70 e0       	ldi	r23, 0x00	; 0
    109a:	02 c0       	rjmp	.+4      	; 0x10a0 <oled_write_pixel_to_SRAM+0x3e>
    109c:	66 0f       	add	r22, r22
    109e:	77 1f       	adc	r23, r23
    10a0:	1a 95       	dec	r17
    10a2:	e2 f7       	brpl	.-8      	; 0x109c <oled_write_pixel_to_SRAM+0x3a>
    10a4:	68 2b       	or	r22, r24
    10a6:	09 c0       	rjmp	.+18     	; 0x10ba <oled_write_pixel_to_SRAM+0x58>
		} else {
		current_byte &= ~(1 << bit_position);  // Nullstill bit til 0
    10a8:	61 e0       	ldi	r22, 0x01	; 1
    10aa:	70 e0       	ldi	r23, 0x00	; 0
    10ac:	02 c0       	rjmp	.+4      	; 0x10b2 <oled_write_pixel_to_SRAM+0x50>
    10ae:	66 0f       	add	r22, r22
    10b0:	77 1f       	adc	r23, r23
    10b2:	1a 95       	dec	r17
    10b4:	e2 f7       	brpl	.-8      	; 0x10ae <oled_write_pixel_to_SRAM+0x4c>
    10b6:	60 95       	com	r22
    10b8:	68 23       	and	r22, r24
	}
	
	SRAM_write(sram_address, current_byte);
    10ba:	ce 01       	movw	r24, r28
    10bc:	0e 94 d3 09 	call	0x13a6	; 0x13a6 <SRAM_write>
}
    10c0:	df 91       	pop	r29
    10c2:	cf 91       	pop	r28
    10c4:	1f 91       	pop	r17
    10c6:	0f 91       	pop	r16
    10c8:	08 95       	ret

000010ca <oled_clear_screen>:

void oled_clear_screen(void) {
    10ca:	cf 93       	push	r28
    10cc:	df 93       	push	r29
	// Lag en tom buffer fylt med nuller eller mellomrom (0 er nok, fordi funksjonen oversetter til ' ')
	char empty_buffer[128] = {0};  // Heile skjermen, 128 tegn

	// Skriv den tomme bufferen til SRAM, som vil tømme skjermen
	oled_write_screen_to_SRAM(empty_buffer);*/
	for(int i = 0; i < 1024; i++){
    10ce:	c0 e0       	ldi	r28, 0x00	; 0
    10d0:	d0 e0       	ldi	r29, 0x00	; 0
		SRAM_write(i, 0);
    10d2:	60 e0       	ldi	r22, 0x00	; 0
    10d4:	ce 01       	movw	r24, r28
    10d6:	0e 94 d3 09 	call	0x13a6	; 0x13a6 <SRAM_write>
	// Lag en tom buffer fylt med nuller eller mellomrom (0 er nok, fordi funksjonen oversetter til ' ')
	char empty_buffer[128] = {0};  // Heile skjermen, 128 tegn

	// Skriv den tomme bufferen til SRAM, som vil tømme skjermen
	oled_write_screen_to_SRAM(empty_buffer);*/
	for(int i = 0; i < 1024; i++){
    10da:	21 96       	adiw	r28, 0x01	; 1
    10dc:	c1 15       	cp	r28, r1
    10de:	84 e0       	ldi	r24, 0x04	; 4
    10e0:	d8 07       	cpc	r29, r24
    10e2:	b9 f7       	brne	.-18     	; 0x10d2 <oled_clear_screen+0x8>
		SRAM_write(i, 0);
	}
}
    10e4:	df 91       	pop	r29
    10e6:	cf 91       	pop	r28
    10e8:	08 95       	ret

000010ea <oled_draw_line>:

void oled_draw_line(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1) {
    10ea:	6f 92       	push	r6
    10ec:	7f 92       	push	r7
    10ee:	8f 92       	push	r8
    10f0:	9f 92       	push	r9
    10f2:	af 92       	push	r10
    10f4:	bf 92       	push	r11
    10f6:	cf 92       	push	r12
    10f8:	df 92       	push	r13
    10fa:	ef 92       	push	r14
    10fc:	ff 92       	push	r15
    10fe:	0f 93       	push	r16
    1100:	1f 93       	push	r17
    1102:	cf 93       	push	r28
    1104:	df 93       	push	r29
    1106:	c8 2f       	mov	r28, r24
    1108:	d6 2f       	mov	r29, r22
    110a:	94 2e       	mov	r9, r20
    110c:	62 2e       	mov	r6, r18
	int dx = abs(x1 - x0);
    110e:	84 2f       	mov	r24, r20
    1110:	90 e0       	ldi	r25, 0x00	; 0
    1112:	8c 1b       	sub	r24, r28
    1114:	91 09       	sbc	r25, r1
    1116:	7c 01       	movw	r14, r24
    1118:	22 f4       	brpl	.+8      	; 0x1122 <oled_draw_line+0x38>
    111a:	ee 24       	eor	r14, r14
    111c:	ff 24       	eor	r15, r15
    111e:	e8 1a       	sub	r14, r24
    1120:	f9 0a       	sbc	r15, r25
	int dy = abs(y1 - y0);
    1122:	86 2d       	mov	r24, r6
    1124:	90 e0       	ldi	r25, 0x00	; 0
    1126:	8d 1b       	sub	r24, r29
    1128:	91 09       	sbc	r25, r1
    112a:	5c 01       	movw	r10, r24
    112c:	22 f4       	brpl	.+8      	; 0x1136 <oled_draw_line+0x4c>
    112e:	aa 24       	eor	r10, r10
    1130:	bb 24       	eor	r11, r11
    1132:	a8 1a       	sub	r10, r24
    1134:	b9 0a       	sbc	r11, r25
	int sx = (x0 < x1) ? 1 : -1;
    1136:	c9 15       	cp	r28, r9
    1138:	18 f0       	brcs	.+6      	; 0x1140 <oled_draw_line+0x56>
    113a:	88 24       	eor	r8, r8
    113c:	8a 94       	dec	r8
    113e:	02 c0       	rjmp	.+4      	; 0x1144 <oled_draw_line+0x5a>
    1140:	88 24       	eor	r8, r8
    1142:	83 94       	inc	r8
	int sy = (y0 < y1) ? 1 : -1;
    1144:	d6 15       	cp	r29, r6
    1146:	18 f0       	brcs	.+6      	; 0x114e <oled_draw_line+0x64>
    1148:	77 24       	eor	r7, r7
    114a:	7a 94       	dec	r7
    114c:	02 c0       	rjmp	.+4      	; 0x1152 <oled_draw_line+0x68>
    114e:	77 24       	eor	r7, r7
    1150:	73 94       	inc	r7
	int err = dx - dy;
    1152:	87 01       	movw	r16, r14
    1154:	0a 19       	sub	r16, r10
    1156:	1b 09       	sbc	r17, r11
	while (1) {
		oled_write_pixel_to_SRAM(y0, x0, 1);  // Tegn piksel

		if (x0 == x1 && y0 == y1) break;
		int e2 = 2 * err;
		if (e2 > -dy) {
    1158:	cc 24       	eor	r12, r12
    115a:	dd 24       	eor	r13, r13
    115c:	ca 18       	sub	r12, r10
    115e:	db 08       	sbc	r13, r11
	int sx = (x0 < x1) ? 1 : -1;
	int sy = (y0 < y1) ? 1 : -1;
	int err = dx - dy;

	while (1) {
		oled_write_pixel_to_SRAM(y0, x0, 1);  // Tegn piksel
    1160:	41 e0       	ldi	r20, 0x01	; 1
    1162:	6c 2f       	mov	r22, r28
    1164:	8d 2f       	mov	r24, r29
    1166:	0e 94 31 08 	call	0x1062	; 0x1062 <oled_write_pixel_to_SRAM>

		if (x0 == x1 && y0 == y1) break;
    116a:	c9 11       	cpse	r28, r9
    116c:	02 c0       	rjmp	.+4      	; 0x1172 <oled_draw_line+0x88>
    116e:	d6 15       	cp	r29, r6
    1170:	81 f0       	breq	.+32     	; 0x1192 <oled_draw_line+0xa8>
		int e2 = 2 * err;
    1172:	c8 01       	movw	r24, r16
    1174:	88 0f       	add	r24, r24
    1176:	99 1f       	adc	r25, r25
		if (e2 > -dy) {
    1178:	c8 16       	cp	r12, r24
    117a:	d9 06       	cpc	r13, r25
    117c:	1c f4       	brge	.+6      	; 0x1184 <oled_draw_line+0x9a>
			err -= dy;
    117e:	0a 19       	sub	r16, r10
    1180:	1b 09       	sbc	r17, r11
			x0 += sx;
    1182:	c8 0d       	add	r28, r8
		}
		if (e2 < dx) {
    1184:	8e 15       	cp	r24, r14
    1186:	9f 05       	cpc	r25, r15
    1188:	5c f7       	brge	.-42     	; 0x1160 <oled_draw_line+0x76>
			err += dx;
    118a:	0e 0d       	add	r16, r14
    118c:	1f 1d       	adc	r17, r15
			y0 += sy;
    118e:	d7 0d       	add	r29, r7
    1190:	e7 cf       	rjmp	.-50     	; 0x1160 <oled_draw_line+0x76>
		}
	}
}
    1192:	df 91       	pop	r29
    1194:	cf 91       	pop	r28
    1196:	1f 91       	pop	r17
    1198:	0f 91       	pop	r16
    119a:	ff 90       	pop	r15
    119c:	ef 90       	pop	r14
    119e:	df 90       	pop	r13
    11a0:	cf 90       	pop	r12
    11a2:	bf 90       	pop	r11
    11a4:	af 90       	pop	r10
    11a6:	9f 90       	pop	r9
    11a8:	8f 90       	pop	r8
    11aa:	7f 90       	pop	r7
    11ac:	6f 90       	pop	r6
    11ae:	08 95       	ret

000011b0 <oled_draw_circle>:

void oled_draw_circle(uint8_t x0, uint8_t y0, uint8_t radius) {
    11b0:	9f 92       	push	r9
    11b2:	af 92       	push	r10
    11b4:	bf 92       	push	r11
    11b6:	cf 92       	push	r12
    11b8:	df 92       	push	r13
    11ba:	ef 92       	push	r14
    11bc:	ff 92       	push	r15
    11be:	0f 93       	push	r16
    11c0:	1f 93       	push	r17
    11c2:	cf 93       	push	r28
    11c4:	df 93       	push	r29
    11c6:	98 2e       	mov	r9, r24
    11c8:	c6 2e       	mov	r12, r22
	int x = radius;
    11ca:	c4 2f       	mov	r28, r20
    11cc:	d0 e0       	ldi	r29, 0x00	; 0
    11ce:	a1 2c       	mov	r10, r1
    11d0:	b1 2c       	mov	r11, r1
    11d2:	00 e0       	ldi	r16, 0x00	; 0
    11d4:	10 e0       	ldi	r17, 0x00	; 0
	int y = 0;
	int err = 0;

	while (x >= y) {
		oled_write_pixel_to_SRAM(y0 + y, x0 + x, 1);
    11d6:	41 e0       	ldi	r20, 0x01	; 1
    11d8:	fc 2e       	mov	r15, r28
    11da:	f9 0c       	add	r15, r9
    11dc:	6f 2d       	mov	r22, r15
    11de:	dc 2c       	mov	r13, r12
    11e0:	d0 0e       	add	r13, r16
    11e2:	8d 2d       	mov	r24, r13
    11e4:	0e 94 31 08 	call	0x1062	; 0x1062 <oled_write_pixel_to_SRAM>
		oled_write_pixel_to_SRAM(y0 + y, x0 - x, 1);
    11e8:	41 e0       	ldi	r20, 0x01	; 1
    11ea:	e9 2c       	mov	r14, r9
    11ec:	ec 1a       	sub	r14, r28
    11ee:	6e 2d       	mov	r22, r14
    11f0:	8d 2d       	mov	r24, r13
    11f2:	0e 94 31 08 	call	0x1062	; 0x1062 <oled_write_pixel_to_SRAM>
		oled_write_pixel_to_SRAM(y0 - y, x0 + x, 1);
    11f6:	41 e0       	ldi	r20, 0x01	; 1
    11f8:	6f 2d       	mov	r22, r15
    11fa:	fc 2c       	mov	r15, r12
    11fc:	f0 1a       	sub	r15, r16
    11fe:	8f 2d       	mov	r24, r15
    1200:	0e 94 31 08 	call	0x1062	; 0x1062 <oled_write_pixel_to_SRAM>
		oled_write_pixel_to_SRAM(y0 - y, x0 - x, 1);
    1204:	41 e0       	ldi	r20, 0x01	; 1
    1206:	6e 2d       	mov	r22, r14
    1208:	8f 2d       	mov	r24, r15
    120a:	0e 94 31 08 	call	0x1062	; 0x1062 <oled_write_pixel_to_SRAM>
		oled_write_pixel_to_SRAM(y0 + x, x0 + y, 1);
    120e:	41 e0       	ldi	r20, 0x01	; 1
    1210:	f9 2c       	mov	r15, r9
    1212:	f0 0e       	add	r15, r16
    1214:	6f 2d       	mov	r22, r15
    1216:	dc 2e       	mov	r13, r28
    1218:	dc 0c       	add	r13, r12
    121a:	8d 2d       	mov	r24, r13
    121c:	0e 94 31 08 	call	0x1062	; 0x1062 <oled_write_pixel_to_SRAM>
		oled_write_pixel_to_SRAM(y0 + x, x0 - y, 1);
    1220:	41 e0       	ldi	r20, 0x01	; 1
    1222:	e9 2c       	mov	r14, r9
    1224:	e0 1a       	sub	r14, r16
    1226:	6e 2d       	mov	r22, r14
    1228:	8d 2d       	mov	r24, r13
    122a:	0e 94 31 08 	call	0x1062	; 0x1062 <oled_write_pixel_to_SRAM>
		oled_write_pixel_to_SRAM(y0 - x, x0 + y, 1);
    122e:	41 e0       	ldi	r20, 0x01	; 1
    1230:	6f 2d       	mov	r22, r15
    1232:	fc 2c       	mov	r15, r12
    1234:	fc 1a       	sub	r15, r28
    1236:	8f 2d       	mov	r24, r15
    1238:	0e 94 31 08 	call	0x1062	; 0x1062 <oled_write_pixel_to_SRAM>
		oled_write_pixel_to_SRAM(y0 - x, x0 - y, 1);
    123c:	41 e0       	ldi	r20, 0x01	; 1
    123e:	6e 2d       	mov	r22, r14
    1240:	8f 2d       	mov	r24, r15
    1242:	0e 94 31 08 	call	0x1062	; 0x1062 <oled_write_pixel_to_SRAM>

		if (err <= 0) {
    1246:	1a 14       	cp	r1, r10
    1248:	1b 04       	cpc	r1, r11
    124a:	5c f0       	brlt	.+22     	; 0x1262 <oled_draw_circle+0xb2>
			y += 1;
    124c:	0f 5f       	subi	r16, 0xFF	; 255
    124e:	1f 4f       	sbci	r17, 0xFF	; 255
			err += 2 * y + 1;
    1250:	c8 01       	movw	r24, r16
    1252:	88 0f       	add	r24, r24
    1254:	99 1f       	adc	r25, r25
    1256:	01 96       	adiw	r24, 0x01	; 1
    1258:	a8 0e       	add	r10, r24
    125a:	b9 1e       	adc	r11, r25
		}
		if (err > 0) {
    125c:	1a 14       	cp	r1, r10
    125e:	1b 04       	cpc	r1, r11
    1260:	3c f4       	brge	.+14     	; 0x1270 <oled_draw_circle+0xc0>
			x -= 1;
    1262:	21 97       	sbiw	r28, 0x01	; 1
			err -= 2 * x + 1;
    1264:	ce 01       	movw	r24, r28
    1266:	88 0f       	add	r24, r24
    1268:	99 1f       	adc	r25, r25
    126a:	01 96       	adiw	r24, 0x01	; 1
    126c:	a8 1a       	sub	r10, r24
    126e:	b9 0a       	sbc	r11, r25
void oled_draw_circle(uint8_t x0, uint8_t y0, uint8_t radius) {
	int x = radius;
	int y = 0;
	int err = 0;

	while (x >= y) {
    1270:	c0 17       	cp	r28, r16
    1272:	d1 07       	cpc	r29, r17
    1274:	0c f0       	brlt	.+2      	; 0x1278 <oled_draw_circle+0xc8>
    1276:	af cf       	rjmp	.-162    	; 0x11d6 <oled_draw_circle+0x26>
		if (err > 0) {
			x -= 1;
			err -= 2 * x + 1;
		}
	}
}
    1278:	df 91       	pop	r29
    127a:	cf 91       	pop	r28
    127c:	1f 91       	pop	r17
    127e:	0f 91       	pop	r16
    1280:	ff 90       	pop	r15
    1282:	ef 90       	pop	r14
    1284:	df 90       	pop	r13
    1286:	cf 90       	pop	r12
    1288:	bf 90       	pop	r11
    128a:	af 90       	pop	r10
    128c:	9f 90       	pop	r9
    128e:	08 95       	ret

00001290 <oled_draw_square>:

void oled_draw_square(uint8_t x0, uint8_t y0, uint8_t width, uint8_t height) {
    1290:	0f 93       	push	r16
    1292:	1f 93       	push	r17
    1294:	cf 93       	push	r28
    1296:	df 93       	push	r29
    1298:	08 2f       	mov	r16, r24
    129a:	16 2f       	mov	r17, r22
    129c:	d2 2f       	mov	r29, r18
	oled_draw_line(x0, y0, x0 + width, y0);           // Øvre linje
    129e:	c8 2f       	mov	r28, r24
    12a0:	c4 0f       	add	r28, r20
    12a2:	26 2f       	mov	r18, r22
    12a4:	4c 2f       	mov	r20, r28
    12a6:	0e 94 75 08 	call	0x10ea	; 0x10ea <oled_draw_line>
	oled_draw_line(x0, y0 + height, x0 + width, y0 + height);  // Nedre linje
    12aa:	d1 0f       	add	r29, r17
    12ac:	2d 2f       	mov	r18, r29
    12ae:	4c 2f       	mov	r20, r28
    12b0:	6d 2f       	mov	r22, r29
    12b2:	80 2f       	mov	r24, r16
    12b4:	0e 94 75 08 	call	0x10ea	; 0x10ea <oled_draw_line>
	oled_draw_line(x0, y0, x0, y0 + height);           // Venstre linje
    12b8:	2d 2f       	mov	r18, r29
    12ba:	40 2f       	mov	r20, r16
    12bc:	61 2f       	mov	r22, r17
    12be:	80 2f       	mov	r24, r16
    12c0:	0e 94 75 08 	call	0x10ea	; 0x10ea <oled_draw_line>
	oled_draw_line(x0 + width, y0, x0 + width, y0 + height);   // Høyre linje
    12c4:	2d 2f       	mov	r18, r29
    12c6:	4c 2f       	mov	r20, r28
    12c8:	61 2f       	mov	r22, r17
    12ca:	8c 2f       	mov	r24, r28
    12cc:	0e 94 75 08 	call	0x10ea	; 0x10ea <oled_draw_line>
}
    12d0:	df 91       	pop	r29
    12d2:	cf 91       	pop	r28
    12d4:	1f 91       	pop	r17
    12d6:	0f 91       	pop	r16
    12d8:	08 95       	ret

000012da <__vector_15>:

// Definer den globale variabelen for å telje millisekund
volatile uint32_t overflow_count = 0;

// Timer-overflyt interrupt service rutine
ISR(TIMER1_OVF_vect) {
    12da:	1f 92       	push	r1
    12dc:	0f 92       	push	r0
    12de:	0f b6       	in	r0, 0x3f	; 63
    12e0:	0f 92       	push	r0
    12e2:	11 24       	eor	r1, r1
    12e4:	8f 93       	push	r24
    12e6:	9f 93       	push	r25
    12e8:	af 93       	push	r26
    12ea:	bf 93       	push	r27
	overflow_count++;
    12ec:	80 91 bd 01 	lds	r24, 0x01BD	; 0x8001bd <overflow_count>
    12f0:	90 91 be 01 	lds	r25, 0x01BE	; 0x8001be <overflow_count+0x1>
    12f4:	a0 91 bf 01 	lds	r26, 0x01BF	; 0x8001bf <overflow_count+0x2>
    12f8:	b0 91 c0 01 	lds	r27, 0x01C0	; 0x8001c0 <overflow_count+0x3>
    12fc:	01 96       	adiw	r24, 0x01	; 1
    12fe:	a1 1d       	adc	r26, r1
    1300:	b1 1d       	adc	r27, r1
    1302:	80 93 bd 01 	sts	0x01BD, r24	; 0x8001bd <overflow_count>
    1306:	90 93 be 01 	sts	0x01BE, r25	; 0x8001be <overflow_count+0x1>
    130a:	a0 93 bf 01 	sts	0x01BF, r26	; 0x8001bf <overflow_count+0x2>
    130e:	b0 93 c0 01 	sts	0x01C0, r27	; 0x8001c0 <overflow_count+0x3>
}
    1312:	bf 91       	pop	r27
    1314:	af 91       	pop	r26
    1316:	9f 91       	pop	r25
    1318:	8f 91       	pop	r24
    131a:	0f 90       	pop	r0
    131c:	0f be       	out	0x3f, r0	; 63
    131e:	0f 90       	pop	r0
    1320:	1f 90       	pop	r1
    1322:	18 95       	reti

00001324 <get_time_in_cycles>:
}

uint32_t get_time_in_cycles(void) {
	// Returner tiden i klokkesykluser
	// Hver gang timeren overflyter, har vi telt 65536 klokkesykluser
	return (overflow_count * 65536UL) + TCNT1;
    1324:	80 91 bd 01 	lds	r24, 0x01BD	; 0x8001bd <overflow_count>
    1328:	90 91 be 01 	lds	r25, 0x01BE	; 0x8001be <overflow_count+0x1>
    132c:	a0 91 bf 01 	lds	r26, 0x01BF	; 0x8001bf <overflow_count+0x2>
    1330:	b0 91 c0 01 	lds	r27, 0x01C0	; 0x8001c0 <overflow_count+0x3>
    1334:	2c b5       	in	r18, 0x2c	; 44
    1336:	3d b5       	in	r19, 0x2d	; 45
    1338:	dc 01       	movw	r26, r24
    133a:	99 27       	eor	r25, r25
    133c:	88 27       	eor	r24, r24
    133e:	bc 01       	movw	r22, r24
    1340:	cd 01       	movw	r24, r26
    1342:	62 0f       	add	r22, r18
    1344:	73 1f       	adc	r23, r19
    1346:	81 1d       	adc	r24, r1
    1348:	91 1d       	adc	r25, r1
}
    134a:	08 95       	ret

0000134c <get_time_in_ms>:
	overflow_count++;
}

// Funksjon som returnerer tida i millisekund sidan programstart
uint32_t get_time_in_ms(void){
	return get_time_in_cycles()/(4915200UL/1000);
    134c:	0e 94 92 09 	call	0x1324	; 0x1324 <get_time_in_cycles>
    1350:	23 e3       	ldi	r18, 0x33	; 51
    1352:	33 e1       	ldi	r19, 0x13	; 19
    1354:	40 e0       	ldi	r20, 0x00	; 0
    1356:	50 e0       	ldi	r21, 0x00	; 0
    1358:	0e 94 27 0a 	call	0x144e	; 0x144e <__udivmodsi4>
}
    135c:	ca 01       	movw	r24, r20
    135e:	b9 01       	movw	r22, r18
    1360:	08 95       	ret

00001362 <setup_timer>:
}

// Funksjon for å setje opp Timer1 til å generere 1 ms avbrot
void setup_timer() {
	// Sett normal modus (WGM12 = 0)
	TCCR1A = 0;      // Normal mode
    1362:	1f bc       	out	0x2f, r1	; 47
	TCCR1B = (1 << CS10); // Prescaler = 1 (ingen prescaling, f_CPU direkte)
    1364:	81 e0       	ldi	r24, 0x01	; 1
    1366:	8e bd       	out	0x2e, r24	; 46

	// Aktiver Timer1 overflow interrupt
	TIMSK = (1 << TOIE1);
    1368:	80 e8       	ldi	r24, 0x80	; 128
    136a:	89 bf       	out	0x39, r24	; 57

	// Nullstill Timer/Counter1
	TCNT1 = 0;
    136c:	1d bc       	out	0x2d, r1	; 45
    136e:	1c bc       	out	0x2c, r1	; 44
    1370:	08 95       	ret

00001372 <restart_timer>:
}
void restart_timer(){
	// Nullstill Timer/Counter1
	TCNT1 = 0;
    1372:	1d bc       	out	0x2d, r1	; 45
    1374:	1c bc       	out	0x2c, r1	; 44
	overflow_count = 0;
    1376:	10 92 bd 01 	sts	0x01BD, r1	; 0x8001bd <overflow_count>
    137a:	10 92 be 01 	sts	0x01BE, r1	; 0x8001be <overflow_count+0x1>
    137e:	10 92 bf 01 	sts	0x01BF, r1	; 0x8001bf <overflow_count+0x2>
    1382:	10 92 c0 01 	sts	0x01C0, r1	; 0x8001c0 <overflow_count+0x3>
    1386:	08 95       	ret

00001388 <externalMemoryInit>:
 */ 
#include "XMEM_Decode.h"
// Funksjon for ï¿½ initialisere det eksterne minnet (SRAM + latch)
void externalMemoryInit(void) {
	// Set Port A (AD0-AD7) og Port C (A8-A15) som utgang for adresse- og databuss
	DDRA = 0xFF;  // PA0-PA7 som utgang
    1388:	8f ef       	ldi	r24, 0xFF	; 255
    138a:	8a bb       	out	0x1a, r24	; 26
	DDRC = 0x0F ;  // PC0-PC3 som utgang
    138c:	8f e0       	ldi	r24, 0x0F	; 15
    138e:	84 bb       	out	0x14, r24	; 20
	
	// Set Port D (PD6 og PD7) som utgang for WR og RD signal
	setBit(DDRD, PD6);  // WR
    1390:	8e 9a       	sbi	0x11, 6	; 17
	setBit(DDRD, PD7);  // RD
    1392:	8f 9a       	sbi	0x11, 7	; 17

	// Set Port E (PE1) som utgang for ALE
	setBit(DDRE, PE1);  // ALE
    1394:	31 9a       	sbi	0x06, 1	; 6

	// Aktivere ekstern minnegrensesnitt
	setBit(MCUCR, SRE);   // Enable external SRAM interface
    1396:	85 b7       	in	r24, 0x35	; 53
    1398:	80 68       	ori	r24, 0x80	; 128
    139a:	85 bf       	out	0x35, r24	; 53
	SFIOR = 0x00;         // No wait state
    139c:	10 be       	out	0x30, r1	; 48
	
	//Maskes pc4-pc7 (disables as output) (s32 ATmega datasheet)
	setBit(SFIOR, XMM2);
    139e:	80 b7       	in	r24, 0x30	; 48
    13a0:	80 62       	ori	r24, 0x20	; 32
    13a2:	80 bf       	out	0x30, r24	; 48
    13a4:	08 95       	ret

000013a6 <SRAM_write>:
}


// Funksjon for ï¿½ skrive data til SRAM
void SRAM_write(volatile uint16_t addr, uint8_t data) {
    13a6:	cf 93       	push	r28
    13a8:	df 93       	push	r29
    13aa:	00 d0       	rcall	.+0      	; 0x13ac <SRAM_write+0x6>
    13ac:	cd b7       	in	r28, 0x3d	; 61
    13ae:	de b7       	in	r29, 0x3e	; 62
    13b0:	9a 83       	std	Y+2, r25	; 0x02
    13b2:	89 83       	std	Y+1, r24	; 0x01
	volatile char *ext_ram = (char *) SRAM_START; // Startadresse for SRAM
	uint16_t ext_ram_size = SRAM_SIZE; // Stï¿½rrelsen pï¿½ SRAM (2 KB)
	ext_ram[addr] = data;
    13b4:	e9 81       	ldd	r30, Y+1	; 0x01
    13b6:	fa 81       	ldd	r31, Y+2	; 0x02
    13b8:	f8 5e       	subi	r31, 0xE8	; 232
    13ba:	60 83       	st	Z, r22
}
    13bc:	0f 90       	pop	r0
    13be:	0f 90       	pop	r0
    13c0:	df 91       	pop	r29
    13c2:	cf 91       	pop	r28
    13c4:	08 95       	ret

000013c6 <SRAM_read>:

// Funksjon for ï¿½ lese data frï¿½ SRAM
uint8_t SRAM_read(volatile uint16_t addr) {
    13c6:	cf 93       	push	r28
    13c8:	df 93       	push	r29
    13ca:	00 d0       	rcall	.+0      	; 0x13cc <SRAM_read+0x6>
    13cc:	cd b7       	in	r28, 0x3d	; 61
    13ce:	de b7       	in	r29, 0x3e	; 62
    13d0:	9a 83       	std	Y+2, r25	; 0x02
    13d2:	89 83       	std	Y+1, r24	; 0x01
	volatile char *ext_ram = (char *) SRAM_START; // Startadresse for SRAM
	uint16_t ext_ram_size = SRAM_SIZE; // Stï¿½rrelsen pï¿½ SRAM (2 KB)
	uint8_t data = ext_ram[addr];
    13d4:	e9 81       	ldd	r30, Y+1	; 0x01
    13d6:	fa 81       	ldd	r31, Y+2	; 0x02
    13d8:	f8 5e       	subi	r31, 0xE8	; 232
    13da:	80 81       	ld	r24, Z
	
	return data;
}
    13dc:	0f 90       	pop	r0
    13de:	0f 90       	pop	r0
    13e0:	df 91       	pop	r29
    13e2:	cf 91       	pop	r28
    13e4:	08 95       	ret

000013e6 <Universal_write>:

// Funksjon for ï¿½ skrive data til SRAM
void Universal_write(volatile uint16_t addr, uint8_t data) {
    13e6:	cf 93       	push	r28
    13e8:	df 93       	push	r29
    13ea:	00 d0       	rcall	.+0      	; 0x13ec <Universal_write+0x6>
    13ec:	cd b7       	in	r28, 0x3d	; 61
    13ee:	de b7       	in	r29, 0x3e	; 62
    13f0:	9a 83       	std	Y+2, r25	; 0x02
    13f2:	89 83       	std	Y+1, r24	; 0x01
	volatile char *ext_ram = (char *) OLED_START; // Startadresse for SRAM
	ext_ram[addr] = data;
    13f4:	e9 81       	ldd	r30, Y+1	; 0x01
    13f6:	fa 81       	ldd	r31, Y+2	; 0x02
    13f8:	f0 5f       	subi	r31, 0xF0	; 240
    13fa:	60 83       	st	Z, r22
		
}
    13fc:	0f 90       	pop	r0
    13fe:	0f 90       	pop	r0
    1400:	df 91       	pop	r29
    1402:	cf 91       	pop	r28
    1404:	08 95       	ret

00001406 <Universal_read>:

// Funksjon for ï¿½ lese data frï¿½ SRAM
uint8_t Universal_read(volatile uint16_t addr) {
    1406:	cf 93       	push	r28
    1408:	df 93       	push	r29
    140a:	00 d0       	rcall	.+0      	; 0x140c <Universal_read+0x6>
    140c:	cd b7       	in	r28, 0x3d	; 61
    140e:	de b7       	in	r29, 0x3e	; 62
    1410:	9a 83       	std	Y+2, r25	; 0x02
    1412:	89 83       	std	Y+1, r24	; 0x01
	volatile char *ext_ram = (char *) OLED_START; // Startadresse for SRAM
	uint8_t data = ext_ram[addr];
    1414:	e9 81       	ldd	r30, Y+1	; 0x01
    1416:	fa 81       	ldd	r31, Y+2	; 0x02
    1418:	f0 5f       	subi	r31, 0xF0	; 240
    141a:	80 81       	ld	r24, Z
	
	return data;
}
    141c:	0f 90       	pop	r0
    141e:	0f 90       	pop	r0
    1420:	df 91       	pop	r29
    1422:	cf 91       	pop	r28
    1424:	08 95       	ret

00001426 <__divmodhi4>:
    1426:	97 fb       	bst	r25, 7
    1428:	07 2e       	mov	r0, r23
    142a:	16 f4       	brtc	.+4      	; 0x1430 <__divmodhi4+0xa>
    142c:	00 94       	com	r0
    142e:	07 d0       	rcall	.+14     	; 0x143e <__divmodhi4_neg1>
    1430:	77 fd       	sbrc	r23, 7
    1432:	09 d0       	rcall	.+18     	; 0x1446 <__divmodhi4_neg2>
    1434:	0e 94 49 0a 	call	0x1492	; 0x1492 <__udivmodhi4>
    1438:	07 fc       	sbrc	r0, 7
    143a:	05 d0       	rcall	.+10     	; 0x1446 <__divmodhi4_neg2>
    143c:	3e f4       	brtc	.+14     	; 0x144c <__divmodhi4_exit>

0000143e <__divmodhi4_neg1>:
    143e:	90 95       	com	r25
    1440:	81 95       	neg	r24
    1442:	9f 4f       	sbci	r25, 0xFF	; 255
    1444:	08 95       	ret

00001446 <__divmodhi4_neg2>:
    1446:	70 95       	com	r23
    1448:	61 95       	neg	r22
    144a:	7f 4f       	sbci	r23, 0xFF	; 255

0000144c <__divmodhi4_exit>:
    144c:	08 95       	ret

0000144e <__udivmodsi4>:
    144e:	a1 e2       	ldi	r26, 0x21	; 33
    1450:	1a 2e       	mov	r1, r26
    1452:	aa 1b       	sub	r26, r26
    1454:	bb 1b       	sub	r27, r27
    1456:	fd 01       	movw	r30, r26
    1458:	0d c0       	rjmp	.+26     	; 0x1474 <__udivmodsi4_ep>

0000145a <__udivmodsi4_loop>:
    145a:	aa 1f       	adc	r26, r26
    145c:	bb 1f       	adc	r27, r27
    145e:	ee 1f       	adc	r30, r30
    1460:	ff 1f       	adc	r31, r31
    1462:	a2 17       	cp	r26, r18
    1464:	b3 07       	cpc	r27, r19
    1466:	e4 07       	cpc	r30, r20
    1468:	f5 07       	cpc	r31, r21
    146a:	20 f0       	brcs	.+8      	; 0x1474 <__udivmodsi4_ep>
    146c:	a2 1b       	sub	r26, r18
    146e:	b3 0b       	sbc	r27, r19
    1470:	e4 0b       	sbc	r30, r20
    1472:	f5 0b       	sbc	r31, r21

00001474 <__udivmodsi4_ep>:
    1474:	66 1f       	adc	r22, r22
    1476:	77 1f       	adc	r23, r23
    1478:	88 1f       	adc	r24, r24
    147a:	99 1f       	adc	r25, r25
    147c:	1a 94       	dec	r1
    147e:	69 f7       	brne	.-38     	; 0x145a <__udivmodsi4_loop>
    1480:	60 95       	com	r22
    1482:	70 95       	com	r23
    1484:	80 95       	com	r24
    1486:	90 95       	com	r25
    1488:	9b 01       	movw	r18, r22
    148a:	ac 01       	movw	r20, r24
    148c:	bd 01       	movw	r22, r26
    148e:	cf 01       	movw	r24, r30
    1490:	08 95       	ret

00001492 <__udivmodhi4>:
    1492:	aa 1b       	sub	r26, r26
    1494:	bb 1b       	sub	r27, r27
    1496:	51 e1       	ldi	r21, 0x11	; 17
    1498:	07 c0       	rjmp	.+14     	; 0x14a8 <__udivmodhi4_ep>

0000149a <__udivmodhi4_loop>:
    149a:	aa 1f       	adc	r26, r26
    149c:	bb 1f       	adc	r27, r27
    149e:	a6 17       	cp	r26, r22
    14a0:	b7 07       	cpc	r27, r23
    14a2:	10 f0       	brcs	.+4      	; 0x14a8 <__udivmodhi4_ep>
    14a4:	a6 1b       	sub	r26, r22
    14a6:	b7 0b       	sbc	r27, r23

000014a8 <__udivmodhi4_ep>:
    14a8:	88 1f       	adc	r24, r24
    14aa:	99 1f       	adc	r25, r25
    14ac:	5a 95       	dec	r21
    14ae:	a9 f7       	brne	.-22     	; 0x149a <__udivmodhi4_loop>
    14b0:	80 95       	com	r24
    14b2:	90 95       	com	r25
    14b4:	bc 01       	movw	r22, r24
    14b6:	cd 01       	movw	r24, r26
    14b8:	08 95       	ret

000014ba <_exit>:
    14ba:	f8 94       	cli

000014bc <__stop_program>:
    14bc:	ff cf       	rjmp	.-2      	; 0x14bc <__stop_program>
