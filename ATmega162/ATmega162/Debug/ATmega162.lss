
ATmega162.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000ba  00800100  00001536  000015ca  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001536  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000001f  008001ba  008001ba  00001684  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001684  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000016b4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000288  00000000  00000000  000016f0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00003121  00000000  00000000  00001978  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000011ef  00000000  00000000  00004a99  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000161a  00000000  00000000  00005c88  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000730  00000000  00000000  000072a4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000ad2  00000000  00000000  000079d4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001d3a  00000000  00000000  000084a6  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000208  00000000  00000000  0000a1e0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 1c 03 	jmp	0x638	; 0x638 <__ctors_end>
       4:	0c 94 39 03 	jmp	0x672	; 0x672 <__bad_interrupt>
       8:	0c 94 39 03 	jmp	0x672	; 0x672 <__bad_interrupt>
       c:	0c 94 39 03 	jmp	0x672	; 0x672 <__bad_interrupt>
      10:	0c 94 39 03 	jmp	0x672	; 0x672 <__bad_interrupt>
      14:	0c 94 39 03 	jmp	0x672	; 0x672 <__bad_interrupt>
      18:	0c 94 39 03 	jmp	0x672	; 0x672 <__bad_interrupt>
      1c:	0c 94 39 03 	jmp	0x672	; 0x672 <__bad_interrupt>
      20:	0c 94 39 03 	jmp	0x672	; 0x672 <__bad_interrupt>
      24:	0c 94 39 03 	jmp	0x672	; 0x672 <__bad_interrupt>
      28:	0c 94 39 03 	jmp	0x672	; 0x672 <__bad_interrupt>
      2c:	0c 94 39 03 	jmp	0x672	; 0x672 <__bad_interrupt>
      30:	0c 94 39 03 	jmp	0x672	; 0x672 <__bad_interrupt>
      34:	0c 94 39 03 	jmp	0x672	; 0x672 <__bad_interrupt>
      38:	0c 94 39 03 	jmp	0x672	; 0x672 <__bad_interrupt>
      3c:	0c 94 8b 09 	jmp	0x1316	; 0x1316 <__vector_15>
      40:	0c 94 39 03 	jmp	0x672	; 0x672 <__bad_interrupt>
      44:	0c 94 39 03 	jmp	0x672	; 0x672 <__bad_interrupt>
      48:	0c 94 39 03 	jmp	0x672	; 0x672 <__bad_interrupt>
      4c:	0c 94 66 03 	jmp	0x6cc	; 0x6cc <__vector_19>
      50:	0c 94 39 03 	jmp	0x672	; 0x672 <__bad_interrupt>
      54:	0c 94 39 03 	jmp	0x672	; 0x672 <__bad_interrupt>
      58:	0c 94 39 03 	jmp	0x672	; 0x672 <__bad_interrupt>
      5c:	0c 94 39 03 	jmp	0x672	; 0x672 <__bad_interrupt>
      60:	0c 94 39 03 	jmp	0x672	; 0x672 <__bad_interrupt>
      64:	0c 94 39 03 	jmp	0x672	; 0x672 <__bad_interrupt>
      68:	0c 94 39 03 	jmp	0x672	; 0x672 <__bad_interrupt>
      6c:	0c 94 39 03 	jmp	0x672	; 0x672 <__bad_interrupt>

00000070 <__trampolines_end>:
      70:	20 20       	and	r2, r0
      72:	5f 5f       	subi	r21, 0xFF	; 255
      74:	5f 5f       	subi	r21, 0xFF	; 255
      76:	5f 25       	eor	r21, r15
      78:	20 20       	and	r2, r0
      7a:	25 5f       	subi	r18, 0xF5	; 245
      7c:	5f 5f       	subi	r21, 0xFF	; 255
      7e:	5f 5f       	subi	r21, 0xFF	; 255
      80:	20 20       	and	r2, r0
      82:	2a 2a       	or	r2, r26
      84:	2a 2a       	or	r2, r26
      86:	2a 20       	and	r2, r10
      88:	20 20       	and	r2, r0
      8a:	2a 2a       	or	r2, r26
      8c:	2a 2a       	or	r2, r26
      8e:	2a 20       	and	r2, r10
      90:	20 2a       	or	r2, r16
      92:	20 20       	and	r2, r0
      94:	20 20       	and	r2, r0
      96:	20 2a       	or	r2, r16
      98:	20 2a       	or	r2, r16
      9a:	20 20       	and	r2, r0
      9c:	20 20       	and	r2, r0
      9e:	20 2a       	or	r2, r16
      a0:	20 2a       	or	r2, r16
      a2:	20 20       	and	r2, r0
      a4:	2a 2a       	or	r2, r26
      a6:	20 20       	and	r2, r0
      a8:	2a 20       	and	r2, r10
      aa:	20 2a       	or	r2, r16
      ac:	2a 20       	and	r2, r10
      ae:	20 2a       	or	r2, r16
      b0:	20 2a       	or	r2, r16
      b2:	20 20       	and	r2, r0
      b4:	20 20       	and	r2, r0
      b6:	20 20       	and	r2, r0
      b8:	2a 20       	and	r2, r10
      ba:	20 20       	and	r2, r0
      bc:	20 20       	and	r2, r0
      be:	20 2a       	or	r2, r16
      c0:	20 20       	and	r2, r0
      c2:	2a 20       	and	r2, r10
      c4:	20 20       	and	r2, r0
      c6:	20 2a       	or	r2, r16
      c8:	20 2a       	or	r2, r16
      ca:	20 20       	and	r2, r0
      cc:	20 20       	and	r2, r0
      ce:	2a 20       	and	r2, r10
      d0:	20 20       	and	r2, r0
      d2:	20 2a       	or	r2, r16
      d4:	2a 2a       	or	r2, r26
      d6:	2a 20       	and	r2, r10
      d8:	20 20       	and	r2, r0
      da:	2a 2a       	or	r2, r26
      dc:	2a 2a       	or	r2, r26
      de:	20 20       	and	r2, r0
      e0:	20 5c       	subi	r18, 0xC0	; 192
      e2:	5f 5f       	subi	r21, 0xFF	; 255
      e4:	5f 5f       	subi	r21, 0xFF	; 255
      e6:	5f 5f       	subi	r21, 0xFF	; 255
      e8:	5f 5f       	subi	r21, 0xFF	; 255
      ea:	5f 5f       	subi	r21, 0xFF	; 255
      ec:	5f 5f       	subi	r21, 0xFF	; 255
      ee:	5f 2f       	mov	r21, r31

000000f0 <solkors>:
      f0:	20 20 20 79 61 70 40 40 40 2a 20 20 20 20 20 20        yap@@@*      
     100:	20 20 20 23 40 40 40 23 20 20 20 2a 23 20 20 20        #@@@#   *#   
     110:	20 20 23 40 40 40 2a 20 20 2a 40 40 40 40 23 20       #@@@*  *@@@@# 
     120:	2a 20 20 2b 23 40 40 40 40 40 40 20 20 40 40 40     *  +#@@@@@@  @@@
     130:	40 40 20 20 20 2b 40 40 40 40 2a 20 20 20 40 40     @@   +@@@@*   @@
     140:	40 40 40 25 25 40 40 40 40 40 40 20 2b 20 20 2a     @@@%%@@@@@@ +  *
     150:	20 23 40 40 40 40 2a 20 20 2a 40 40 40 23 20 20      #@@@@*  *@@@#  
     160:	20 20 20 23 23 20 20 20 23 40 40 40 23 20 20 20        ##   #@@@#   

00000170 <font8x8_basic>:
	...
     178:	00 00 5f 00 00 00 00 00 00 07 00 07 00 00 00 00     .._.............
     188:	14 7f 14 7f 14 00 00 00 24 2a 7f 2a 12 00 00 00     ........$*.*....
     198:	23 13 08 64 62 00 00 00 36 49 56 20 50 00 00 00     #..db...6IV P...
     1a8:	00 08 07 03 00 00 00 00 00 1c 22 41 00 00 00 00     .........."A....
     1b8:	00 41 22 1c 00 00 00 00 14 08 3e 08 14 00 00 00     .A".......>.....
     1c8:	08 08 3e 08 08 00 00 00 00 50 30 00 00 00 00 00     ..>......P0.....
     1d8:	08 08 08 08 08 00 00 00 00 60 60 00 00 00 00 00     .........``.....
     1e8:	20 10 08 04 02 00 00 00 3e 51 49 45 3e 00 00 00      .......>QIE>...
     1f8:	00 42 7f 40 00 00 00 00 42 61 51 49 46 00 00 00     .B.@....BaQIF...
     208:	21 41 45 4b 31 00 00 00 18 14 12 7f 10 00 00 00     !AEK1...........
     218:	27 45 45 45 39 00 00 00 3c 4a 49 49 30 00 00 00     'EEE9...<JII0...
     228:	01 71 09 05 03 00 00 00 36 49 49 49 36 00 00 00     .q......6III6...
     238:	06 49 49 29 1e 00 00 00 00 36 36 00 00 00 00 00     .II).....66.....
     248:	00 56 36 00 00 00 00 00 08 14 22 41 00 00 00 00     .V6......."A....
     258:	14 14 14 14 14 14 00 00 41 22 14 08 00 00 00 00     ........A"......
     268:	02 01 51 09 06 00 00 00 3e 41 5d 5d 1e 00 00 00     ..Q.....>A]]....
     278:	7e 11 11 11 7e 00 00 00 7f 49 49 49 36 00 00 00     ~...~....III6...
     288:	3e 41 41 41 22 00 00 00 7f 41 41 22 1c 00 00 00     >AAA"....AA"....
     298:	7f 49 49 49 41 00 00 00 7f 09 09 09 01 00 00 00     .IIIA...........
     2a8:	3e 41 49 49 7a 00 00 00 7f 08 08 08 7f 00 00 00     >AIIz...........
     2b8:	00 41 7f 41 00 00 00 00 20 40 41 3f 01 00 00 00     .A.A.... @A?....
     2c8:	7f 08 14 22 41 00 00 00 7f 40 40 40 40 00 00 00     ..."A....@@@@...
     2d8:	7f 02 04 02 7f 00 00 00 7f 02 04 08 7f 00 00 00     ................
     2e8:	3e 41 41 41 3e 00 00 00 7f 09 09 09 06 00 00 00     >AAA>...........
     2f8:	3e 41 51 21 5e 00 00 00 7f 09 19 29 46 00 00 00     >AQ!^......)F...
     308:	46 49 49 49 31 00 00 00 01 01 7f 01 01 00 00 00     FIII1...........
     318:	3f 40 40 40 3f 00 00 00 1f 20 40 20 1f 00 00 00     ?@@@?.... @ ....
     328:	7f 20 18 20 7f 00 00 00 63 14 08 14 63 00 00 00     . . ....c...c...
     338:	03 04 78 04 03 00 00 00 61 51 49 45 43 00 00 00     ..x.....aQIEC...
     348:	00 3e 41 41 00 00 00 00 02 04 08 10 20 00 00 00     .>AA........ ...
     358:	00 41 41 3e 00 00 00 00 04 02 01 02 04 00 00 00     .AA>............
     368:	40 40 40 40 40 40 00 00 00 00 03 07 00 00 00 00     @@@@@@..........
     378:	20 54 54 54 78 00 00 00 7f 48 44 44 38 00 00 00      TTTx....HDD8...
     388:	38 44 44 44 20 00 00 00 38 44 44 48 7f 00 00 00     8DDD ...8DDH....
     398:	38 54 54 54 18 00 00 00 08 7e 09 01 02 00 00 00     8TTT.....~......
     3a8:	08 14 54 54 3c 00 00 00 7f 08 04 04 78 00 00 00     ..TT<.......x...
     3b8:	00 44 7d 40 00 00 00 00 20 40 44 3d 00 00 00 00     .D}@.... @D=....
     3c8:	00 7f 10 28 44 00 00 00 00 41 7f 40 00 00 00 00     ...(D....A.@....
     3d8:	7c 04 18 04 78 00 00 00 7c 08 04 04 78 00 00 00     |...x...|...x...
     3e8:	38 44 44 44 38 00 00 00 7c 14 14 14 08 00 00 00     8DDD8...|.......
     3f8:	08 14 14 18 7c 00 00 00 7c 08 04 04 08 00 00 00     ....|...|.......
     408:	48 54 54 54 20 00 00 00 04 3f 44 40 20 00 00 00     HTTT ....?D@ ...
     418:	3c 40 40 20 7c 00 00 00 1c 20 40 20 1c 00 00 00     <@@ |.... @ ....
     428:	3c 40 30 40 3c 00 00 00 44 28 10 28 44 00 00 00     <@0@<...D(.(D...
     438:	0c 50 50 50 3c 00 00 00 44 64 54 4c 44 00 00 00     .PPP<...DdTLD...
     448:	00 08 36 41 00 00 00 00 00 00 7f 00 00 00 00 00     ..6A............
     458:	00 41 36 08 00 00 00 00 08 04 08 10 08 00 00 00     .A6.............

00000468 <settingsMenuItems>:
     468:	20 53 6f 75 6e 64 20 20 20 20 20 20 20 20 00 00      Sound        ..
     478:	20 42 72 69 67 68 74 6e 65 73 73 20 20 20 00 00      Brightness   ..
     488:	20 43 6f 6e 74 72 6f 6c 73 20 20 20 20 20 00 00      Controls     ..
     498:	20 42 61 63 6b 20 20 20 20 20 20 20 20 20 00 00      Back         ..

000004a8 <scrollMenuItems>:
     4a8:	20 49 74 65 6d 20 31 20 20 42 41 43 4b 20 00 00      Item 1  BACK ..
     4b8:	20 49 74 65 6d 20 32 20 20 20 20 20 20 20 00 00      Item 2       ..
     4c8:	20 49 74 65 6d 20 33 20 20 20 20 20 20 20 00 00      Item 3       ..
     4d8:	20 49 74 65 6d 20 34 20 20 20 20 20 20 20 00 00      Item 4       ..
     4e8:	20 49 74 65 6d 20 35 20 20 20 20 20 20 20 00 00      Item 5       ..
     4f8:	20 49 74 65 6d 20 36 20 20 20 20 20 20 20 00 00      Item 6       ..
     508:	20 49 74 65 6d 20 37 20 20 20 20 20 20 20 00 00      Item 7       ..
     518:	20 49 74 65 6d 20 38 20 20 20 20 20 20 20 00 00      Item 8       ..
     528:	20 49 74 65 6d 20 39 20 20 20 20 20 20 20 00 00      Item 9       ..
     538:	20 49 74 65 6d 20 31 30 20 20 20 20 20 20 00 00      Item 10      ..
     548:	20 49 74 65 6d 20 31 31 20 20 20 20 20 20 00 00      Item 11      ..
     558:	20 49 74 65 6d 20 31 32 20 20 20 20 20 20 00 00      Item 12      ..
     568:	20 49 74 65 6d 20 31 33 20 20 20 20 20 20 00 00      Item 13      ..
     578:	20 49 74 65 6d 20 31 34 20 20 20 20 20 20 00 00      Item 14      ..
     588:	20 49 74 65 6d 20 31 35 20 20 20 20 20 20 00 00      Item 15      ..
     598:	20 49 74 65 6d 20 31 36 20 20 20 20 20 20 00 00      Item 16      ..
     5a8:	20 49 74 65 6d 20 31 37 20 20 20 20 20 20 00 00      Item 17      ..
     5b8:	20 49 74 65 6d 20 31 38 20 20 20 20 20 20 00 00      Item 18      ..
     5c8:	20 49 74 65 6d 20 31 39 20 20 20 20 20 20 00 00      Item 19      ..
     5d8:	20 49 74 65 6d 20 32 30 20 20 20 20 20 20 00 00      Item 20      ..

000005e8 <mainMenuItems>:
     5e8:	20 53 74 61 72 74 20 47 61 6d 65 20 20 20 00 00      Start Game   ..
     5f8:	20 53 65 74 74 69 6e 67 73 20 20 20 20 20 00 00      Settings     ..
     608:	20 48 69 67 68 20 53 63 6f 72 65 73 20 20 00 00      High Scores  ..
     618:	20 43 72 65 64 69 74 73 20 20 20 20 20 20 00 00      Credits      ..
     628:	20 45 78 69 74 20 20 20 20 20 20 20 20 20 00 00      Exit         ..

00000638 <__ctors_end>:
     638:	11 24       	eor	r1, r1
     63a:	1f be       	out	0x3f, r1	; 63
     63c:	cf ef       	ldi	r28, 0xFF	; 255
     63e:	d4 e0       	ldi	r29, 0x04	; 4
     640:	de bf       	out	0x3e, r29	; 62
     642:	cd bf       	out	0x3d, r28	; 61

00000644 <__do_copy_data>:
     644:	11 e0       	ldi	r17, 0x01	; 1
     646:	a0 e0       	ldi	r26, 0x00	; 0
     648:	b1 e0       	ldi	r27, 0x01	; 1
     64a:	e6 e3       	ldi	r30, 0x36	; 54
     64c:	f5 e1       	ldi	r31, 0x15	; 21
     64e:	02 c0       	rjmp	.+4      	; 0x654 <__do_copy_data+0x10>
     650:	05 90       	lpm	r0, Z+
     652:	0d 92       	st	X+, r0
     654:	aa 3b       	cpi	r26, 0xBA	; 186
     656:	b1 07       	cpc	r27, r17
     658:	d9 f7       	brne	.-10     	; 0x650 <__do_copy_data+0xc>

0000065a <__do_clear_bss>:
     65a:	21 e0       	ldi	r18, 0x01	; 1
     65c:	aa eb       	ldi	r26, 0xBA	; 186
     65e:	b1 e0       	ldi	r27, 0x01	; 1
     660:	01 c0       	rjmp	.+2      	; 0x664 <.do_clear_bss_start>

00000662 <.do_clear_bss_loop>:
     662:	1d 92       	st	X+, r1

00000664 <.do_clear_bss_start>:
     664:	a9 3d       	cpi	r26, 0xD9	; 217
     666:	b2 07       	cpc	r27, r18
     668:	e1 f7       	brne	.-8      	; 0x662 <.do_clear_bss_loop>
     66a:	0e 94 73 03 	call	0x6e6	; 0x6e6 <main>
     66e:	0c 94 99 0a 	jmp	0x1532	; 0x1532 <_exit>

00000672 <__bad_interrupt>:
     672:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000676 <UART_Init>:
	setBit(UCSR0B, RXCIE0);
}

// Deaktiver avbrot for når data blir mottatt
void UART_DisableReceiveInterrupt(void) {
	clearBit(UCSR0B, RXCIE0);
     676:	90 bd       	out	0x20, r25	; 32
     678:	89 b9       	out	0x09, r24	; 9
     67a:	54 9a       	sbi	0x0a, 4	; 10
     67c:	53 9a       	sbi	0x0a, 3	; 10
     67e:	8e e8       	ldi	r24, 0x8E	; 142
     680:	80 bd       	out	0x20, r24	; 32
     682:	08 95       	ret

00000684 <UART_SendChar>:
     684:	5d 9b       	sbis	0x0b, 5	; 11
     686:	fe cf       	rjmp	.-4      	; 0x684 <UART_SendChar>
     688:	8c b9       	out	0x0c, r24	; 12
     68a:	08 95       	ret

0000068c <UART_putChar>:
     68c:	0e 94 42 03 	call	0x684	; 0x684 <UART_SendChar>
     690:	80 e0       	ldi	r24, 0x00	; 0
     692:	90 e0       	ldi	r25, 0x00	; 0
     694:	08 95       	ret

00000696 <UART_ReceiveChar>:
     696:	5f 9b       	sbis	0x0b, 7	; 11
     698:	fe cf       	rjmp	.-4      	; 0x696 <UART_ReceiveChar>
     69a:	8c b1       	in	r24, 0x0c	; 12
     69c:	08 95       	ret

0000069e <UART_getChar>:
     69e:	cf 93       	push	r28
     6a0:	0e 94 4b 03 	call	0x696	; 0x696 <UART_ReceiveChar>
     6a4:	c8 2f       	mov	r28, r24
     6a6:	0e 94 42 03 	call	0x684	; 0x684 <UART_SendChar>
     6aa:	8c 2f       	mov	r24, r28
     6ac:	90 e0       	ldi	r25, 0x00	; 0
     6ae:	cf 91       	pop	r28
     6b0:	08 95       	ret

000006b2 <URAT_initStudio>:
     6b2:	e3 ed       	ldi	r30, 0xD3	; 211
     6b4:	f1 e0       	ldi	r31, 0x01	; 1
     6b6:	8e e0       	ldi	r24, 0x0E	; 14
     6b8:	91 e0       	ldi	r25, 0x01	; 1
     6ba:	93 83       	std	Z+3, r25	; 0x03
     6bc:	82 83       	std	Z+2, r24	; 0x02
     6be:	80 e0       	ldi	r24, 0x00	; 0
     6c0:	91 e0       	ldi	r25, 0x01	; 1
     6c2:	91 83       	std	Z+1, r25	; 0x01
     6c4:	80 83       	st	Z, r24
     6c6:	08 95       	ret

000006c8 <UART_EnableReceiveInterrupt>:
     6c8:	57 9a       	sbi	0x0a, 7	; 10
     6ca:	08 95       	ret

000006cc <__vector_19>:
}

// UART mottaksavbrotvektor USART0_RX_vect
ISR(USART0_RXC_vect) {
     6cc:	1f 92       	push	r1
     6ce:	0f 92       	push	r0
     6d0:	0f b6       	in	r0, 0x3f	; 63
     6d2:	0f 92       	push	r0
     6d4:	11 24       	eor	r1, r1
     6d6:	8f 93       	push	r24
	// Handter mottatt data
	char received = UDR0;
     6d8:	8c b1       	in	r24, 0x0c	; 12
}
     6da:	8f 91       	pop	r24
     6dc:	0f 90       	pop	r0
     6de:	0f be       	out	0x3f, r0	; 63
     6e0:	0f 90       	pop	r0
     6e2:	1f 90       	pop	r1
     6e4:	18 95       	reti

000006e6 <main>:

#include "DriverUART.h"
#include "SRAM.h"
#include "Menu_init.h"

int main(void) {
     6e6:	cf 93       	push	r28
     6e8:	df 93       	push	r29
     6ea:	cd b7       	in	r28, 0x3d	; 61
     6ec:	de b7       	in	r29, 0x3e	; 62
     6ee:	2f 97       	sbiw	r28, 0x0f	; 15
     6f0:	0f b6       	in	r0, 0x3f	; 63
     6f2:	f8 94       	cli
     6f4:	de bf       	out	0x3e, r29	; 62
     6f6:	0f be       	out	0x3f, r0	; 63
     6f8:	cd bf       	out	0x3d, r28	; 61
	/*_________________INITIALISERINGER START______________________*/
	// Initialiser UART med baudrate 9600
	UART_Init(MYUBBR);
     6fa:	8f e1       	ldi	r24, 0x1F	; 31
     6fc:	90 e0       	ldi	r25, 0x00	; 0
     6fe:	0e 94 3b 03 	call	0x676	; 0x676 <UART_Init>
	URAT_initStudio();
     702:	0e 94 59 03 	call	0x6b2	; 0x6b2 <URAT_initStudio>
	UART_EnableReceiveInterrupt();
     706:	0e 94 64 03 	call	0x6c8	; 0x6c8 <UART_EnableReceiveInterrupt>
    setup_timer();						// Start millisekundteljinga
     70a:	0e 94 cf 09 	call	0x139e	; 0x139e <setup_timer>
	sei();								// Aktiver globale avbrot
     70e:	78 94       	sei
	externalMemoryInit();				// Initialiser eksternt minne må vere etter sei
     710:	0e 94 e2 09 	call	0x13c4	; 0x13c4 <externalMemoryInit>
	initialize_menus();
     714:	0e 94 c2 04 	call	0x984	; 0x984 <initialize_menus>
	MultiBoard board;
	MultiBoard_Init(&board);			// Initialiser MultiBoard og kalibrer joystickens origo
     718:	ce 01       	movw	r24, r28
     71a:	01 96       	adiw	r24, 0x01	; 1
     71c:	0e 94 79 05 	call	0xaf2	; 0xaf2 <MultiBoard_Init>
	oled_init();						// Initialiser OLED-skjermen
     720:	0e 94 8c 06 	call	0xd18	; 0xd18 <oled_init>
	//setup_printf_for_oled();			// Optional
	//SRAM_test();
	
	/*______MENY______*/
	current_menu = &mainMenu;
     724:	87 ec       	ldi	r24, 0xC7	; 199
     726:	91 e0       	ldi	r25, 0x01	; 1
     728:	90 93 bb 01 	sts	0x01BB, r25	; 0x8001bb <__data_end+0x1>
     72c:	80 93 ba 01 	sts	0x01BA, r24	; 0x8001ba <__data_end>
	

	/*_______TEST OLED______________________*/
	
	oled_home();
     730:	0e 94 85 06 	call	0xd0a	; 0xd0a <oled_home>
	oled_write_screen_to_SRAM(smiley);
     734:	80 e7       	ldi	r24, 0x70	; 112
     736:	90 e0       	ldi	r25, 0x00	; 0
     738:	0e 94 21 07 	call	0xe42	; 0xe42 <oled_write_screen_to_SRAM>
	oled_data_from_SRAM();
     73c:	0e 94 cf 06 	call	0xd9e	; 0xd9e <oled_data_from_SRAM>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     740:	2f ef       	ldi	r18, 0xFF	; 255
     742:	8f ef       	ldi	r24, 0xFF	; 255
     744:	9e e0       	ldi	r25, 0x0E	; 14
     746:	21 50       	subi	r18, 0x01	; 1
     748:	80 40       	sbci	r24, 0x00	; 0
     74a:	90 40       	sbci	r25, 0x00	; 0
     74c:	e1 f7       	brne	.-8      	; 0x746 <main+0x60>
     74e:	00 c0       	rjmp	.+0      	; 0x750 <main+0x6a>
     750:	00 00       	nop
	_delay_ms(1000); //smile litt før start
	
	//linje og slikt
	oled_clear_screen();
     752:	0e 94 75 08 	call	0x10ea	; 0x10ea <oled_clear_screen>
	oled_draw_line(10, 10, 100, 50);
     756:	22 e3       	ldi	r18, 0x32	; 50
     758:	44 e6       	ldi	r20, 0x64	; 100
     75a:	6a e0       	ldi	r22, 0x0A	; 10
     75c:	8a e0       	ldi	r24, 0x0A	; 10
     75e:	0e 94 93 08 	call	0x1126	; 0x1126 <oled_draw_line>
	oled_draw_circle(64, 32, 20);
     762:	44 e1       	ldi	r20, 0x14	; 20
     764:	50 e0       	ldi	r21, 0x00	; 0
     766:	60 e2       	ldi	r22, 0x20	; 32
     768:	70 e0       	ldi	r23, 0x00	; 0
     76a:	80 e4       	ldi	r24, 0x40	; 64
     76c:	90 e0       	ldi	r25, 0x00	; 0
     76e:	0e 94 f6 08 	call	0x11ec	; 0x11ec <oled_draw_circle>
	oled_draw_square(20, 20, 40, 30);
     772:	2e e1       	ldi	r18, 0x1E	; 30
     774:	48 e2       	ldi	r20, 0x28	; 40
     776:	64 e1       	ldi	r22, 0x14	; 20
     778:	84 e1       	ldi	r24, 0x14	; 20
     77a:	0e 94 66 09 	call	0x12cc	; 0x12cc <oled_draw_square>
	oled_data_from_SRAM();
     77e:	0e 94 cf 06 	call	0xd9e	; 0xd9e <oled_data_from_SRAM>
     782:	2f ef       	ldi	r18, 0xFF	; 255
     784:	8f ef       	ldi	r24, 0xFF	; 255
     786:	95 e9       	ldi	r25, 0x95	; 149
     788:	21 50       	subi	r18, 0x01	; 1
     78a:	80 40       	sbci	r24, 0x00	; 0
     78c:	90 40       	sbci	r25, 0x00	; 0
     78e:	e1 f7       	brne	.-8      	; 0x788 <main+0xa2>
     790:	00 c0       	rjmp	.+0      	; 0x792 <main+0xac>
     792:	00 00       	nop
	_delay_ms(10000);
	
	/*_______HOVUDLØKKE______*/
	 while (1) {

        menu_navigate(&board, &current_menu);  // Kallar `menu_navigate` med referanse til gjeldande meny
     794:	6a eb       	ldi	r22, 0xBA	; 186
     796:	71 e0       	ldi	r23, 0x01	; 1
     798:	ce 01       	movw	r24, r28
     79a:	01 96       	adiw	r24, 0x01	; 1
     79c:	0e 94 96 04 	call	0x92c	; 0x92c <menu_navigate>
		
		/*Så lenge vi ikkje har noko delay gåandes og ditta står her tenker eg 
		at den oppdateres automatisk med det minnet vi har skreve til sramen?
		Det kunne vert fornuftig med eit flag her då
		*/
		if (get_time_in_ms() >= 16) {
     7a0:	0e 94 c4 09 	call	0x1388	; 0x1388 <get_time_in_ms>
     7a4:	60 31       	cpi	r22, 0x10	; 16
     7a6:	71 05       	cpc	r23, r1
     7a8:	81 05       	cpc	r24, r1
     7aa:	91 05       	cpc	r25, r1
     7ac:	98 f3       	brcs	.-26     	; 0x794 <main+0xae>
			restart_timer();
     7ae:	0e 94 d7 09 	call	0x13ae	; 0x13ae <restart_timer>
			oled_data_from_SRAM();
     7b2:	0e 94 cf 06 	call	0xd9e	; 0xd9e <oled_data_from_SRAM>
     7b6:	ee cf       	rjmp	.-36     	; 0x794 <main+0xae>

000007b8 <oled_display_menu>:
}

// Sjekker om joystick-knappen er trykt
uint8_t is_joystick_button_pressed(MultiBoard* board) {
	return (board->JoyBtn != 0);  // Anta at knappen er aktiv-høg (1 betyr trykt)
}
     7b8:	cf 92       	push	r12
     7ba:	df 92       	push	r13
     7bc:	ef 92       	push	r14
     7be:	ff 92       	push	r15
     7c0:	1f 93       	push	r17
     7c2:	cf 93       	push	r28
     7c4:	df 93       	push	r29
     7c6:	cd b7       	in	r28, 0x3d	; 61
     7c8:	de b7       	in	r29, 0x3e	; 62
     7ca:	c0 59       	subi	r28, 0x90	; 144
     7cc:	d1 09       	sbc	r29, r1
     7ce:	0f b6       	in	r0, 0x3f	; 63
     7d0:	f8 94       	cli
     7d2:	de bf       	out	0x3e, r29	; 62
     7d4:	0f be       	out	0x3f, r0	; 63
     7d6:	cd bf       	out	0x3d, r28	; 61
     7d8:	6c 01       	movw	r12, r24
     7da:	fe 01       	movw	r30, r28
     7dc:	71 96       	adiw	r30, 0x11	; 17
     7de:	80 e8       	ldi	r24, 0x80	; 128
     7e0:	df 01       	movw	r26, r30
     7e2:	1d 92       	st	X+, r1
     7e4:	8a 95       	dec	r24
     7e6:	e9 f7       	brne	.-6      	; 0x7e2 <oled_display_menu+0x2a>
     7e8:	7f 01       	movw	r14, r30
     7ea:	10 e0       	ldi	r17, 0x00	; 0
     7ec:	f6 01       	movw	r30, r12
     7ee:	84 81       	ldd	r24, Z+4	; 0x04
     7f0:	81 0f       	add	r24, r17
     7f2:	95 81       	ldd	r25, Z+5	; 0x05
     7f4:	89 17       	cp	r24, r25
     7f6:	a8 f4       	brcc	.+42     	; 0x822 <oled_display_menu+0x6a>
     7f8:	60 81       	ld	r22, Z
     7fa:	71 81       	ldd	r23, Z+1	; 0x01
     7fc:	f0 e1       	ldi	r31, 0x10	; 16
     7fe:	8f 9f       	mul	r24, r31
     800:	60 0d       	add	r22, r0
     802:	71 1d       	adc	r23, r1
     804:	11 24       	eor	r1, r1
     806:	40 e1       	ldi	r20, 0x10	; 16
     808:	50 e0       	ldi	r21, 0x00	; 0
     80a:	ce 01       	movw	r24, r28
     80c:	01 96       	adiw	r24, 0x01	; 1
     80e:	0e 94 7b 0a 	call	0x14f6	; 0x14f6 <strncpy_P>
     812:	40 e1       	ldi	r20, 0x10	; 16
     814:	50 e0       	ldi	r21, 0x00	; 0
     816:	be 01       	movw	r22, r28
     818:	6f 5f       	subi	r22, 0xFF	; 255
     81a:	7f 4f       	sbci	r23, 0xFF	; 255
     81c:	c7 01       	movw	r24, r14
     81e:	0e 94 8a 0a 	call	0x1514	; 0x1514 <strncpy>
     822:	1f 5f       	subi	r17, 0xFF	; 255
     824:	80 e1       	ldi	r24, 0x10	; 16
     826:	e8 0e       	add	r14, r24
     828:	f1 1c       	adc	r15, r1
     82a:	18 30       	cpi	r17, 0x08	; 8
     82c:	f9 f6       	brne	.-66     	; 0x7ec <oled_display_menu+0x34>
     82e:	ce 01       	movw	r24, r28
     830:	41 96       	adiw	r24, 0x11	; 17
     832:	0e 94 21 07 	call	0xe42	; 0xe42 <oled_write_screen_to_SRAM>
     836:	d6 01       	movw	r26, r12
     838:	12 96       	adiw	r26, 0x02	; 2
     83a:	8c 91       	ld	r24, X
     83c:	12 97       	sbiw	r26, 0x02	; 2
     83e:	14 96       	adiw	r26, 0x04	; 4
     840:	9c 91       	ld	r25, X
     842:	4e e3       	ldi	r20, 0x3E	; 62
     844:	60 e0       	ldi	r22, 0x00	; 0
     846:	89 1b       	sub	r24, r25
     848:	0e 94 04 08 	call	0x1008	; 0x1008 <oled_write_char_to_SRAM>
     84c:	c0 57       	subi	r28, 0x70	; 112
     84e:	df 4f       	sbci	r29, 0xFF	; 255
     850:	0f b6       	in	r0, 0x3f	; 63
     852:	f8 94       	cli
     854:	de bf       	out	0x3e, r29	; 62
     856:	0f be       	out	0x3f, r0	; 63
     858:	cd bf       	out	0x3d, r28	; 61
     85a:	df 91       	pop	r29
     85c:	cf 91       	pop	r28
     85e:	1f 91       	pop	r17
     860:	ff 90       	pop	r15
     862:	ef 90       	pop	r14
     864:	df 90       	pop	r13
     866:	cf 90       	pop	r12
     868:	08 95       	ret

0000086a <update_menu_arrows>:
     86a:	cf 93       	push	r28
     86c:	c8 2f       	mov	r28, r24
     86e:	86 2f       	mov	r24, r22
     870:	40 e2       	ldi	r20, 0x20	; 32
     872:	60 e0       	ldi	r22, 0x00	; 0
     874:	0e 94 04 08 	call	0x1008	; 0x1008 <oled_write_char_to_SRAM>
     878:	4e e3       	ldi	r20, 0x3E	; 62
     87a:	60 e0       	ldi	r22, 0x00	; 0
     87c:	8c 2f       	mov	r24, r28
     87e:	0e 94 04 08 	call	0x1008	; 0x1008 <oled_write_char_to_SRAM>
     882:	cf 91       	pop	r28
     884:	08 95       	ret

00000886 <update_menu_position_from_joystick>:
     886:	fb 01       	movw	r30, r22
     888:	dc 01       	movw	r26, r24
     88a:	1b 96       	adiw	r26, 0x0b	; 11
     88c:	8d 91       	ld	r24, X+
     88e:	9c 91       	ld	r25, X
     890:	1c 97       	sbiw	r26, 0x0c	; 12
     892:	83 33       	cpi	r24, 0x33	; 51
     894:	91 05       	cpc	r25, r1
     896:	fc f0       	brlt	.+62     	; 0x8d6 <update_menu_position_from_joystick+0x50>
     898:	62 81       	ldd	r22, Z+2	; 0x02
     89a:	66 23       	and	r22, r22
     89c:	09 f4       	brne	.+2      	; 0x8a0 <update_menu_position_from_joystick+0x1a>
     89e:	45 c0       	rjmp	.+138    	; 0x92a <update_menu_position_from_joystick+0xa4>
     8a0:	63 83       	std	Z+3, r22	; 0x03
     8a2:	8f ef       	ldi	r24, 0xFF	; 255
     8a4:	86 0f       	add	r24, r22
     8a6:	82 83       	std	Z+2, r24	; 0x02
     8a8:	94 81       	ldd	r25, Z+4	; 0x04
     8aa:	89 17       	cp	r24, r25
     8ac:	30 f4       	brcc	.+12     	; 0x8ba <update_menu_position_from_joystick+0x34>
     8ae:	91 50       	subi	r25, 0x01	; 1
     8b0:	94 83       	std	Z+4, r25	; 0x04
     8b2:	cf 01       	movw	r24, r30
     8b4:	0e 94 dc 03 	call	0x7b8	; 0x7b8 <oled_display_menu>
     8b8:	04 c0       	rjmp	.+8      	; 0x8c2 <update_menu_position_from_joystick+0x3c>
     8ba:	69 1b       	sub	r22, r25
     8bc:	89 1b       	sub	r24, r25
     8be:	0e 94 35 04 	call	0x86a	; 0x86a <update_menu_arrows>
     8c2:	bf ef       	ldi	r27, 0xFF	; 255
     8c4:	2f ef       	ldi	r18, 0xFF	; 255
     8c6:	82 e0       	ldi	r24, 0x02	; 2
     8c8:	b1 50       	subi	r27, 0x01	; 1
     8ca:	20 40       	sbci	r18, 0x00	; 0
     8cc:	80 40       	sbci	r24, 0x00	; 0
     8ce:	e1 f7       	brne	.-8      	; 0x8c8 <update_menu_position_from_joystick+0x42>
     8d0:	00 c0       	rjmp	.+0      	; 0x8d2 <update_menu_position_from_joystick+0x4c>
     8d2:	00 c0       	rjmp	.+0      	; 0x8d4 <update_menu_position_from_joystick+0x4e>
     8d4:	08 95       	ret
     8d6:	8e 3c       	cpi	r24, 0xCE	; 206
     8d8:	9f 4f       	sbci	r25, 0xFF	; 255
     8da:	3c f5       	brge	.+78     	; 0x92a <update_menu_position_from_joystick+0xa4>
     8dc:	62 81       	ldd	r22, Z+2	; 0x02
     8de:	26 2f       	mov	r18, r22
     8e0:	30 e0       	ldi	r19, 0x00	; 0
     8e2:	85 81       	ldd	r24, Z+5	; 0x05
     8e4:	90 e0       	ldi	r25, 0x00	; 0
     8e6:	01 97       	sbiw	r24, 0x01	; 1
     8e8:	28 17       	cp	r18, r24
     8ea:	39 07       	cpc	r19, r25
     8ec:	f4 f4       	brge	.+60     	; 0x92a <update_menu_position_from_joystick+0xa4>
     8ee:	63 83       	std	Z+3, r22	; 0x03
     8f0:	81 e0       	ldi	r24, 0x01	; 1
     8f2:	86 0f       	add	r24, r22
     8f4:	82 83       	std	Z+2, r24	; 0x02
     8f6:	94 81       	ldd	r25, Z+4	; 0x04
     8f8:	48 2f       	mov	r20, r24
     8fa:	50 e0       	ldi	r21, 0x00	; 0
     8fc:	29 2f       	mov	r18, r25
     8fe:	30 e0       	ldi	r19, 0x00	; 0
     900:	28 5f       	subi	r18, 0xF8	; 248
     902:	3f 4f       	sbci	r19, 0xFF	; 255
     904:	42 17       	cp	r20, r18
     906:	53 07       	cpc	r21, r19
     908:	1c f0       	brlt	.+6      	; 0x910 <update_menu_position_from_joystick+0x8a>
     90a:	9f 5f       	subi	r25, 0xFF	; 255
     90c:	94 83       	std	Z+4, r25	; 0x04
     90e:	04 c0       	rjmp	.+8      	; 0x918 <update_menu_position_from_joystick+0x92>
     910:	69 1b       	sub	r22, r25
     912:	89 1b       	sub	r24, r25
     914:	0e 94 35 04 	call	0x86a	; 0x86a <update_menu_arrows>
     918:	bf ef       	ldi	r27, 0xFF	; 255
     91a:	2f ef       	ldi	r18, 0xFF	; 255
     91c:	82 e0       	ldi	r24, 0x02	; 2
     91e:	b1 50       	subi	r27, 0x01	; 1
     920:	20 40       	sbci	r18, 0x00	; 0
     922:	80 40       	sbci	r24, 0x00	; 0
     924:	e1 f7       	brne	.-8      	; 0x91e <update_menu_position_from_joystick+0x98>
     926:	00 c0       	rjmp	.+0      	; 0x928 <update_menu_position_from_joystick+0xa2>
     928:	00 c0       	rjmp	.+0      	; 0x92a <update_menu_position_from_joystick+0xa4>
     92a:	08 95       	ret

0000092c <menu_navigate>:

static uint8_t menu_changed = 1;  // Flag for å spore endringar i menyen
// Funksjon for å navigere i menyen uten blokkering
void menu_navigate(MultiBoard* board, Menu** menu) {
     92c:	0f 93       	push	r16
     92e:	1f 93       	push	r17
     930:	cf 93       	push	r28
     932:	df 93       	push	r29
     934:	ec 01       	movw	r28, r24
     936:	8b 01       	movw	r16, r22

	// Oppdater joystick- og menyposisjon
	MultiBoard_Update(board);
     938:	0e 94 0f 06 	call	0xc1e	; 0xc1e <MultiBoard_Update>
	update_menu_position_from_joystick(board, *menu);
     93c:	f8 01       	movw	r30, r16
     93e:	60 81       	ld	r22, Z
     940:	71 81       	ldd	r23, Z+1	; 0x01
     942:	ce 01       	movw	r24, r28
     944:	0e 94 43 04 	call	0x886	; 0x886 <update_menu_position_from_joystick>

	// Sjekk om menyen har endra seg
	if (menu_changed) {
     948:	80 91 1c 01 	lds	r24, 0x011C	; 0x80011c <menu_changed>
     94c:	88 23       	and	r24, r24
     94e:	39 f0       	breq	.+14     	; 0x95e <menu_navigate+0x32>
		oled_display_menu(*menu);  // Oppdater OLED med den nye menyen
     950:	f8 01       	movw	r30, r16
     952:	80 81       	ld	r24, Z
     954:	91 81       	ldd	r25, Z+1	; 0x01
     956:	0e 94 dc 03 	call	0x7b8	; 0x7b8 <oled_display_menu>
		menu_changed = 0;  // Nullstill flagget etter oppdatering
     95a:	10 92 1c 01 	sts	0x011C, r1	; 0x80011c <menu_changed>
	}

	// Sjekk om knappen er trykt for å bekrefte menyval
	if (is_joystick_button_pressed(board)) {
     95e:	8e 81       	ldd	r24, Y+6	; 0x06
     960:	88 23       	and	r24, r24
     962:	59 f0       	breq	.+22     	; 0x97a <menu_navigate+0x4e>
		oled_clear_screen();
     964:	0e 94 75 08 	call	0x10ea	; 0x10ea <oled_clear_screen>
		handleMenuSelection(board, *menu);  // Behandlar menyvalet
     968:	f8 01       	movw	r30, r16
     96a:	60 81       	ld	r22, Z
     96c:	71 81       	ldd	r23, Z+1	; 0x01
     96e:	ce 01       	movw	r24, r28
     970:	0e 94 e4 04 	call	0x9c8	; 0x9c8 <handleMenuSelection>
		menu_changed = 1;  // Menyen vil endre seg etter valet
     974:	81 e0       	ldi	r24, 0x01	; 1
     976:	80 93 1c 01 	sts	0x011C, r24	; 0x80011c <menu_changed>
	}
}
     97a:	df 91       	pop	r29
     97c:	cf 91       	pop	r28
     97e:	1f 91       	pop	r17
     980:	0f 91       	pop	r16
     982:	08 95       	ret

00000984 <initialize_menus>:
Menu mainMenu;
Menu scrollMenu;
Menu settingsMenu;

void initialize_menus() {
	mainMenu.items = mainMenuItems;
     984:	e7 ec       	ldi	r30, 0xC7	; 199
     986:	f1 e0       	ldi	r31, 0x01	; 1
     988:	88 ee       	ldi	r24, 0xE8	; 232
     98a:	95 e0       	ldi	r25, 0x05	; 5
     98c:	91 83       	std	Z+1, r25	; 0x01
     98e:	80 83       	st	Z, r24
	mainMenu.num_items = 5;
     990:	85 e0       	ldi	r24, 0x05	; 5
     992:	85 83       	std	Z+5, r24	; 0x05
	mainMenu.current_position = 0;
     994:	12 82       	std	Z+2, r1	; 0x02
	mainMenu.prev_position = 0;
     996:	13 82       	std	Z+3, r1	; 0x03
	mainMenu.scroll_offset = 0;
     998:	14 82       	std	Z+4, r1	; 0x04

	scrollMenu.items = scrollMenuItems;
     99a:	ed ec       	ldi	r30, 0xCD	; 205
     99c:	f1 e0       	ldi	r31, 0x01	; 1
     99e:	88 ea       	ldi	r24, 0xA8	; 168
     9a0:	94 e0       	ldi	r25, 0x04	; 4
     9a2:	91 83       	std	Z+1, r25	; 0x01
     9a4:	80 83       	st	Z, r24
	scrollMenu.num_items = 20;
     9a6:	84 e1       	ldi	r24, 0x14	; 20
     9a8:	85 83       	std	Z+5, r24	; 0x05
	scrollMenu.current_position = 0;
     9aa:	12 82       	std	Z+2, r1	; 0x02
	scrollMenu.prev_position = 0;
     9ac:	13 82       	std	Z+3, r1	; 0x03
	scrollMenu.scroll_offset = 0;
     9ae:	14 82       	std	Z+4, r1	; 0x04

	settingsMenu.items = settingsMenuItems;
     9b0:	e1 ec       	ldi	r30, 0xC1	; 193
     9b2:	f1 e0       	ldi	r31, 0x01	; 1
     9b4:	88 e6       	ldi	r24, 0x68	; 104
     9b6:	94 e0       	ldi	r25, 0x04	; 4
     9b8:	91 83       	std	Z+1, r25	; 0x01
     9ba:	80 83       	st	Z, r24
	settingsMenu.num_items = 4;
     9bc:	84 e0       	ldi	r24, 0x04	; 4
     9be:	85 83       	std	Z+5, r24	; 0x05
	settingsMenu.current_position = 0;
     9c0:	12 82       	std	Z+2, r1	; 0x02
	settingsMenu.prev_position = 0;
     9c2:	13 82       	std	Z+3, r1	; 0x03
	settingsMenu.scroll_offset = 0;
     9c4:	14 82       	std	Z+4, r1	; 0x04
     9c6:	08 95       	ret

000009c8 <handleMenuSelection>:
}

void handleMenuSelection(MultiBoard* board, Menu* menu) {
	switch (currentMenuState) {
     9c8:	80 91 bc 01 	lds	r24, 0x01BC	; 0x8001bc <currentMenuState>
     9cc:	81 30       	cpi	r24, 0x01	; 1
     9ce:	09 f4       	brne	.+2      	; 0x9d2 <handleMenuSelection+0xa>
     9d0:	6f c0       	rjmp	.+222    	; 0xab0 <handleMenuSelection+0xe8>
     9d2:	20 f0       	brcs	.+8      	; 0x9dc <handleMenuSelection+0x14>
     9d4:	82 30       	cpi	r24, 0x02	; 2
     9d6:	09 f4       	brne	.+2      	; 0x9da <handleMenuSelection+0x12>
     9d8:	40 c0       	rjmp	.+128    	; 0xa5a <handleMenuSelection+0x92>
     9da:	08 95       	ret
		case MAIN_MENU:
		switch (menu->current_position) {
     9dc:	fb 01       	movw	r30, r22
     9de:	82 81       	ldd	r24, Z+2	; 0x02
     9e0:	82 30       	cpi	r24, 0x02	; 2
     9e2:	d9 f0       	breq	.+54     	; 0xa1a <handleMenuSelection+0x52>
     9e4:	28 f4       	brcc	.+10     	; 0x9f0 <handleMenuSelection+0x28>
     9e6:	88 23       	and	r24, r24
     9e8:	41 f0       	breq	.+16     	; 0x9fa <handleMenuSelection+0x32>
     9ea:	81 30       	cpi	r24, 0x01	; 1
     9ec:	61 f0       	breq	.+24     	; 0xa06 <handleMenuSelection+0x3e>
     9ee:	2f c0       	rjmp	.+94     	; 0xa4e <handleMenuSelection+0x86>
     9f0:	83 30       	cpi	r24, 0x03	; 3
     9f2:	e9 f0       	breq	.+58     	; 0xa2e <handleMenuSelection+0x66>
     9f4:	84 30       	cpi	r24, 0x04	; 4
     9f6:	29 f1       	breq	.+74     	; 0xa42 <handleMenuSelection+0x7a>
     9f8:	2a c0       	rjmp	.+84     	; 0xa4e <handleMenuSelection+0x86>
			case 0:
			oled_write_line_to_SRAM(0, "Startar spelet...");
     9fa:	6d e1       	ldi	r22, 0x1D	; 29
     9fc:	71 e0       	ldi	r23, 0x01	; 1
     9fe:	80 e0       	ldi	r24, 0x00	; 0
     a00:	0e 94 8c 07 	call	0xf18	; 0xf18 <oled_write_line_to_SRAM>
			break;
     a04:	08 95       	ret
			case 1:
			// Gå til innstillingar
			currentMenuState = SETTINGS_MENU;
     a06:	82 e0       	ldi	r24, 0x02	; 2
     a08:	80 93 bc 01 	sts	0x01BC, r24	; 0x8001bc <currentMenuState>
			current_menu = &settingsMenu;  // Oppdater til innstillingsmeny
     a0c:	81 ec       	ldi	r24, 0xC1	; 193
     a0e:	91 e0       	ldi	r25, 0x01	; 1
     a10:	90 93 bb 01 	sts	0x01BB, r25	; 0x8001bb <__data_end+0x1>
     a14:	80 93 ba 01 	sts	0x01BA, r24	; 0x8001ba <__data_end>
			break;
     a18:	08 95       	ret
			case 2:
			// Gå til scrollemeny
			currentMenuState = SCROLL_MENU;
     a1a:	81 e0       	ldi	r24, 0x01	; 1
     a1c:	80 93 bc 01 	sts	0x01BC, r24	; 0x8001bc <currentMenuState>
			current_menu = &scrollMenu;  // Oppdater til scrollemeny
     a20:	8d ec       	ldi	r24, 0xCD	; 205
     a22:	91 e0       	ldi	r25, 0x01	; 1
     a24:	90 93 bb 01 	sts	0x01BB, r25	; 0x8001bb <__data_end+0x1>
     a28:	80 93 ba 01 	sts	0x01BA, r24	; 0x8001ba <__data_end>
			break;
     a2c:	08 95       	ret
			case 3:
			oled_write_line_to_SRAM(0, "Viser kredittar...");
     a2e:	6f e2       	ldi	r22, 0x2F	; 47
     a30:	71 e0       	ldi	r23, 0x01	; 1
     a32:	80 e0       	ldi	r24, 0x00	; 0
     a34:	0e 94 8c 07 	call	0xf18	; 0xf18 <oled_write_line_to_SRAM>
			oled_write_screen_to_SRAM(solkors);  // Vis kredittar på skjermen
     a38:	80 ef       	ldi	r24, 0xF0	; 240
     a3a:	90 e0       	ldi	r25, 0x00	; 0
     a3c:	0e 94 21 07 	call	0xe42	; 0xe42 <oled_write_screen_to_SRAM>
			break;
     a40:	08 95       	ret
			case 4:
			oled_write_line_to_SRAM(0, "Avsluttar...");
     a42:	62 e4       	ldi	r22, 0x42	; 66
     a44:	71 e0       	ldi	r23, 0x01	; 1
     a46:	80 e0       	ldi	r24, 0x00	; 0
     a48:	0e 94 8c 07 	call	0xf18	; 0xf18 <oled_write_line_to_SRAM>
			// Legg eventuelt til funksjonalitet for å avslutte
			break;
     a4c:	08 95       	ret
			default:
			oled_write_line_to_SRAM(0, "Ugyldig valg");
     a4e:	6f e4       	ldi	r22, 0x4F	; 79
     a50:	71 e0       	ldi	r23, 0x01	; 1
     a52:	80 e0       	ldi	r24, 0x00	; 0
     a54:	0e 94 8c 07 	call	0xf18	; 0xf18 <oled_write_line_to_SRAM>
			break;
     a58:	08 95       	ret
		}
		break;

		case SETTINGS_MENU:
		// Håndter valg i innstillingsmenyen
		switch (menu->current_position) {
     a5a:	fb 01       	movw	r30, r22
     a5c:	82 81       	ldd	r24, Z+2	; 0x02
     a5e:	81 30       	cpi	r24, 0x01	; 1
     a60:	61 f0       	breq	.+24     	; 0xa7a <handleMenuSelection+0xb2>
     a62:	28 f0       	brcs	.+10     	; 0xa6e <handleMenuSelection+0xa6>
     a64:	82 30       	cpi	r24, 0x02	; 2
     a66:	79 f0       	breq	.+30     	; 0xa86 <handleMenuSelection+0xbe>
     a68:	83 30       	cpi	r24, 0x03	; 3
     a6a:	99 f0       	breq	.+38     	; 0xa92 <handleMenuSelection+0xca>
     a6c:	1b c0       	rjmp	.+54     	; 0xaa4 <handleMenuSelection+0xdc>
			case 0:
			oled_write_line_to_SRAM(0, "Endrer lydinnstillingar...");
     a6e:	6c e5       	ldi	r22, 0x5C	; 92
     a70:	71 e0       	ldi	r23, 0x01	; 1
     a72:	80 e0       	ldi	r24, 0x00	; 0
     a74:	0e 94 8c 07 	call	0xf18	; 0xf18 <oled_write_line_to_SRAM>
			break;
     a78:	08 95       	ret
			case 1:
			oled_write_line_to_SRAM(0, "Endrer lysstyrke...");
     a7a:	67 e7       	ldi	r22, 0x77	; 119
     a7c:	71 e0       	ldi	r23, 0x01	; 1
     a7e:	80 e0       	ldi	r24, 0x00	; 0
     a80:	0e 94 8c 07 	call	0xf18	; 0xf18 <oled_write_line_to_SRAM>
			break;
     a84:	08 95       	ret
			case 2:
			oled_write_line_to_SRAM(0, "Endrer kontrollar...");
     a86:	6b e8       	ldi	r22, 0x8B	; 139
     a88:	71 e0       	ldi	r23, 0x01	; 1
     a8a:	80 e0       	ldi	r24, 0x00	; 0
     a8c:	0e 94 8c 07 	call	0xf18	; 0xf18 <oled_write_line_to_SRAM>
			break;
     a90:	08 95       	ret
			case 3:
			// Gå tilbake til hovudmenyen
			currentMenuState = MAIN_MENU;
     a92:	10 92 bc 01 	sts	0x01BC, r1	; 0x8001bc <currentMenuState>
			current_menu = &mainMenu;
     a96:	87 ec       	ldi	r24, 0xC7	; 199
     a98:	91 e0       	ldi	r25, 0x01	; 1
     a9a:	90 93 bb 01 	sts	0x01BB, r25	; 0x8001bb <__data_end+0x1>
     a9e:	80 93 ba 01 	sts	0x01BA, r24	; 0x8001ba <__data_end>
			break;
     aa2:	08 95       	ret
			default:
			oled_write_line_to_SRAM(0, "Ugyldig valg");
     aa4:	6f e4       	ldi	r22, 0x4F	; 79
     aa6:	71 e0       	ldi	r23, 0x01	; 1
     aa8:	80 e0       	ldi	r24, 0x00	; 0
     aaa:	0e 94 8c 07 	call	0xf18	; 0xf18 <oled_write_line_to_SRAM>
			break;
     aae:	08 95       	ret
		}
		break;

		case SCROLL_MENU:
		// Håndter valg i scrollemenyen
		switch (menu->current_position) {
     ab0:	fb 01       	movw	r30, r22
     ab2:	82 81       	ldd	r24, Z+2	; 0x02
     ab4:	88 23       	and	r24, r24
     ab6:	19 f0       	breq	.+6      	; 0xabe <handleMenuSelection+0xf6>
     ab8:	81 30       	cpi	r24, 0x01	; 1
     aba:	79 f0       	breq	.+30     	; 0xada <handleMenuSelection+0x112>
     abc:	14 c0       	rjmp	.+40     	; 0xae6 <handleMenuSelection+0x11e>
			case 0:
			oled_write_line_to_SRAM(0, "Item 1 valgt");
     abe:	60 ea       	ldi	r22, 0xA0	; 160
     ac0:	71 e0       	ldi	r23, 0x01	; 1
     ac2:	80 e0       	ldi	r24, 0x00	; 0
     ac4:	0e 94 8c 07 	call	0xf18	; 0xf18 <oled_write_line_to_SRAM>
			currentMenuState = MAIN_MENU;
     ac8:	10 92 bc 01 	sts	0x01BC, r1	; 0x8001bc <currentMenuState>
			current_menu = &mainMenu;
     acc:	87 ec       	ldi	r24, 0xC7	; 199
     ace:	91 e0       	ldi	r25, 0x01	; 1
     ad0:	90 93 bb 01 	sts	0x01BB, r25	; 0x8001bb <__data_end+0x1>
     ad4:	80 93 ba 01 	sts	0x01BA, r24	; 0x8001ba <__data_end>
			break;
     ad8:	08 95       	ret
			case 1:
			oled_write_line_to_SRAM(0, "Item 2 valgt");
     ada:	6d ea       	ldi	r22, 0xAD	; 173
     adc:	71 e0       	ldi	r23, 0x01	; 1
     ade:	80 e0       	ldi	r24, 0x00	; 0
     ae0:	0e 94 8c 07 	call	0xf18	; 0xf18 <oled_write_line_to_SRAM>
			break;
     ae4:	08 95       	ret
			default:
			oled_write_line_to_SRAM(0, "Ugyldig valg");
     ae6:	6f e4       	ldi	r22, 0x4F	; 79
     ae8:	71 e0       	ldi	r23, 0x01	; 1
     aea:	80 e0       	ldi	r24, 0x00	; 0
     aec:	0e 94 8c 07 	call	0xf18	; 0xf18 <oled_write_line_to_SRAM>
     af0:	08 95       	ret

00000af2 <MultiBoard_Init>:
 * Created: 14.09.2024 11:00:59
 *  Author: ravneb
 */ 
#include "MultiBoard.h"

void MultiBoard_Init(MultiBoard* board) {
     af2:	cf 93       	push	r28
     af4:	df 93       	push	r29
     af6:	ec 01       	movw	r28, r24
	// Set pinner for knapper som input
	clearBit(DDRB, LEFT_BUTTON_PIN);  // Set Left button pin as input
     af8:	bc 98       	cbi	0x17, 4	; 23
	clearBit(DDRB, RIGHT_BUTTON_PIN); // Set Right button pin as input
     afa:	bb 98       	cbi	0x17, 3	; 23
	clearBit(DDRB, JOY_BUTTON_PIN);   // Set Joystick button pin as input
     afc:	ba 98       	cbi	0x17, 2	; 23
	clearBit(DDRB, BUSY_PIN);         // Set BUSY pin as input
     afe:	b9 98       	cbi	0x17, 1	; 23
	
	// Aktiver pullup
	setBit(PORTB, JOY_BUTTON_PIN);
     b00:	c2 9a       	sbi	0x18, 2	; 24
	

	// Kalibrer joysticken (finn origo)
	Universal_write(ADC_START, 0x80); // For Chip Enable til ADC, (data her er irrelevant)
     b02:	60 e8       	ldi	r22, 0x80	; 128
     b04:	80 e0       	ldi	r24, 0x00	; 0
     b06:	94 e1       	ldi	r25, 0x14	; 20
     b08:	0e 94 11 0a 	call	0x1422	; 0x1422 <Universal_write>
	loopUntilBitIsClear(PINB, BUSY_PIN);    // Vent til BUSY gï¿½r lav
     b0c:	b1 99       	sbic	0x16, 1	; 22
     b0e:	fe cf       	rjmp	.-4      	; 0xb0c <MultiBoard_Init+0x1a>
	board->JoyYOrigo = Universal_read(ADC_START); //CH0
     b10:	80 e0       	ldi	r24, 0x00	; 0
     b12:	94 e1       	ldi	r25, 0x14	; 20
     b14:	0e 94 21 0a 	call	0x1442	; 0x1442 <Universal_read>
     b18:	88 87       	std	Y+8, r24	; 0x08
	board->JoyXOrigo = Universal_read(ADC_START); //CH1
     b1a:	80 e0       	ldi	r24, 0x00	; 0
     b1c:	94 e1       	ldi	r25, 0x14	; 20
     b1e:	0e 94 21 0a 	call	0x1442	; 0x1442 <Universal_read>
     b22:	8f 83       	std	Y+7, r24	; 0x07
	
	// Initialiser alle andre verdier
	board->LSpos = 0;
     b24:	1a 82       	std	Y+2, r1	; 0x02
	board->RSpos = 0;
     b26:	1b 82       	std	Y+3, r1	; 0x03
	board->LBtn = 0;
     b28:	1c 82       	std	Y+4, r1	; 0x04
	board->RBtn = 0;
     b2a:	1d 82       	std	Y+5, r1	; 0x05
	board->JoyXpos = 0;
     b2c:	19 82       	std	Y+1, r1	; 0x01
	board->JoyYpos = 0;
     b2e:	18 82       	st	Y, r1
	board->JoyXposCal = 0;
     b30:	1a 86       	std	Y+10, r1	; 0x0a
     b32:	19 86       	std	Y+9, r1	; 0x09
	board->JoyYposCal = 0;
     b34:	1c 86       	std	Y+12, r1	; 0x0c
     b36:	1b 86       	std	Y+11, r1	; 0x0b
	board->JoyAngle = 0;
     b38:	1e 86       	std	Y+14, r1	; 0x0e
     b3a:	1d 86       	std	Y+13, r1	; 0x0d
	board->JoyBtn = 0;  // Endra fra en, vi bruker fortsatt 0 for av basert pÃ¥ logikk i MB_Update()
     b3c:	1e 82       	std	Y+6, r1	; 0x06
}
     b3e:	df 91       	pop	r29
     b40:	cf 91       	pop	r28
     b42:	08 95       	ret

00000b44 <MultiBoard_UpdateJoystickAngle>:
	///IKKJE TESTA
	MultiBoard_UpdateJoystickAngle(board);
}

/// IKKJE TESTA 
void MultiBoard_UpdateJoystickAngle(MultiBoard* board) {
     b44:	fc 01       	movw	r30, r24
	int16_t x = board->JoyXposCal;
     b46:	61 85       	ldd	r22, Z+9	; 0x09
     b48:	72 85       	ldd	r23, Z+10	; 0x0a
	int16_t y = board->JoyYposCal;
     b4a:	43 85       	ldd	r20, Z+11	; 0x0b
     b4c:	54 85       	ldd	r21, Z+12	; 0x0c

	// Unngï¿½ divisjon med 0 (nï¿½r senterpunkt) + hysterese
	if (!(abs(x) > JOY_ANGLE_HYSTERESIS || abs(y) >  JOY_ANGLE_HYSTERESIS)) {
     b4e:	cb 01       	movw	r24, r22
     b50:	05 96       	adiw	r24, 0x05	; 5
     b52:	0b 97       	sbiw	r24, 0x0b	; 11
     b54:	38 f4       	brcc	.+14     	; 0xb64 <MultiBoard_UpdateJoystickAngle+0x20>
     b56:	ca 01       	movw	r24, r20
     b58:	05 96       	adiw	r24, 0x05	; 5
     b5a:	0b 97       	sbiw	r24, 0x0b	; 11
     b5c:	18 f4       	brcc	.+6      	; 0xb64 <MultiBoard_UpdateJoystickAngle+0x20>
		board->JoyAngle = 0;  // Midtpunkt, sett vinkelen til 0
     b5e:	16 86       	std	Z+14, r1	; 0x0e
     b60:	15 86       	std	Z+13, r1	; 0x0d
     b62:	08 95       	ret
		} else {
		// Bestem kvadrant basert pï¿½ verdiane til x og y
		switch ((x >= 0) << 1 | (y >= 0)) {
     b64:	87 2f       	mov	r24, r23
     b66:	80 95       	com	r24
     b68:	88 1f       	adc	r24, r24
     b6a:	88 27       	eor	r24, r24
     b6c:	88 1f       	adc	r24, r24
     b6e:	90 e0       	ldi	r25, 0x00	; 0
     b70:	88 0f       	add	r24, r24
     b72:	99 1f       	adc	r25, r25
     b74:	25 2f       	mov	r18, r21
     b76:	20 95       	com	r18
     b78:	22 1f       	adc	r18, r18
     b7a:	22 27       	eor	r18, r18
     b7c:	22 1f       	adc	r18, r18
     b7e:	82 2b       	or	r24, r18
     b80:	81 30       	cpi	r24, 0x01	; 1
     b82:	91 05       	cpc	r25, r1
     b84:	b9 f0       	breq	.+46     	; 0xbb4 <MultiBoard_UpdateJoystickAngle+0x70>
     b86:	1c f4       	brge	.+6      	; 0xb8e <MultiBoard_UpdateJoystickAngle+0x4a>
     b88:	89 2b       	or	r24, r25
     b8a:	29 f1       	breq	.+74     	; 0xbd6 <MultiBoard_UpdateJoystickAngle+0x92>
     b8c:	45 c0       	rjmp	.+138    	; 0xc18 <MultiBoard_UpdateJoystickAngle+0xd4>
     b8e:	82 30       	cpi	r24, 0x02	; 2
     b90:	91 05       	cpc	r25, r1
     b92:	99 f1       	breq	.+102    	; 0xbfa <MultiBoard_UpdateJoystickAngle+0xb6>
     b94:	03 97       	sbiw	r24, 0x03	; 3
     b96:	09 f0       	breq	.+2      	; 0xb9a <MultiBoard_UpdateJoystickAngle+0x56>
     b98:	3f c0       	rjmp	.+126    	; 0xc18 <MultiBoard_UpdateJoystickAngle+0xd4>
			case 0b11:  // Fï¿½rste kvadrant (x >= 0, y >= 0)
			board->JoyAngle = (y * 90) / (x + y);
     b9a:	2a e5       	ldi	r18, 0x5A	; 90
     b9c:	24 9f       	mul	r18, r20
     b9e:	c0 01       	movw	r24, r0
     ba0:	25 9f       	mul	r18, r21
     ba2:	90 0d       	add	r25, r0
     ba4:	11 24       	eor	r1, r1
     ba6:	64 0f       	add	r22, r20
     ba8:	75 1f       	adc	r23, r21
     baa:	0e 94 31 0a 	call	0x1462	; 0x1462 <__divmodhi4>
     bae:	76 87       	std	Z+14, r23	; 0x0e
     bb0:	65 87       	std	Z+13, r22	; 0x0d
			break;
     bb2:	08 95       	ret
			case 0b01:  // Andre kvadrant (x < 0, y >= 0)
			board->JoyAngle = 90 + ((-x * 90) / (-x + y));
     bb4:	26 ea       	ldi	r18, 0xA6	; 166
     bb6:	26 03       	mulsu	r18, r22
     bb8:	c0 01       	movw	r24, r0
     bba:	27 9f       	mul	r18, r23
     bbc:	90 0d       	add	r25, r0
     bbe:	11 24       	eor	r1, r1
     bc0:	9a 01       	movw	r18, r20
     bc2:	26 1b       	sub	r18, r22
     bc4:	37 0b       	sbc	r19, r23
     bc6:	b9 01       	movw	r22, r18
     bc8:	0e 94 31 0a 	call	0x1462	; 0x1462 <__divmodhi4>
     bcc:	66 5a       	subi	r22, 0xA6	; 166
     bce:	7f 4f       	sbci	r23, 0xFF	; 255
     bd0:	76 87       	std	Z+14, r23	; 0x0e
     bd2:	65 87       	std	Z+13, r22	; 0x0d
			break;
     bd4:	08 95       	ret
			case 0b00:  // Tredje kvadrant (x < 0, y < 0)
			board->JoyAngle = 180 + ((-y * 90) / (-x - y));
     bd6:	26 ea       	ldi	r18, 0xA6	; 166
     bd8:	24 03       	mulsu	r18, r20
     bda:	c0 01       	movw	r24, r0
     bdc:	25 9f       	mul	r18, r21
     bde:	90 0d       	add	r25, r0
     be0:	11 24       	eor	r1, r1
     be2:	71 95       	neg	r23
     be4:	61 95       	neg	r22
     be6:	71 09       	sbc	r23, r1
     be8:	64 1b       	sub	r22, r20
     bea:	75 0b       	sbc	r23, r21
     bec:	0e 94 31 0a 	call	0x1462	; 0x1462 <__divmodhi4>
     bf0:	6c 54       	subi	r22, 0x4C	; 76
     bf2:	7f 4f       	sbci	r23, 0xFF	; 255
     bf4:	76 87       	std	Z+14, r23	; 0x0e
     bf6:	65 87       	std	Z+13, r22	; 0x0d
			break;
     bf8:	08 95       	ret
			case 0b10:  // Fjerde kvadrant (x >= 0, y < 0)
			board->JoyAngle = 270 + ((x * 90) / (x - y));
     bfa:	2a e5       	ldi	r18, 0x5A	; 90
     bfc:	26 9f       	mul	r18, r22
     bfe:	c0 01       	movw	r24, r0
     c00:	27 9f       	mul	r18, r23
     c02:	90 0d       	add	r25, r0
     c04:	11 24       	eor	r1, r1
     c06:	64 1b       	sub	r22, r20
     c08:	75 0b       	sbc	r23, r21
     c0a:	0e 94 31 0a 	call	0x1462	; 0x1462 <__divmodhi4>
     c0e:	62 5f       	subi	r22, 0xF2	; 242
     c10:	7e 4f       	sbci	r23, 0xFE	; 254
     c12:	76 87       	std	Z+14, r23	; 0x0e
     c14:	65 87       	std	Z+13, r22	; 0x0d
			break;
     c16:	08 95       	ret
			default:
			board->JoyAngle = 0;  // Feiltilfelle, skal ikkje skje
     c18:	16 86       	std	Z+14, r1	; 0x0e
     c1a:	15 86       	std	Z+13, r1	; 0x0d
     c1c:	08 95       	ret

00000c1e <MultiBoard_Update>:
	board->JoyAngle = 0;
	board->JoyBtn = 0;  // Endra fra en, vi bruker fortsatt 0 for av basert pÃ¥ logikk i MB_Update()
}


void MultiBoard_Update(MultiBoard* board) {
     c1e:	cf 93       	push	r28
     c20:	df 93       	push	r29
     c22:	ec 01       	movw	r28, r24
	// Velg kanal for venstre skyvebryter (LSpos)
	Universal_write(ADC_START, 0x00);
     c24:	60 e0       	ldi	r22, 0x00	; 0
     c26:	80 e0       	ldi	r24, 0x00	; 0
     c28:	94 e1       	ldi	r25, 0x14	; 20
     c2a:	0e 94 11 0a 	call	0x1422	; 0x1422 <Universal_write>
	loopUntilBitIsClear(PINB, BUSY_PIN);		// Vent til BUSY gï¿½r lav - klar for ï¿½ sende pï¿½ ny
     c2e:	b1 99       	sbic	0x16, 1	; 22
     c30:	fe cf       	rjmp	.-4      	; 0xc2e <MultiBoard_Update+0x10>
	board->JoyYpos = Universal_read(ADC_START); //  - CH0 fï¿½rste RD low gir channel 0
     c32:	80 e0       	ldi	r24, 0x00	; 0
     c34:	94 e1       	ldi	r25, 0x14	; 20
     c36:	0e 94 21 0a 	call	0x1442	; 0x1442 <Universal_read>
     c3a:	88 83       	st	Y, r24
	board->JoyXpos = Universal_read(ADC_START); //	- CH1 andre RD low gir channel 1
     c3c:	80 e0       	ldi	r24, 0x00	; 0
     c3e:	94 e1       	ldi	r25, 0x14	; 20
     c40:	0e 94 21 0a 	call	0x1442	; 0x1442 <Universal_read>
     c44:	89 83       	std	Y+1, r24	; 0x01
	board->RSpos = Universal_read(ADC_START);	//	- CH2
     c46:	80 e0       	ldi	r24, 0x00	; 0
     c48:	94 e1       	ldi	r25, 0x14	; 20
     c4a:	0e 94 21 0a 	call	0x1442	; 0x1442 <Universal_read>
     c4e:	8b 83       	std	Y+3, r24	; 0x03
	board->LSpos = Universal_read(ADC_START);	//	- CH3
     c50:	80 e0       	ldi	r24, 0x00	; 0
     c52:	94 e1       	ldi	r25, 0x14	; 20
     c54:	0e 94 21 0a 	call	0x1442	; 0x1442 <Universal_read>
     c58:	8a 83       	std	Y+2, r24	; 0x02
	// Les knappestatus
	board->LBtn = 0<testBit(PINB, LEFT_BUTTON_PIN);
     c5a:	81 e0       	ldi	r24, 0x01	; 1
     c5c:	b4 9b       	sbis	0x16, 4	; 22
     c5e:	80 e0       	ldi	r24, 0x00	; 0
     c60:	8c 83       	std	Y+4, r24	; 0x04
	board->RBtn = 0<testBit(PINB, RIGHT_BUTTON_PIN);
     c62:	81 e0       	ldi	r24, 0x01	; 1
     c64:	b3 9b       	sbis	0x16, 3	; 22
     c66:	80 e0       	ldi	r24, 0x00	; 0
     c68:	8d 83       	std	Y+5, r24	; 0x05
	board->JoyBtn = !(0<testBit(PINB, JOY_BUTTON_PIN));
     c6a:	81 e0       	ldi	r24, 0x01	; 1
     c6c:	b2 99       	sbic	0x16, 2	; 22
     c6e:	80 e0       	ldi	r24, 0x00	; 0
     c70:	8e 83       	std	Y+6, r24	; 0x06
	// Opretter ein int med pluss og minus slik at vi kan finne riktig vinkel med _UpdateJoystickAngel
	board->JoyYposCal = (int16_t)(board->JoyYpos) - (int16_t)(board->JoyYOrigo);
     c72:	88 81       	ld	r24, Y
     c74:	90 e0       	ldi	r25, 0x00	; 0
     c76:	28 85       	ldd	r18, Y+8	; 0x08
     c78:	82 1b       	sub	r24, r18
     c7a:	91 09       	sbc	r25, r1
     c7c:	9c 87       	std	Y+12, r25	; 0x0c
     c7e:	8b 87       	std	Y+11, r24	; 0x0b
	board->JoyXposCal = (int16_t)(board->JoyXpos) - (int16_t)(board->JoyXOrigo);
     c80:	89 81       	ldd	r24, Y+1	; 0x01
     c82:	90 e0       	ldi	r25, 0x00	; 0
     c84:	2f 81       	ldd	r18, Y+7	; 0x07
     c86:	82 1b       	sub	r24, r18
     c88:	91 09       	sbc	r25, r1
     c8a:	9a 87       	std	Y+10, r25	; 0x0a
     c8c:	89 87       	std	Y+9, r24	; 0x09
	///IKKJE TESTA
	MultiBoard_UpdateJoystickAngle(board);
     c8e:	ce 01       	movw	r24, r28
     c90:	0e 94 a2 05 	call	0xb44	; 0xb44 <MultiBoard_UpdateJoystickAngle>
}
     c94:	df 91       	pop	r29
     c96:	cf 91       	pop	r28
     c98:	08 95       	ret

00000c9a <oled_write_command>:
	for (uint16_t i = 0; i < 1024; i++) {
		// Les byte direkte frå Flash og skriv til SRAM
		uint8_t byte_from_flash = pgm_read_byte(&screen_1024[i]);
		SRAM_write(i, byte_from_flash);
	}
}
     c9a:	68 2f       	mov	r22, r24
     c9c:	80 e0       	ldi	r24, 0x00	; 0
     c9e:	90 e0       	ldi	r25, 0x00	; 0
     ca0:	0e 94 11 0a 	call	0x1422	; 0x1422 <Universal_write>
     ca4:	08 95       	ret

00000ca6 <oled_write_data>:
     ca6:	ef 92       	push	r14
     ca8:	ff 92       	push	r15
     caa:	0f 93       	push	r16
     cac:	1f 93       	push	r17
     cae:	cf 93       	push	r28
     cb0:	df 93       	push	r29
     cb2:	61 15       	cp	r22, r1
     cb4:	71 05       	cpc	r23, r1
     cb6:	81 f0       	breq	.+32     	; 0xcd8 <oled_write_data+0x32>
     cb8:	7c 01       	movw	r14, r24
     cba:	8c 01       	movw	r16, r24
     cbc:	e6 0e       	add	r14, r22
     cbe:	f7 1e       	adc	r15, r23
     cc0:	c0 e0       	ldi	r28, 0x00	; 0
     cc2:	d2 e0       	ldi	r29, 0x02	; 2
     cc4:	f8 01       	movw	r30, r16
     cc6:	61 91       	ld	r22, Z+
     cc8:	8f 01       	movw	r16, r30
     cca:	ce 01       	movw	r24, r28
     ccc:	0e 94 11 0a 	call	0x1422	; 0x1422 <Universal_write>
     cd0:	21 96       	adiw	r28, 0x01	; 1
     cd2:	0e 15       	cp	r16, r14
     cd4:	1f 05       	cpc	r17, r15
     cd6:	b1 f7       	brne	.-20     	; 0xcc4 <oled_write_data+0x1e>
     cd8:	df 91       	pop	r29
     cda:	cf 91       	pop	r28
     cdc:	1f 91       	pop	r17
     cde:	0f 91       	pop	r16
     ce0:	ff 90       	pop	r15
     ce2:	ef 90       	pop	r14
     ce4:	08 95       	ret

00000ce6 <oled_set_page>:
     ce6:	87 70       	andi	r24, 0x07	; 7
     ce8:	80 6b       	ori	r24, 0xB0	; 176
     cea:	0e 94 4d 06 	call	0xc9a	; 0xc9a <oled_write_command>
     cee:	08 95       	ret

00000cf0 <oled_set_column>:
     cf0:	cf 93       	push	r28
     cf2:	c8 2f       	mov	r28, r24
     cf4:	82 95       	swap	r24
     cf6:	8f 70       	andi	r24, 0x0F	; 15
     cf8:	80 61       	ori	r24, 0x10	; 16
     cfa:	0e 94 4d 06 	call	0xc9a	; 0xc9a <oled_write_command>
     cfe:	8c 2f       	mov	r24, r28
     d00:	8f 70       	andi	r24, 0x0F	; 15
     d02:	0e 94 4d 06 	call	0xc9a	; 0xc9a <oled_write_command>
     d06:	cf 91       	pop	r28
     d08:	08 95       	ret

00000d0a <oled_home>:
     d0a:	80 e0       	ldi	r24, 0x00	; 0
     d0c:	0e 94 73 06 	call	0xce6	; 0xce6 <oled_set_page>
     d10:	80 e0       	ldi	r24, 0x00	; 0
     d12:	0e 94 78 06 	call	0xcf0	; 0xcf0 <oled_set_column>
     d16:	08 95       	ret

00000d18 <oled_init>:
     d18:	8e ea       	ldi	r24, 0xAE	; 174
     d1a:	0e 94 4d 06 	call	0xc9a	; 0xc9a <oled_write_command>
     d1e:	81 ea       	ldi	r24, 0xA1	; 161
     d20:	0e 94 4d 06 	call	0xc9a	; 0xc9a <oled_write_command>
     d24:	8a ed       	ldi	r24, 0xDA	; 218
     d26:	0e 94 4d 06 	call	0xc9a	; 0xc9a <oled_write_command>
     d2a:	82 e1       	ldi	r24, 0x12	; 18
     d2c:	0e 94 4d 06 	call	0xc9a	; 0xc9a <oled_write_command>
     d30:	88 ec       	ldi	r24, 0xC8	; 200
     d32:	0e 94 4d 06 	call	0xc9a	; 0xc9a <oled_write_command>
     d36:	88 ea       	ldi	r24, 0xA8	; 168
     d38:	0e 94 4d 06 	call	0xc9a	; 0xc9a <oled_write_command>
     d3c:	8f e3       	ldi	r24, 0x3F	; 63
     d3e:	0e 94 4d 06 	call	0xc9a	; 0xc9a <oled_write_command>
     d42:	85 ed       	ldi	r24, 0xD5	; 213
     d44:	0e 94 4d 06 	call	0xc9a	; 0xc9a <oled_write_command>
     d48:	80 e8       	ldi	r24, 0x80	; 128
     d4a:	0e 94 4d 06 	call	0xc9a	; 0xc9a <oled_write_command>
     d4e:	81 e8       	ldi	r24, 0x81	; 129
     d50:	0e 94 4d 06 	call	0xc9a	; 0xc9a <oled_write_command>
     d54:	80 e5       	ldi	r24, 0x50	; 80
     d56:	0e 94 4d 06 	call	0xc9a	; 0xc9a <oled_write_command>
     d5a:	89 ed       	ldi	r24, 0xD9	; 217
     d5c:	0e 94 4d 06 	call	0xc9a	; 0xc9a <oled_write_command>
     d60:	81 e2       	ldi	r24, 0x21	; 33
     d62:	0e 94 4d 06 	call	0xc9a	; 0xc9a <oled_write_command>
     d66:	80 e2       	ldi	r24, 0x20	; 32
     d68:	0e 94 4d 06 	call	0xc9a	; 0xc9a <oled_write_command>
     d6c:	82 e0       	ldi	r24, 0x02	; 2
     d6e:	0e 94 4d 06 	call	0xc9a	; 0xc9a <oled_write_command>
     d72:	8b ed       	ldi	r24, 0xDB	; 219
     d74:	0e 94 4d 06 	call	0xc9a	; 0xc9a <oled_write_command>
     d78:	80 e3       	ldi	r24, 0x30	; 48
     d7a:	0e 94 4d 06 	call	0xc9a	; 0xc9a <oled_write_command>
     d7e:	8d ea       	ldi	r24, 0xAD	; 173
     d80:	0e 94 4d 06 	call	0xc9a	; 0xc9a <oled_write_command>
     d84:	80 e0       	ldi	r24, 0x00	; 0
     d86:	0e 94 4d 06 	call	0xc9a	; 0xc9a <oled_write_command>
     d8a:	84 ea       	ldi	r24, 0xA4	; 164
     d8c:	0e 94 4d 06 	call	0xc9a	; 0xc9a <oled_write_command>
     d90:	86 ea       	ldi	r24, 0xA6	; 166
     d92:	0e 94 4d 06 	call	0xc9a	; 0xc9a <oled_write_command>
     d96:	8f ea       	ldi	r24, 0xAF	; 175
     d98:	0e 94 4d 06 	call	0xc9a	; 0xc9a <oled_write_command>
     d9c:	08 95       	ret

00000d9e <oled_data_from_SRAM>:
     d9e:	8f 92       	push	r8
     da0:	9f 92       	push	r9
     da2:	bf 92       	push	r11
     da4:	cf 92       	push	r12
     da6:	df 92       	push	r13
     da8:	ef 92       	push	r14
     daa:	ff 92       	push	r15
     dac:	0f 93       	push	r16
     dae:	1f 93       	push	r17
     db0:	cf 93       	push	r28
     db2:	df 93       	push	r29
     db4:	cd b7       	in	r28, 0x3d	; 61
     db6:	de b7       	in	r29, 0x3e	; 62
     db8:	c0 58       	subi	r28, 0x80	; 128
     dba:	d1 09       	sbc	r29, r1
     dbc:	0f b6       	in	r0, 0x3f	; 63
     dbe:	f8 94       	cli
     dc0:	de bf       	out	0x3e, r29	; 62
     dc2:	0f be       	out	0x3f, r0	; 63
     dc4:	cd bf       	out	0x3d, r28	; 61
     dc6:	ce 01       	movw	r24, r28
     dc8:	01 96       	adiw	r24, 0x01	; 1
     dca:	4c 01       	movw	r8, r24
     dcc:	ee 24       	eor	r14, r14
     dce:	ff 24       	eor	r15, r15
     dd0:	e8 1a       	sub	r14, r24
     dd2:	f9 0a       	sbc	r15, r25
     dd4:	b1 2c       	mov	r11, r1
     dd6:	6e 01       	movw	r12, r28
     dd8:	91 e8       	ldi	r25, 0x81	; 129
     dda:	c9 0e       	add	r12, r25
     ddc:	d1 1c       	adc	r13, r1
     dde:	8b 2d       	mov	r24, r11
     de0:	0e 94 73 06 	call	0xce6	; 0xce6 <oled_set_page>
     de4:	80 e0       	ldi	r24, 0x00	; 0
     de6:	0e 94 78 06 	call	0xcf0	; 0xcf0 <oled_set_column>
     dea:	84 01       	movw	r16, r8
     dec:	c8 01       	movw	r24, r16
     dee:	8e 0d       	add	r24, r14
     df0:	9f 1d       	adc	r25, r15
     df2:	0e 94 01 0a 	call	0x1402	; 0x1402 <SRAM_read>
     df6:	f8 01       	movw	r30, r16
     df8:	81 93       	st	Z+, r24
     dfa:	8f 01       	movw	r16, r30
     dfc:	ec 15       	cp	r30, r12
     dfe:	fd 05       	cpc	r31, r13
     e00:	a9 f7       	brne	.-22     	; 0xdec <oled_data_from_SRAM+0x4e>
     e02:	60 e8       	ldi	r22, 0x80	; 128
     e04:	70 e0       	ldi	r23, 0x00	; 0
     e06:	ce 01       	movw	r24, r28
     e08:	01 96       	adiw	r24, 0x01	; 1
     e0a:	0e 94 53 06 	call	0xca6	; 0xca6 <oled_write_data>
     e0e:	b3 94       	inc	r11
     e10:	f0 e8       	ldi	r31, 0x80	; 128
     e12:	ef 0e       	add	r14, r31
     e14:	f1 1c       	adc	r15, r1
     e16:	88 e0       	ldi	r24, 0x08	; 8
     e18:	b8 12       	cpse	r11, r24
     e1a:	e1 cf       	rjmp	.-62     	; 0xdde <oled_data_from_SRAM+0x40>
     e1c:	c0 58       	subi	r28, 0x80	; 128
     e1e:	df 4f       	sbci	r29, 0xFF	; 255
     e20:	0f b6       	in	r0, 0x3f	; 63
     e22:	f8 94       	cli
     e24:	de bf       	out	0x3e, r29	; 62
     e26:	0f be       	out	0x3f, r0	; 63
     e28:	cd bf       	out	0x3d, r28	; 61
     e2a:	df 91       	pop	r29
     e2c:	cf 91       	pop	r28
     e2e:	1f 91       	pop	r17
     e30:	0f 91       	pop	r16
     e32:	ff 90       	pop	r15
     e34:	ef 90       	pop	r14
     e36:	df 90       	pop	r13
     e38:	cf 90       	pop	r12
     e3a:	bf 90       	pop	r11
     e3c:	9f 90       	pop	r9
     e3e:	8f 90       	pop	r8
     e40:	08 95       	ret

00000e42 <oled_write_screen_to_SRAM>:
     e42:	6f 92       	push	r6
     e44:	7f 92       	push	r7
     e46:	8f 92       	push	r8
     e48:	9f 92       	push	r9
     e4a:	af 92       	push	r10
     e4c:	bf 92       	push	r11
     e4e:	cf 92       	push	r12
     e50:	df 92       	push	r13
     e52:	ef 92       	push	r14
     e54:	ff 92       	push	r15
     e56:	0f 93       	push	r16
     e58:	1f 93       	push	r17
     e5a:	cf 93       	push	r28
     e5c:	df 93       	push	r29
     e5e:	4c 01       	movw	r8, r24
     e60:	e1 2c       	mov	r14, r1
     e62:	f1 2c       	mov	r15, r1
     e64:	0f 2e       	mov	r0, r31
     e66:	f0 e7       	ldi	r31, 0x70	; 112
     e68:	6f 2e       	mov	r6, r31
     e6a:	f1 e0       	ldi	r31, 0x01	; 1
     e6c:	7f 2e       	mov	r7, r31
     e6e:	f0 2d       	mov	r31, r0
     e70:	0f 2e       	mov	r0, r31
     e72:	f8 e7       	ldi	r31, 0x78	; 120
     e74:	af 2e       	mov	r10, r31
     e76:	f1 e0       	ldi	r31, 0x01	; 1
     e78:	bf 2e       	mov	r11, r31
     e7a:	f0 2d       	mov	r31, r0
     e7c:	f4 01       	movw	r30, r8
     e7e:	04 91       	lpm	r16, Z
     e80:	80 ee       	ldi	r24, 0xE0	; 224
     e82:	80 0f       	add	r24, r16
     e84:	80 36       	cpi	r24, 0x60	; 96
     e86:	f0 f4       	brcc	.+60     	; 0xec4 <oled_write_screen_to_SRAM+0x82>
     e88:	10 e0       	ldi	r17, 0x00	; 0
     e8a:	00 52       	subi	r16, 0x20	; 32
     e8c:	11 09       	sbc	r17, r1
     e8e:	00 0f       	add	r16, r16
     e90:	11 1f       	adc	r17, r17
     e92:	00 0f       	add	r16, r16
     e94:	11 1f       	adc	r17, r17
     e96:	00 0f       	add	r16, r16
     e98:	11 1f       	adc	r17, r17
     e9a:	67 01       	movw	r12, r14
     e9c:	f8 e0       	ldi	r31, 0x08	; 8
     e9e:	cf 0e       	add	r12, r31
     ea0:	d1 1c       	adc	r13, r1
     ea2:	e7 01       	movw	r28, r14
     ea4:	0e 19       	sub	r16, r14
     ea6:	1f 09       	sbc	r17, r15
     ea8:	f8 01       	movw	r30, r16
     eaa:	ec 0f       	add	r30, r28
     eac:	fd 1f       	adc	r31, r29
     eae:	e0 59       	subi	r30, 0x90	; 144
     eb0:	fe 4f       	sbci	r31, 0xFE	; 254
     eb2:	64 91       	lpm	r22, Z
     eb4:	ce 01       	movw	r24, r28
     eb6:	0e 94 f1 09 	call	0x13e2	; 0x13e2 <SRAM_write>
     eba:	21 96       	adiw	r28, 0x01	; 1
     ebc:	cc 16       	cp	r12, r28
     ebe:	dd 06       	cpc	r13, r29
     ec0:	99 f7       	brne	.-26     	; 0xea8 <oled_write_screen_to_SRAM+0x66>
     ec2:	10 c0       	rjmp	.+32     	; 0xee4 <oled_write_screen_to_SRAM+0xa2>
     ec4:	c0 e7       	ldi	r28, 0x70	; 112
     ec6:	d1 e0       	ldi	r29, 0x01	; 1
     ec8:	87 01       	movw	r16, r14
     eca:	06 19       	sub	r16, r6
     ecc:	17 09       	sbc	r17, r7
     ece:	fe 01       	movw	r30, r28
     ed0:	64 91       	lpm	r22, Z
     ed2:	c8 01       	movw	r24, r16
     ed4:	8c 0f       	add	r24, r28
     ed6:	9d 1f       	adc	r25, r29
     ed8:	0e 94 f1 09 	call	0x13e2	; 0x13e2 <SRAM_write>
     edc:	21 96       	adiw	r28, 0x01	; 1
     ede:	ca 15       	cp	r28, r10
     ee0:	db 05       	cpc	r29, r11
     ee2:	a9 f7       	brne	.-22     	; 0xece <oled_write_screen_to_SRAM+0x8c>
     ee4:	ff ef       	ldi	r31, 0xFF	; 255
     ee6:	8f 1a       	sub	r8, r31
     ee8:	9f 0a       	sbc	r9, r31
     eea:	88 e0       	ldi	r24, 0x08	; 8
     eec:	e8 0e       	add	r14, r24
     eee:	f1 1c       	adc	r15, r1
     ef0:	e1 14       	cp	r14, r1
     ef2:	e4 e0       	ldi	r30, 0x04	; 4
     ef4:	fe 06       	cpc	r15, r30
     ef6:	09 f0       	breq	.+2      	; 0xefa <oled_write_screen_to_SRAM+0xb8>
     ef8:	c1 cf       	rjmp	.-126    	; 0xe7c <oled_write_screen_to_SRAM+0x3a>
     efa:	df 91       	pop	r29
     efc:	cf 91       	pop	r28
     efe:	1f 91       	pop	r17
     f00:	0f 91       	pop	r16
     f02:	ff 90       	pop	r15
     f04:	ef 90       	pop	r14
     f06:	df 90       	pop	r13
     f08:	cf 90       	pop	r12
     f0a:	bf 90       	pop	r11
     f0c:	af 90       	pop	r10
     f0e:	9f 90       	pop	r9
     f10:	8f 90       	pop	r8
     f12:	7f 90       	pop	r7
     f14:	6f 90       	pop	r6
     f16:	08 95       	ret

00000f18 <oled_write_line_to_SRAM>:


void oled_write_line_to_SRAM(uint8_t line, const char* data) {
     f18:	8f 92       	push	r8
     f1a:	9f 92       	push	r9
     f1c:	bf 92       	push	r11
     f1e:	cf 92       	push	r12
     f20:	df 92       	push	r13
     f22:	ef 92       	push	r14
     f24:	ff 92       	push	r15
     f26:	0f 93       	push	r16
     f28:	1f 93       	push	r17
     f2a:	cf 93       	push	r28
     f2c:	df 93       	push	r29
	if (line >= 8) {
     f2e:	88 30       	cpi	r24, 0x08	; 8
     f30:	08 f0       	brcs	.+2      	; 0xf34 <oled_write_line_to_SRAM+0x1c>
     f32:	5e c0       	rjmp	.+188    	; 0xff0 <oled_write_line_to_SRAM+0xd8>
     f34:	fb 01       	movw	r30, r22
		return; 
	}
	uint8_t max_chars_per_line = 16;
	uint16_t sram_address = line * 128;  // Hver linje er 128 bytes, 16 karakterer à 8 pixels
     f36:	90 e8       	ldi	r25, 0x80	; 128
     f38:	89 9f       	mul	r24, r25
     f3a:	60 01       	movw	r12, r0
     f3c:	11 24       	eor	r1, r1
	uint8_t i = 0; // så den ikkje døyr når vi går ut av forloopen (brukast igjen)
	// Skriv karakterene til SRAM, men ikke mer enn 16
	for (; i < max_chars_per_line; i++) {
		if (data[i] == '\0') {
     f3e:	80 81       	ld	r24, Z
     f40:	88 23       	and	r24, r24
     f42:	09 f4       	brne	.+2      	; 0xf46 <oled_write_line_to_SRAM+0x2e>
     f44:	47 c0       	rjmp	.+142    	; 0xfd4 <oled_write_line_to_SRAM+0xbc>
     f46:	76 01       	movw	r14, r12
     f48:	8b 01       	movw	r16, r22
     f4a:	b1 2c       	mov	r11, r1
     f4c:	0a c0       	rjmp	.+20     	; 0xf62 <oled_write_line_to_SRAM+0x4a>
     f4e:	0f 5f       	subi	r16, 0xFF	; 255
     f50:	1f 4f       	sbci	r17, 0xFF	; 255
     f52:	a8 e0       	ldi	r26, 0x08	; 8
     f54:	ea 0e       	add	r14, r26
     f56:	f1 1c       	adc	r15, r1
     f58:	f8 01       	movw	r30, r16
     f5a:	80 81       	ld	r24, Z
     f5c:	88 23       	and	r24, r24
     f5e:	09 f4       	brne	.+2      	; 0xf62 <oled_write_line_to_SRAM+0x4a>
     f60:	3a c0       	rjmp	.+116    	; 0xfd6 <oled_write_line_to_SRAM+0xbe>
     f62:	c0 e0       	ldi	r28, 0x00	; 0
     f64:	d0 e0       	ldi	r29, 0x00	; 0
			break;  // Avslutt hvis vi når slutten av data
		}
		for (uint8_t j = 0; j < 8; j++) {
			SRAM_write(sram_address + (i * 8) + j, pgm_read_byte(&font8x8_basic[(data[i] - 32) * 8 + j]));
     f66:	d8 01       	movw	r26, r16
     f68:	ec 91       	ld	r30, X
     f6a:	f0 e0       	ldi	r31, 0x00	; 0
     f6c:	b0 97       	sbiw	r30, 0x20	; 32
     f6e:	ee 0f       	add	r30, r30
     f70:	ff 1f       	adc	r31, r31
     f72:	ee 0f       	add	r30, r30
     f74:	ff 1f       	adc	r31, r31
     f76:	ee 0f       	add	r30, r30
     f78:	ff 1f       	adc	r31, r31
     f7a:	ec 0f       	add	r30, r28
     f7c:	fd 1f       	adc	r31, r29
     f7e:	e0 59       	subi	r30, 0x90	; 144
     f80:	fe 4f       	sbci	r31, 0xFE	; 254
     f82:	64 91       	lpm	r22, Z
     f84:	c7 01       	movw	r24, r14
     f86:	8c 0f       	add	r24, r28
     f88:	9d 1f       	adc	r25, r29
     f8a:	0e 94 f1 09 	call	0x13e2	; 0x13e2 <SRAM_write>
     f8e:	21 96       	adiw	r28, 0x01	; 1
	// Skriv karakterene til SRAM, men ikke mer enn 16
	for (; i < max_chars_per_line; i++) {
		if (data[i] == '\0') {
			break;  // Avslutt hvis vi når slutten av data
		}
		for (uint8_t j = 0; j < 8; j++) {
     f90:	c8 30       	cpi	r28, 0x08	; 8
     f92:	d1 05       	cpc	r29, r1
     f94:	41 f7       	brne	.-48     	; 0xf66 <oled_write_line_to_SRAM+0x4e>
	}
	uint8_t max_chars_per_line = 16;
	uint16_t sram_address = line * 128;  // Hver linje er 128 bytes, 16 karakterer à 8 pixels
	uint8_t i = 0; // så den ikkje døyr når vi går ut av forloopen (brukast igjen)
	// Skriv karakterene til SRAM, men ikke mer enn 16
	for (; i < max_chars_per_line; i++) {
     f96:	b3 94       	inc	r11
     f98:	b0 e1       	ldi	r27, 0x10	; 16
     f9a:	bb 12       	cpse	r11, r27
     f9c:	d8 cf       	rjmp	.-80     	; 0xf4e <oled_write_line_to_SRAM+0x36>
     f9e:	28 c0       	rjmp	.+80     	; 0xff0 <oled_write_line_to_SRAM+0xd8>
		}
	}
	// Fyll resten av linjen med tomrom (mellomrom) etter slutten av data
	for (; i < max_chars_per_line; i++) {
		for (uint8_t j = 0; j < 8; j++) {
			SRAM_write(sram_address + (i * 8) + j, pgm_read_byte(&font8x8_basic[(' ' - 32) * 8 + j]));
     fa0:	fe 01       	movw	r30, r28
     fa2:	64 91       	lpm	r22, Z
     fa4:	c8 01       	movw	r24, r16
     fa6:	8c 0f       	add	r24, r28
     fa8:	9d 1f       	adc	r25, r29
     faa:	0e 94 f1 09 	call	0x13e2	; 0x13e2 <SRAM_write>
     fae:	21 96       	adiw	r28, 0x01	; 1
			SRAM_write(sram_address + (i * 8) + j, pgm_read_byte(&font8x8_basic[(data[i] - 32) * 8 + j]));
		}
	}
	// Fyll resten av linjen med tomrom (mellomrom) etter slutten av data
	for (; i < max_chars_per_line; i++) {
		for (uint8_t j = 0; j < 8; j++) {
     fb0:	ce 15       	cp	r28, r14
     fb2:	df 05       	cpc	r29, r15
     fb4:	a9 f7       	brne	.-22     	; 0xfa0 <oled_write_line_to_SRAM+0x88>
		for (uint8_t j = 0; j < 8; j++) {
			SRAM_write(sram_address + (i * 8) + j, pgm_read_byte(&font8x8_basic[(data[i] - 32) * 8 + j]));
		}
	}
	// Fyll resten av linjen med tomrom (mellomrom) etter slutten av data
	for (; i < max_chars_per_line; i++) {
     fb6:	b3 94       	inc	r11
     fb8:	ff e0       	ldi	r31, 0x0F	; 15
     fba:	fb 15       	cp	r31, r11
     fbc:	c8 f0       	brcs	.+50     	; 0xff0 <oled_write_line_to_SRAM+0xd8>
		for (uint8_t j = 0; j < 8; j++) {
			SRAM_write(sram_address + (i * 8) + j, pgm_read_byte(&font8x8_basic[(' ' - 32) * 8 + j]));
     fbe:	c0 e7       	ldi	r28, 0x70	; 112
     fc0:	d1 e0       	ldi	r29, 0x01	; 1
     fc2:	86 01       	movw	r16, r12
     fc4:	88 e0       	ldi	r24, 0x08	; 8
     fc6:	b8 9e       	mul	r11, r24
     fc8:	00 0d       	add	r16, r0
     fca:	11 1d       	adc	r17, r1
     fcc:	11 24       	eor	r1, r1
     fce:	08 19       	sub	r16, r8
     fd0:	19 09       	sbc	r17, r9
     fd2:	e6 cf       	rjmp	.-52     	; 0xfa0 <oled_write_line_to_SRAM+0x88>
	if (line >= 8) {
		return; 
	}
	uint8_t max_chars_per_line = 16;
	uint16_t sram_address = line * 128;  // Hver linje er 128 bytes, 16 karakterer à 8 pixels
	uint8_t i = 0; // så den ikkje døyr når vi går ut av forloopen (brukast igjen)
     fd4:	b1 2c       	mov	r11, r1
     fd6:	0f 2e       	mov	r0, r31
     fd8:	f0 e7       	ldi	r31, 0x70	; 112
     fda:	8f 2e       	mov	r8, r31
     fdc:	f1 e0       	ldi	r31, 0x01	; 1
     fde:	9f 2e       	mov	r9, r31
     fe0:	f0 2d       	mov	r31, r0
     fe2:	0f 2e       	mov	r0, r31
     fe4:	f8 e7       	ldi	r31, 0x78	; 120
     fe6:	ef 2e       	mov	r14, r31
     fe8:	f1 e0       	ldi	r31, 0x01	; 1
     fea:	ff 2e       	mov	r15, r31
     fec:	f0 2d       	mov	r31, r0
     fee:	e7 cf       	rjmp	.-50     	; 0xfbe <oled_write_line_to_SRAM+0xa6>
	for (; i < max_chars_per_line; i++) {
		for (uint8_t j = 0; j < 8; j++) {
			SRAM_write(sram_address + (i * 8) + j, pgm_read_byte(&font8x8_basic[(' ' - 32) * 8 + j]));
		}
	}
}
     ff0:	df 91       	pop	r29
     ff2:	cf 91       	pop	r28
     ff4:	1f 91       	pop	r17
     ff6:	0f 91       	pop	r16
     ff8:	ff 90       	pop	r15
     ffa:	ef 90       	pop	r14
     ffc:	df 90       	pop	r13
     ffe:	cf 90       	pop	r12
    1000:	bf 90       	pop	r11
    1002:	9f 90       	pop	r9
    1004:	8f 90       	pop	r8
    1006:	08 95       	ret

00001008 <oled_write_char_to_SRAM>:
//Nyttig for menyen trur eg, lar deg spesifisere nøyaktig kor på skjermen du vil overskrive
void oled_write_char_to_SRAM(uint8_t row, uint8_t col, char c) {
    1008:	ef 92       	push	r14
    100a:	ff 92       	push	r15
    100c:	0f 93       	push	r16
    100e:	1f 93       	push	r17
    1010:	cf 93       	push	r28
    1012:	df 93       	push	r29
	if (row >= 8 || col >= 16) {
    1014:	88 30       	cpi	r24, 0x08	; 8
    1016:	70 f5       	brcc	.+92     	; 0x1074 <oled_write_char_to_SRAM+0x6c>
    1018:	60 31       	cpi	r22, 0x10	; 16
    101a:	60 f5       	brcc	.+88     	; 0x1074 <oled_write_char_to_SRAM+0x6c>
    101c:	28 2f       	mov	r18, r24
		return; 
	}
	uint16_t sram_address = row * 128 + (col * 8); 
    101e:	86 2f       	mov	r24, r22
    1020:	90 e0       	ldi	r25, 0x00	; 0
    1022:	30 e1       	ldi	r19, 0x10	; 16
    1024:	23 9f       	mul	r18, r19
    1026:	80 0d       	add	r24, r0
    1028:	91 1d       	adc	r25, r1
    102a:	11 24       	eor	r1, r1
    102c:	88 0f       	add	r24, r24
    102e:	99 1f       	adc	r25, r25
    1030:	88 0f       	add	r24, r24
    1032:	99 1f       	adc	r25, r25
    1034:	88 0f       	add	r24, r24
    1036:	99 1f       	adc	r25, r25
	for (uint8_t i = 0; i < 8; i++) {
		SRAM_write(sram_address + i, pgm_read_byte(&font8x8_basic[(c - 32) * 8 + i]));
    1038:	04 2f       	mov	r16, r20
    103a:	10 e0       	ldi	r17, 0x00	; 0
    103c:	00 52       	subi	r16, 0x20	; 32
    103e:	11 09       	sbc	r17, r1
    1040:	00 0f       	add	r16, r16
    1042:	11 1f       	adc	r17, r17
    1044:	00 0f       	add	r16, r16
    1046:	11 1f       	adc	r17, r17
    1048:	00 0f       	add	r16, r16
    104a:	11 1f       	adc	r17, r17
    104c:	7c 01       	movw	r14, r24
    104e:	28 e0       	ldi	r18, 0x08	; 8
    1050:	e2 0e       	add	r14, r18
    1052:	f1 1c       	adc	r15, r1
    1054:	ec 01       	movw	r28, r24
    1056:	08 1b       	sub	r16, r24
    1058:	19 0b       	sbc	r17, r25
    105a:	f8 01       	movw	r30, r16
    105c:	ec 0f       	add	r30, r28
    105e:	fd 1f       	adc	r31, r29
    1060:	e0 59       	subi	r30, 0x90	; 144
    1062:	fe 4f       	sbci	r31, 0xFE	; 254
    1064:	64 91       	lpm	r22, Z
    1066:	ce 01       	movw	r24, r28
    1068:	0e 94 f1 09 	call	0x13e2	; 0x13e2 <SRAM_write>
    106c:	21 96       	adiw	r28, 0x01	; 1
void oled_write_char_to_SRAM(uint8_t row, uint8_t col, char c) {
	if (row >= 8 || col >= 16) {
		return; 
	}
	uint16_t sram_address = row * 128 + (col * 8); 
	for (uint8_t i = 0; i < 8; i++) {
    106e:	ce 15       	cp	r28, r14
    1070:	df 05       	cpc	r29, r15
    1072:	99 f7       	brne	.-26     	; 0x105a <oled_write_char_to_SRAM+0x52>
		SRAM_write(sram_address + i, pgm_read_byte(&font8x8_basic[(c - 32) * 8 + i]));
	}
}
    1074:	df 91       	pop	r29
    1076:	cf 91       	pop	r28
    1078:	1f 91       	pop	r17
    107a:	0f 91       	pop	r16
    107c:	ff 90       	pop	r15
    107e:	ef 90       	pop	r14
    1080:	08 95       	ret

00001082 <oled_write_pixel_to_SRAM>:

void oled_write_pixel_to_SRAM(uint8_t row, uint8_t col, uint8_t value) {
    1082:	0f 93       	push	r16
    1084:	1f 93       	push	r17
    1086:	cf 93       	push	r28
    1088:	df 93       	push	r29
	if (row >= 64 || col >= 128) {
    108a:	80 34       	cpi	r24, 0x40	; 64
    108c:	48 f5       	brcc	.+82     	; 0x10e0 <oled_write_pixel_to_SRAM+0x5e>
    108e:	66 23       	and	r22, r22
    1090:	3c f1       	brlt	.+78     	; 0x10e0 <oled_write_pixel_to_SRAM+0x5e>
    1092:	04 2f       	mov	r16, r20
    1094:	18 2f       	mov	r17, r24
		return;
	}
	
	// Finn korrekt byte i SRAM for å justere pikslen
	uint16_t sram_address = (row / 8) * 128 + col;
    1096:	86 95       	lsr	r24
    1098:	86 95       	lsr	r24
    109a:	86 95       	lsr	r24
    109c:	c6 2f       	mov	r28, r22
    109e:	d0 e0       	ldi	r29, 0x00	; 0
    10a0:	90 e8       	ldi	r25, 0x80	; 128
    10a2:	89 9f       	mul	r24, r25
    10a4:	c0 0d       	add	r28, r0
    10a6:	d1 1d       	adc	r29, r1
    10a8:	11 24       	eor	r1, r1
	uint8_t current_byte = SRAM_read(sram_address);
    10aa:	ce 01       	movw	r24, r28
    10ac:	0e 94 01 0a 	call	0x1402	; 0x1402 <SRAM_read>
	uint8_t bit_position = row % 8;
    10b0:	17 70       	andi	r17, 0x07	; 7

	// Sett eller nullstill den ønskede biten
	if (value) {
    10b2:	00 23       	and	r16, r16
    10b4:	49 f0       	breq	.+18     	; 0x10c8 <oled_write_pixel_to_SRAM+0x46>
		current_byte |= (1 << bit_position);  // Sett bit til 1
    10b6:	61 e0       	ldi	r22, 0x01	; 1
    10b8:	70 e0       	ldi	r23, 0x00	; 0
    10ba:	02 c0       	rjmp	.+4      	; 0x10c0 <oled_write_pixel_to_SRAM+0x3e>
    10bc:	66 0f       	add	r22, r22
    10be:	77 1f       	adc	r23, r23
    10c0:	1a 95       	dec	r17
    10c2:	e2 f7       	brpl	.-8      	; 0x10bc <oled_write_pixel_to_SRAM+0x3a>
    10c4:	68 2b       	or	r22, r24
    10c6:	09 c0       	rjmp	.+18     	; 0x10da <oled_write_pixel_to_SRAM+0x58>
		} else {
		current_byte &= ~(1 << bit_position);  // Nullstill bit til 0
    10c8:	61 e0       	ldi	r22, 0x01	; 1
    10ca:	70 e0       	ldi	r23, 0x00	; 0
    10cc:	02 c0       	rjmp	.+4      	; 0x10d2 <oled_write_pixel_to_SRAM+0x50>
    10ce:	66 0f       	add	r22, r22
    10d0:	77 1f       	adc	r23, r23
    10d2:	1a 95       	dec	r17
    10d4:	e2 f7       	brpl	.-8      	; 0x10ce <oled_write_pixel_to_SRAM+0x4c>
    10d6:	60 95       	com	r22
    10d8:	68 23       	and	r22, r24
	}
	
	SRAM_write(sram_address, current_byte);
    10da:	ce 01       	movw	r24, r28
    10dc:	0e 94 f1 09 	call	0x13e2	; 0x13e2 <SRAM_write>
}
    10e0:	df 91       	pop	r29
    10e2:	cf 91       	pop	r28
    10e4:	1f 91       	pop	r17
    10e6:	0f 91       	pop	r16
    10e8:	08 95       	ret

000010ea <oled_clear_screen>:

void oled_clear_screen(void) {
    10ea:	cf 93       	push	r28
    10ec:	df 93       	push	r29
    10ee:	cd b7       	in	r28, 0x3d	; 61
    10f0:	de b7       	in	r29, 0x3e	; 62
    10f2:	c0 58       	subi	r28, 0x80	; 128
    10f4:	d1 09       	sbc	r29, r1
    10f6:	0f b6       	in	r0, 0x3f	; 63
    10f8:	f8 94       	cli
    10fa:	de bf       	out	0x3e, r29	; 62
    10fc:	0f be       	out	0x3f, r0	; 63
    10fe:	cd bf       	out	0x3d, r28	; 61
	// Lag en tom buffer fylt med nuller eller mellomrom (0 er nok, fordi funksjonen oversetter til ' ')
	char empty_buffer[128] = {0};  // Heile skjermen, 128 tegn
    1100:	ce 01       	movw	r24, r28
    1102:	01 96       	adiw	r24, 0x01	; 1
    1104:	20 e8       	ldi	r18, 0x80	; 128
    1106:	fc 01       	movw	r30, r24
    1108:	11 92       	st	Z+, r1
    110a:	2a 95       	dec	r18
    110c:	e9 f7       	brne	.-6      	; 0x1108 <oled_clear_screen+0x1e>

	// Skriv den tomme bufferen til SRAM, som vil tømme skjermen
	oled_write_screen_to_SRAM(empty_buffer);
    110e:	0e 94 21 07 	call	0xe42	; 0xe42 <oled_write_screen_to_SRAM>
}
    1112:	c0 58       	subi	r28, 0x80	; 128
    1114:	df 4f       	sbci	r29, 0xFF	; 255
    1116:	0f b6       	in	r0, 0x3f	; 63
    1118:	f8 94       	cli
    111a:	de bf       	out	0x3e, r29	; 62
    111c:	0f be       	out	0x3f, r0	; 63
    111e:	cd bf       	out	0x3d, r28	; 61
    1120:	df 91       	pop	r29
    1122:	cf 91       	pop	r28
    1124:	08 95       	ret

00001126 <oled_draw_line>:

void oled_draw_line(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1) {
    1126:	6f 92       	push	r6
    1128:	7f 92       	push	r7
    112a:	8f 92       	push	r8
    112c:	9f 92       	push	r9
    112e:	af 92       	push	r10
    1130:	bf 92       	push	r11
    1132:	cf 92       	push	r12
    1134:	df 92       	push	r13
    1136:	ef 92       	push	r14
    1138:	ff 92       	push	r15
    113a:	0f 93       	push	r16
    113c:	1f 93       	push	r17
    113e:	cf 93       	push	r28
    1140:	df 93       	push	r29
    1142:	c8 2f       	mov	r28, r24
    1144:	d6 2f       	mov	r29, r22
    1146:	94 2e       	mov	r9, r20
    1148:	62 2e       	mov	r6, r18
	int dx = abs(x1 - x0);
    114a:	84 2f       	mov	r24, r20
    114c:	90 e0       	ldi	r25, 0x00	; 0
    114e:	8c 1b       	sub	r24, r28
    1150:	91 09       	sbc	r25, r1
    1152:	7c 01       	movw	r14, r24
    1154:	22 f4       	brpl	.+8      	; 0x115e <oled_draw_line+0x38>
    1156:	ee 24       	eor	r14, r14
    1158:	ff 24       	eor	r15, r15
    115a:	e8 1a       	sub	r14, r24
    115c:	f9 0a       	sbc	r15, r25
	int dy = abs(y1 - y0);
    115e:	86 2d       	mov	r24, r6
    1160:	90 e0       	ldi	r25, 0x00	; 0
    1162:	8d 1b       	sub	r24, r29
    1164:	91 09       	sbc	r25, r1
    1166:	5c 01       	movw	r10, r24
    1168:	22 f4       	brpl	.+8      	; 0x1172 <oled_draw_line+0x4c>
    116a:	aa 24       	eor	r10, r10
    116c:	bb 24       	eor	r11, r11
    116e:	a8 1a       	sub	r10, r24
    1170:	b9 0a       	sbc	r11, r25
	int sx = (x0 < x1) ? 1 : -1;
    1172:	c9 15       	cp	r28, r9
    1174:	18 f0       	brcs	.+6      	; 0x117c <oled_draw_line+0x56>
    1176:	88 24       	eor	r8, r8
    1178:	8a 94       	dec	r8
    117a:	02 c0       	rjmp	.+4      	; 0x1180 <oled_draw_line+0x5a>
    117c:	88 24       	eor	r8, r8
    117e:	83 94       	inc	r8
	int sy = (y0 < y1) ? 1 : -1;
    1180:	d6 15       	cp	r29, r6
    1182:	18 f0       	brcs	.+6      	; 0x118a <oled_draw_line+0x64>
    1184:	77 24       	eor	r7, r7
    1186:	7a 94       	dec	r7
    1188:	02 c0       	rjmp	.+4      	; 0x118e <oled_draw_line+0x68>
    118a:	77 24       	eor	r7, r7
    118c:	73 94       	inc	r7
	int err = dx - dy;
    118e:	87 01       	movw	r16, r14
    1190:	0a 19       	sub	r16, r10
    1192:	1b 09       	sbc	r17, r11
	while (1) {
		oled_write_pixel_to_SRAM(y0, x0, 1);  // Tegn piksel

		if (x0 == x1 && y0 == y1) break;
		int e2 = 2 * err;
		if (e2 > -dy) {
    1194:	cc 24       	eor	r12, r12
    1196:	dd 24       	eor	r13, r13
    1198:	ca 18       	sub	r12, r10
    119a:	db 08       	sbc	r13, r11
	int sx = (x0 < x1) ? 1 : -1;
	int sy = (y0 < y1) ? 1 : -1;
	int err = dx - dy;

	while (1) {
		oled_write_pixel_to_SRAM(y0, x0, 1);  // Tegn piksel
    119c:	41 e0       	ldi	r20, 0x01	; 1
    119e:	6c 2f       	mov	r22, r28
    11a0:	8d 2f       	mov	r24, r29
    11a2:	0e 94 41 08 	call	0x1082	; 0x1082 <oled_write_pixel_to_SRAM>

		if (x0 == x1 && y0 == y1) break;
    11a6:	c9 11       	cpse	r28, r9
    11a8:	02 c0       	rjmp	.+4      	; 0x11ae <oled_draw_line+0x88>
    11aa:	d6 15       	cp	r29, r6
    11ac:	81 f0       	breq	.+32     	; 0x11ce <oled_draw_line+0xa8>
		int e2 = 2 * err;
    11ae:	c8 01       	movw	r24, r16
    11b0:	88 0f       	add	r24, r24
    11b2:	99 1f       	adc	r25, r25
		if (e2 > -dy) {
    11b4:	c8 16       	cp	r12, r24
    11b6:	d9 06       	cpc	r13, r25
    11b8:	1c f4       	brge	.+6      	; 0x11c0 <oled_draw_line+0x9a>
			err -= dy;
    11ba:	0a 19       	sub	r16, r10
    11bc:	1b 09       	sbc	r17, r11
			x0 += sx;
    11be:	c8 0d       	add	r28, r8
		}
		if (e2 < dx) {
    11c0:	8e 15       	cp	r24, r14
    11c2:	9f 05       	cpc	r25, r15
    11c4:	5c f7       	brge	.-42     	; 0x119c <oled_draw_line+0x76>
			err += dx;
    11c6:	0e 0d       	add	r16, r14
    11c8:	1f 1d       	adc	r17, r15
			y0 += sy;
    11ca:	d7 0d       	add	r29, r7
    11cc:	e7 cf       	rjmp	.-50     	; 0x119c <oled_draw_line+0x76>
		}
	}
}
    11ce:	df 91       	pop	r29
    11d0:	cf 91       	pop	r28
    11d2:	1f 91       	pop	r17
    11d4:	0f 91       	pop	r16
    11d6:	ff 90       	pop	r15
    11d8:	ef 90       	pop	r14
    11da:	df 90       	pop	r13
    11dc:	cf 90       	pop	r12
    11de:	bf 90       	pop	r11
    11e0:	af 90       	pop	r10
    11e2:	9f 90       	pop	r9
    11e4:	8f 90       	pop	r8
    11e6:	7f 90       	pop	r7
    11e8:	6f 90       	pop	r6
    11ea:	08 95       	ret

000011ec <oled_draw_circle>:

void oled_draw_circle(uint8_t x0, uint8_t y0, uint8_t radius) {
    11ec:	9f 92       	push	r9
    11ee:	af 92       	push	r10
    11f0:	bf 92       	push	r11
    11f2:	cf 92       	push	r12
    11f4:	df 92       	push	r13
    11f6:	ef 92       	push	r14
    11f8:	ff 92       	push	r15
    11fa:	0f 93       	push	r16
    11fc:	1f 93       	push	r17
    11fe:	cf 93       	push	r28
    1200:	df 93       	push	r29
    1202:	98 2e       	mov	r9, r24
    1204:	c6 2e       	mov	r12, r22
	int x = radius;
    1206:	c4 2f       	mov	r28, r20
    1208:	d0 e0       	ldi	r29, 0x00	; 0
    120a:	a1 2c       	mov	r10, r1
    120c:	b1 2c       	mov	r11, r1
    120e:	00 e0       	ldi	r16, 0x00	; 0
    1210:	10 e0       	ldi	r17, 0x00	; 0
	int y = 0;
	int err = 0;

	while (x >= y) {
		oled_write_pixel_to_SRAM(y0 + y, x0 + x, 1);
    1212:	41 e0       	ldi	r20, 0x01	; 1
    1214:	fc 2e       	mov	r15, r28
    1216:	f9 0c       	add	r15, r9
    1218:	6f 2d       	mov	r22, r15
    121a:	dc 2c       	mov	r13, r12
    121c:	d0 0e       	add	r13, r16
    121e:	8d 2d       	mov	r24, r13
    1220:	0e 94 41 08 	call	0x1082	; 0x1082 <oled_write_pixel_to_SRAM>
		oled_write_pixel_to_SRAM(y0 + y, x0 - x, 1);
    1224:	41 e0       	ldi	r20, 0x01	; 1
    1226:	e9 2c       	mov	r14, r9
    1228:	ec 1a       	sub	r14, r28
    122a:	6e 2d       	mov	r22, r14
    122c:	8d 2d       	mov	r24, r13
    122e:	0e 94 41 08 	call	0x1082	; 0x1082 <oled_write_pixel_to_SRAM>
		oled_write_pixel_to_SRAM(y0 - y, x0 + x, 1);
    1232:	41 e0       	ldi	r20, 0x01	; 1
    1234:	6f 2d       	mov	r22, r15
    1236:	fc 2c       	mov	r15, r12
    1238:	f0 1a       	sub	r15, r16
    123a:	8f 2d       	mov	r24, r15
    123c:	0e 94 41 08 	call	0x1082	; 0x1082 <oled_write_pixel_to_SRAM>
		oled_write_pixel_to_SRAM(y0 - y, x0 - x, 1);
    1240:	41 e0       	ldi	r20, 0x01	; 1
    1242:	6e 2d       	mov	r22, r14
    1244:	8f 2d       	mov	r24, r15
    1246:	0e 94 41 08 	call	0x1082	; 0x1082 <oled_write_pixel_to_SRAM>
		oled_write_pixel_to_SRAM(y0 + x, x0 + y, 1);
    124a:	41 e0       	ldi	r20, 0x01	; 1
    124c:	f9 2c       	mov	r15, r9
    124e:	f0 0e       	add	r15, r16
    1250:	6f 2d       	mov	r22, r15
    1252:	dc 2e       	mov	r13, r28
    1254:	dc 0c       	add	r13, r12
    1256:	8d 2d       	mov	r24, r13
    1258:	0e 94 41 08 	call	0x1082	; 0x1082 <oled_write_pixel_to_SRAM>
		oled_write_pixel_to_SRAM(y0 + x, x0 - y, 1);
    125c:	41 e0       	ldi	r20, 0x01	; 1
    125e:	e9 2c       	mov	r14, r9
    1260:	e0 1a       	sub	r14, r16
    1262:	6e 2d       	mov	r22, r14
    1264:	8d 2d       	mov	r24, r13
    1266:	0e 94 41 08 	call	0x1082	; 0x1082 <oled_write_pixel_to_SRAM>
		oled_write_pixel_to_SRAM(y0 - x, x0 + y, 1);
    126a:	41 e0       	ldi	r20, 0x01	; 1
    126c:	6f 2d       	mov	r22, r15
    126e:	fc 2c       	mov	r15, r12
    1270:	fc 1a       	sub	r15, r28
    1272:	8f 2d       	mov	r24, r15
    1274:	0e 94 41 08 	call	0x1082	; 0x1082 <oled_write_pixel_to_SRAM>
		oled_write_pixel_to_SRAM(y0 - x, x0 - y, 1);
    1278:	41 e0       	ldi	r20, 0x01	; 1
    127a:	6e 2d       	mov	r22, r14
    127c:	8f 2d       	mov	r24, r15
    127e:	0e 94 41 08 	call	0x1082	; 0x1082 <oled_write_pixel_to_SRAM>

		if (err <= 0) {
    1282:	1a 14       	cp	r1, r10
    1284:	1b 04       	cpc	r1, r11
    1286:	5c f0       	brlt	.+22     	; 0x129e <oled_draw_circle+0xb2>
			y += 1;
    1288:	0f 5f       	subi	r16, 0xFF	; 255
    128a:	1f 4f       	sbci	r17, 0xFF	; 255
			err += 2 * y + 1;
    128c:	c8 01       	movw	r24, r16
    128e:	88 0f       	add	r24, r24
    1290:	99 1f       	adc	r25, r25
    1292:	01 96       	adiw	r24, 0x01	; 1
    1294:	a8 0e       	add	r10, r24
    1296:	b9 1e       	adc	r11, r25
		}
		if (err > 0) {
    1298:	1a 14       	cp	r1, r10
    129a:	1b 04       	cpc	r1, r11
    129c:	3c f4       	brge	.+14     	; 0x12ac <oled_draw_circle+0xc0>
			x -= 1;
    129e:	21 97       	sbiw	r28, 0x01	; 1
			err -= 2 * x + 1;
    12a0:	ce 01       	movw	r24, r28
    12a2:	88 0f       	add	r24, r24
    12a4:	99 1f       	adc	r25, r25
    12a6:	01 96       	adiw	r24, 0x01	; 1
    12a8:	a8 1a       	sub	r10, r24
    12aa:	b9 0a       	sbc	r11, r25
void oled_draw_circle(uint8_t x0, uint8_t y0, uint8_t radius) {
	int x = radius;
	int y = 0;
	int err = 0;

	while (x >= y) {
    12ac:	c0 17       	cp	r28, r16
    12ae:	d1 07       	cpc	r29, r17
    12b0:	0c f0       	brlt	.+2      	; 0x12b4 <oled_draw_circle+0xc8>
    12b2:	af cf       	rjmp	.-162    	; 0x1212 <oled_draw_circle+0x26>
		if (err > 0) {
			x -= 1;
			err -= 2 * x + 1;
		}
	}
}
    12b4:	df 91       	pop	r29
    12b6:	cf 91       	pop	r28
    12b8:	1f 91       	pop	r17
    12ba:	0f 91       	pop	r16
    12bc:	ff 90       	pop	r15
    12be:	ef 90       	pop	r14
    12c0:	df 90       	pop	r13
    12c2:	cf 90       	pop	r12
    12c4:	bf 90       	pop	r11
    12c6:	af 90       	pop	r10
    12c8:	9f 90       	pop	r9
    12ca:	08 95       	ret

000012cc <oled_draw_square>:

void oled_draw_square(uint8_t x0, uint8_t y0, uint8_t width, uint8_t height) {
    12cc:	0f 93       	push	r16
    12ce:	1f 93       	push	r17
    12d0:	cf 93       	push	r28
    12d2:	df 93       	push	r29
    12d4:	08 2f       	mov	r16, r24
    12d6:	16 2f       	mov	r17, r22
    12d8:	d2 2f       	mov	r29, r18
	oled_draw_line(x0, y0, x0 + width, y0);           // Øvre linje
    12da:	c8 2f       	mov	r28, r24
    12dc:	c4 0f       	add	r28, r20
    12de:	26 2f       	mov	r18, r22
    12e0:	4c 2f       	mov	r20, r28
    12e2:	0e 94 93 08 	call	0x1126	; 0x1126 <oled_draw_line>
	oled_draw_line(x0, y0 + height, x0 + width, y0 + height);  // Nedre linje
    12e6:	d1 0f       	add	r29, r17
    12e8:	2d 2f       	mov	r18, r29
    12ea:	4c 2f       	mov	r20, r28
    12ec:	6d 2f       	mov	r22, r29
    12ee:	80 2f       	mov	r24, r16
    12f0:	0e 94 93 08 	call	0x1126	; 0x1126 <oled_draw_line>
	oled_draw_line(x0, y0, x0, y0 + height);           // Venstre linje
    12f4:	2d 2f       	mov	r18, r29
    12f6:	40 2f       	mov	r20, r16
    12f8:	61 2f       	mov	r22, r17
    12fa:	80 2f       	mov	r24, r16
    12fc:	0e 94 93 08 	call	0x1126	; 0x1126 <oled_draw_line>
	oled_draw_line(x0 + width, y0, x0 + width, y0 + height);   // Høyre linje
    1300:	2d 2f       	mov	r18, r29
    1302:	4c 2f       	mov	r20, r28
    1304:	61 2f       	mov	r22, r17
    1306:	8c 2f       	mov	r24, r28
    1308:	0e 94 93 08 	call	0x1126	; 0x1126 <oled_draw_line>
}
    130c:	df 91       	pop	r29
    130e:	cf 91       	pop	r28
    1310:	1f 91       	pop	r17
    1312:	0f 91       	pop	r16
    1314:	08 95       	ret

00001316 <__vector_15>:

// Definer den globale variabelen for å telje millisekund
volatile uint32_t overflow_count = 0;

// Timer-overflyt interrupt service rutine
ISR(TIMER1_OVF_vect) {
    1316:	1f 92       	push	r1
    1318:	0f 92       	push	r0
    131a:	0f b6       	in	r0, 0x3f	; 63
    131c:	0f 92       	push	r0
    131e:	11 24       	eor	r1, r1
    1320:	8f 93       	push	r24
    1322:	9f 93       	push	r25
    1324:	af 93       	push	r26
    1326:	bf 93       	push	r27
	overflow_count++;
    1328:	80 91 bd 01 	lds	r24, 0x01BD	; 0x8001bd <overflow_count>
    132c:	90 91 be 01 	lds	r25, 0x01BE	; 0x8001be <overflow_count+0x1>
    1330:	a0 91 bf 01 	lds	r26, 0x01BF	; 0x8001bf <overflow_count+0x2>
    1334:	b0 91 c0 01 	lds	r27, 0x01C0	; 0x8001c0 <overflow_count+0x3>
    1338:	01 96       	adiw	r24, 0x01	; 1
    133a:	a1 1d       	adc	r26, r1
    133c:	b1 1d       	adc	r27, r1
    133e:	80 93 bd 01 	sts	0x01BD, r24	; 0x8001bd <overflow_count>
    1342:	90 93 be 01 	sts	0x01BE, r25	; 0x8001be <overflow_count+0x1>
    1346:	a0 93 bf 01 	sts	0x01BF, r26	; 0x8001bf <overflow_count+0x2>
    134a:	b0 93 c0 01 	sts	0x01C0, r27	; 0x8001c0 <overflow_count+0x3>
}
    134e:	bf 91       	pop	r27
    1350:	af 91       	pop	r26
    1352:	9f 91       	pop	r25
    1354:	8f 91       	pop	r24
    1356:	0f 90       	pop	r0
    1358:	0f be       	out	0x3f, r0	; 63
    135a:	0f 90       	pop	r0
    135c:	1f 90       	pop	r1
    135e:	18 95       	reti

00001360 <get_time_in_cycles>:
}

uint32_t get_time_in_cycles(void) {
	// Returner tiden i klokkesykluser
	// Hver gang timeren overflyter, har vi telt 65536 klokkesykluser
	return (overflow_count * 65536UL) + TCNT1;
    1360:	80 91 bd 01 	lds	r24, 0x01BD	; 0x8001bd <overflow_count>
    1364:	90 91 be 01 	lds	r25, 0x01BE	; 0x8001be <overflow_count+0x1>
    1368:	a0 91 bf 01 	lds	r26, 0x01BF	; 0x8001bf <overflow_count+0x2>
    136c:	b0 91 c0 01 	lds	r27, 0x01C0	; 0x8001c0 <overflow_count+0x3>
    1370:	2c b5       	in	r18, 0x2c	; 44
    1372:	3d b5       	in	r19, 0x2d	; 45
    1374:	dc 01       	movw	r26, r24
    1376:	99 27       	eor	r25, r25
    1378:	88 27       	eor	r24, r24
    137a:	bc 01       	movw	r22, r24
    137c:	cd 01       	movw	r24, r26
    137e:	62 0f       	add	r22, r18
    1380:	73 1f       	adc	r23, r19
    1382:	81 1d       	adc	r24, r1
    1384:	91 1d       	adc	r25, r1
}
    1386:	08 95       	ret

00001388 <get_time_in_ms>:
	overflow_count++;
}

// Funksjon som returnerer tida i millisekund sidan programstart
uint32_t get_time_in_ms(void){
	return get_time_in_cycles()/(4915200UL/1000);
    1388:	0e 94 b0 09 	call	0x1360	; 0x1360 <get_time_in_cycles>
    138c:	23 e3       	ldi	r18, 0x33	; 51
    138e:	33 e1       	ldi	r19, 0x13	; 19
    1390:	40 e0       	ldi	r20, 0x00	; 0
    1392:	50 e0       	ldi	r21, 0x00	; 0
    1394:	0e 94 45 0a 	call	0x148a	; 0x148a <__udivmodsi4>
}
    1398:	ca 01       	movw	r24, r20
    139a:	b9 01       	movw	r22, r18
    139c:	08 95       	ret

0000139e <setup_timer>:
}

// Funksjon for å setje opp Timer1 til å generere 1 ms avbrot
void setup_timer() {
	// Sett normal modus (WGM12 = 0)
	TCCR1A = 0;      // Normal mode
    139e:	1f bc       	out	0x2f, r1	; 47
	TCCR1B = (1 << CS10); // Prescaler = 1 (ingen prescaling, f_CPU direkte)
    13a0:	81 e0       	ldi	r24, 0x01	; 1
    13a2:	8e bd       	out	0x2e, r24	; 46

	// Aktiver Timer1 overflow interrupt
	TIMSK = (1 << TOIE1);
    13a4:	80 e8       	ldi	r24, 0x80	; 128
    13a6:	89 bf       	out	0x39, r24	; 57

	// Nullstill Timer/Counter1
	TCNT1 = 0;
    13a8:	1d bc       	out	0x2d, r1	; 45
    13aa:	1c bc       	out	0x2c, r1	; 44
    13ac:	08 95       	ret

000013ae <restart_timer>:
}
void restart_timer(){
	// Nullstill Timer/Counter1
	TCNT1 = 0;
    13ae:	1d bc       	out	0x2d, r1	; 45
    13b0:	1c bc       	out	0x2c, r1	; 44
	overflow_count = 0;
    13b2:	10 92 bd 01 	sts	0x01BD, r1	; 0x8001bd <overflow_count>
    13b6:	10 92 be 01 	sts	0x01BE, r1	; 0x8001be <overflow_count+0x1>
    13ba:	10 92 bf 01 	sts	0x01BF, r1	; 0x8001bf <overflow_count+0x2>
    13be:	10 92 c0 01 	sts	0x01C0, r1	; 0x8001c0 <overflow_count+0x3>
    13c2:	08 95       	ret

000013c4 <externalMemoryInit>:
 */ 
#include "XMEM_Decode.h"
// Funksjon for ï¿½ initialisere det eksterne minnet (SRAM + latch)
void externalMemoryInit(void) {
	// Set Port A (AD0-AD7) og Port C (A8-A15) som utgang for adresse- og databuss
	DDRA = 0xFF;  // PA0-PA7 som utgang
    13c4:	8f ef       	ldi	r24, 0xFF	; 255
    13c6:	8a bb       	out	0x1a, r24	; 26
	DDRC = 0x0F ;  // PC0-PC3 som utgang
    13c8:	8f e0       	ldi	r24, 0x0F	; 15
    13ca:	84 bb       	out	0x14, r24	; 20
	
	// Set Port D (PD6 og PD7) som utgang for WR og RD signal
	setBit(DDRD, PD6);  // WR
    13cc:	8e 9a       	sbi	0x11, 6	; 17
	setBit(DDRD, PD7);  // RD
    13ce:	8f 9a       	sbi	0x11, 7	; 17

	// Set Port E (PE1) som utgang for ALE
	setBit(DDRE, PE1);  // ALE
    13d0:	31 9a       	sbi	0x06, 1	; 6

	// Aktivere ekstern minnegrensesnitt
	setBit(MCUCR, SRE);   // Enable external SRAM interface
    13d2:	85 b7       	in	r24, 0x35	; 53
    13d4:	80 68       	ori	r24, 0x80	; 128
    13d6:	85 bf       	out	0x35, r24	; 53
	SFIOR = 0x00;         // No wait state
    13d8:	10 be       	out	0x30, r1	; 48
	
	//Maskes pc4-pc7 (disables as output) (s32 ATmega datasheet)
	setBit(SFIOR, XMM2);
    13da:	80 b7       	in	r24, 0x30	; 48
    13dc:	80 62       	ori	r24, 0x20	; 32
    13de:	80 bf       	out	0x30, r24	; 48
    13e0:	08 95       	ret

000013e2 <SRAM_write>:
}


// Funksjon for ï¿½ skrive data til SRAM
void SRAM_write(volatile uint16_t addr, uint8_t data) {
    13e2:	cf 93       	push	r28
    13e4:	df 93       	push	r29
    13e6:	00 d0       	rcall	.+0      	; 0x13e8 <SRAM_write+0x6>
    13e8:	cd b7       	in	r28, 0x3d	; 61
    13ea:	de b7       	in	r29, 0x3e	; 62
    13ec:	9a 83       	std	Y+2, r25	; 0x02
    13ee:	89 83       	std	Y+1, r24	; 0x01
	volatile char *ext_ram = (char *) SRAM_START; // Startadresse for SRAM
	uint16_t ext_ram_size = SRAM_SIZE; // Stï¿½rrelsen pï¿½ SRAM (2 KB)
	ext_ram[addr] = data;
    13f0:	e9 81       	ldd	r30, Y+1	; 0x01
    13f2:	fa 81       	ldd	r31, Y+2	; 0x02
    13f4:	f8 5e       	subi	r31, 0xE8	; 232
    13f6:	60 83       	st	Z, r22
}
    13f8:	0f 90       	pop	r0
    13fa:	0f 90       	pop	r0
    13fc:	df 91       	pop	r29
    13fe:	cf 91       	pop	r28
    1400:	08 95       	ret

00001402 <SRAM_read>:

// Funksjon for ï¿½ lese data frï¿½ SRAM
uint8_t SRAM_read(volatile uint16_t addr) {
    1402:	cf 93       	push	r28
    1404:	df 93       	push	r29
    1406:	00 d0       	rcall	.+0      	; 0x1408 <SRAM_read+0x6>
    1408:	cd b7       	in	r28, 0x3d	; 61
    140a:	de b7       	in	r29, 0x3e	; 62
    140c:	9a 83       	std	Y+2, r25	; 0x02
    140e:	89 83       	std	Y+1, r24	; 0x01
	volatile char *ext_ram = (char *) SRAM_START; // Startadresse for SRAM
	uint16_t ext_ram_size = SRAM_SIZE; // Stï¿½rrelsen pï¿½ SRAM (2 KB)
	uint8_t data = ext_ram[addr];
    1410:	e9 81       	ldd	r30, Y+1	; 0x01
    1412:	fa 81       	ldd	r31, Y+2	; 0x02
    1414:	f8 5e       	subi	r31, 0xE8	; 232
    1416:	80 81       	ld	r24, Z
	
	return data;
}
    1418:	0f 90       	pop	r0
    141a:	0f 90       	pop	r0
    141c:	df 91       	pop	r29
    141e:	cf 91       	pop	r28
    1420:	08 95       	ret

00001422 <Universal_write>:

// Funksjon for ï¿½ skrive data til SRAM
void Universal_write(volatile uint16_t addr, uint8_t data) {
    1422:	cf 93       	push	r28
    1424:	df 93       	push	r29
    1426:	00 d0       	rcall	.+0      	; 0x1428 <Universal_write+0x6>
    1428:	cd b7       	in	r28, 0x3d	; 61
    142a:	de b7       	in	r29, 0x3e	; 62
    142c:	9a 83       	std	Y+2, r25	; 0x02
    142e:	89 83       	std	Y+1, r24	; 0x01
	volatile char *ext_ram = (char *) OLED_START; // Startadresse for SRAM
	ext_ram[addr] = data;
    1430:	e9 81       	ldd	r30, Y+1	; 0x01
    1432:	fa 81       	ldd	r31, Y+2	; 0x02
    1434:	f0 5f       	subi	r31, 0xF0	; 240
    1436:	60 83       	st	Z, r22
		
}
    1438:	0f 90       	pop	r0
    143a:	0f 90       	pop	r0
    143c:	df 91       	pop	r29
    143e:	cf 91       	pop	r28
    1440:	08 95       	ret

00001442 <Universal_read>:

// Funksjon for ï¿½ lese data frï¿½ SRAM
uint8_t Universal_read(volatile uint16_t addr) {
    1442:	cf 93       	push	r28
    1444:	df 93       	push	r29
    1446:	00 d0       	rcall	.+0      	; 0x1448 <Universal_read+0x6>
    1448:	cd b7       	in	r28, 0x3d	; 61
    144a:	de b7       	in	r29, 0x3e	; 62
    144c:	9a 83       	std	Y+2, r25	; 0x02
    144e:	89 83       	std	Y+1, r24	; 0x01
	volatile char *ext_ram = (char *) OLED_START; // Startadresse for SRAM
	uint8_t data = ext_ram[addr];
    1450:	e9 81       	ldd	r30, Y+1	; 0x01
    1452:	fa 81       	ldd	r31, Y+2	; 0x02
    1454:	f0 5f       	subi	r31, 0xF0	; 240
    1456:	80 81       	ld	r24, Z
	
	return data;
}
    1458:	0f 90       	pop	r0
    145a:	0f 90       	pop	r0
    145c:	df 91       	pop	r29
    145e:	cf 91       	pop	r28
    1460:	08 95       	ret

00001462 <__divmodhi4>:
    1462:	97 fb       	bst	r25, 7
    1464:	07 2e       	mov	r0, r23
    1466:	16 f4       	brtc	.+4      	; 0x146c <__divmodhi4+0xa>
    1468:	00 94       	com	r0
    146a:	07 d0       	rcall	.+14     	; 0x147a <__divmodhi4_neg1>
    146c:	77 fd       	sbrc	r23, 7
    146e:	09 d0       	rcall	.+18     	; 0x1482 <__divmodhi4_neg2>
    1470:	0e 94 67 0a 	call	0x14ce	; 0x14ce <__udivmodhi4>
    1474:	07 fc       	sbrc	r0, 7
    1476:	05 d0       	rcall	.+10     	; 0x1482 <__divmodhi4_neg2>
    1478:	3e f4       	brtc	.+14     	; 0x1488 <__divmodhi4_exit>

0000147a <__divmodhi4_neg1>:
    147a:	90 95       	com	r25
    147c:	81 95       	neg	r24
    147e:	9f 4f       	sbci	r25, 0xFF	; 255
    1480:	08 95       	ret

00001482 <__divmodhi4_neg2>:
    1482:	70 95       	com	r23
    1484:	61 95       	neg	r22
    1486:	7f 4f       	sbci	r23, 0xFF	; 255

00001488 <__divmodhi4_exit>:
    1488:	08 95       	ret

0000148a <__udivmodsi4>:
    148a:	a1 e2       	ldi	r26, 0x21	; 33
    148c:	1a 2e       	mov	r1, r26
    148e:	aa 1b       	sub	r26, r26
    1490:	bb 1b       	sub	r27, r27
    1492:	fd 01       	movw	r30, r26
    1494:	0d c0       	rjmp	.+26     	; 0x14b0 <__udivmodsi4_ep>

00001496 <__udivmodsi4_loop>:
    1496:	aa 1f       	adc	r26, r26
    1498:	bb 1f       	adc	r27, r27
    149a:	ee 1f       	adc	r30, r30
    149c:	ff 1f       	adc	r31, r31
    149e:	a2 17       	cp	r26, r18
    14a0:	b3 07       	cpc	r27, r19
    14a2:	e4 07       	cpc	r30, r20
    14a4:	f5 07       	cpc	r31, r21
    14a6:	20 f0       	brcs	.+8      	; 0x14b0 <__udivmodsi4_ep>
    14a8:	a2 1b       	sub	r26, r18
    14aa:	b3 0b       	sbc	r27, r19
    14ac:	e4 0b       	sbc	r30, r20
    14ae:	f5 0b       	sbc	r31, r21

000014b0 <__udivmodsi4_ep>:
    14b0:	66 1f       	adc	r22, r22
    14b2:	77 1f       	adc	r23, r23
    14b4:	88 1f       	adc	r24, r24
    14b6:	99 1f       	adc	r25, r25
    14b8:	1a 94       	dec	r1
    14ba:	69 f7       	brne	.-38     	; 0x1496 <__udivmodsi4_loop>
    14bc:	60 95       	com	r22
    14be:	70 95       	com	r23
    14c0:	80 95       	com	r24
    14c2:	90 95       	com	r25
    14c4:	9b 01       	movw	r18, r22
    14c6:	ac 01       	movw	r20, r24
    14c8:	bd 01       	movw	r22, r26
    14ca:	cf 01       	movw	r24, r30
    14cc:	08 95       	ret

000014ce <__udivmodhi4>:
    14ce:	aa 1b       	sub	r26, r26
    14d0:	bb 1b       	sub	r27, r27
    14d2:	51 e1       	ldi	r21, 0x11	; 17
    14d4:	07 c0       	rjmp	.+14     	; 0x14e4 <__udivmodhi4_ep>

000014d6 <__udivmodhi4_loop>:
    14d6:	aa 1f       	adc	r26, r26
    14d8:	bb 1f       	adc	r27, r27
    14da:	a6 17       	cp	r26, r22
    14dc:	b7 07       	cpc	r27, r23
    14de:	10 f0       	brcs	.+4      	; 0x14e4 <__udivmodhi4_ep>
    14e0:	a6 1b       	sub	r26, r22
    14e2:	b7 0b       	sbc	r27, r23

000014e4 <__udivmodhi4_ep>:
    14e4:	88 1f       	adc	r24, r24
    14e6:	99 1f       	adc	r25, r25
    14e8:	5a 95       	dec	r21
    14ea:	a9 f7       	brne	.-22     	; 0x14d6 <__udivmodhi4_loop>
    14ec:	80 95       	com	r24
    14ee:	90 95       	com	r25
    14f0:	bc 01       	movw	r22, r24
    14f2:	cd 01       	movw	r24, r26
    14f4:	08 95       	ret

000014f6 <strncpy_P>:
    14f6:	fb 01       	movw	r30, r22
    14f8:	dc 01       	movw	r26, r24
    14fa:	41 50       	subi	r20, 0x01	; 1
    14fc:	50 40       	sbci	r21, 0x00	; 0
    14fe:	48 f0       	brcs	.+18     	; 0x1512 <strncpy_P+0x1c>
    1500:	05 90       	lpm	r0, Z+
    1502:	0d 92       	st	X+, r0
    1504:	00 20       	and	r0, r0
    1506:	c9 f7       	brne	.-14     	; 0x14fa <strncpy_P+0x4>
    1508:	01 c0       	rjmp	.+2      	; 0x150c <strncpy_P+0x16>
    150a:	1d 92       	st	X+, r1
    150c:	41 50       	subi	r20, 0x01	; 1
    150e:	50 40       	sbci	r21, 0x00	; 0
    1510:	e0 f7       	brcc	.-8      	; 0x150a <strncpy_P+0x14>
    1512:	08 95       	ret

00001514 <strncpy>:
    1514:	fb 01       	movw	r30, r22
    1516:	dc 01       	movw	r26, r24
    1518:	41 50       	subi	r20, 0x01	; 1
    151a:	50 40       	sbci	r21, 0x00	; 0
    151c:	48 f0       	brcs	.+18     	; 0x1530 <strncpy+0x1c>
    151e:	01 90       	ld	r0, Z+
    1520:	0d 92       	st	X+, r0
    1522:	00 20       	and	r0, r0
    1524:	c9 f7       	brne	.-14     	; 0x1518 <strncpy+0x4>
    1526:	01 c0       	rjmp	.+2      	; 0x152a <strncpy+0x16>
    1528:	1d 92       	st	X+, r1
    152a:	41 50       	subi	r20, 0x01	; 1
    152c:	50 40       	sbci	r21, 0x00	; 0
    152e:	e0 f7       	brcc	.-8      	; 0x1528 <strncpy+0x14>
    1530:	08 95       	ret

00001532 <_exit>:
    1532:	f8 94       	cli

00001534 <__stop_program>:
    1534:	ff cf       	rjmp	.-2      	; 0x1534 <__stop_program>
