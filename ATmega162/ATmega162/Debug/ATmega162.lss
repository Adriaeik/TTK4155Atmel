
ATmega162.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000ba  00800100  00001524  000015b8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001524  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000001f  008001ba  008001ba  00001672  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001672  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000016a4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000288  00000000  00000000  000016e0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000030ec  00000000  00000000  00001968  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000011ef  00000000  00000000  00004a54  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001614  00000000  00000000  00005c43  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000724  00000000  00000000  00007258  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000ad2  00000000  00000000  0000797c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001cf0  00000000  00000000  0000844e  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000208  00000000  00000000  0000a13e  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 1c 03 	jmp	0x638	; 0x638 <__ctors_end>
       4:	0c 94 39 03 	jmp	0x672	; 0x672 <__bad_interrupt>
       8:	0c 94 39 03 	jmp	0x672	; 0x672 <__bad_interrupt>
       c:	0c 94 39 03 	jmp	0x672	; 0x672 <__bad_interrupt>
      10:	0c 94 39 03 	jmp	0x672	; 0x672 <__bad_interrupt>
      14:	0c 94 39 03 	jmp	0x672	; 0x672 <__bad_interrupt>
      18:	0c 94 39 03 	jmp	0x672	; 0x672 <__bad_interrupt>
      1c:	0c 94 39 03 	jmp	0x672	; 0x672 <__bad_interrupt>
      20:	0c 94 39 03 	jmp	0x672	; 0x672 <__bad_interrupt>
      24:	0c 94 39 03 	jmp	0x672	; 0x672 <__bad_interrupt>
      28:	0c 94 39 03 	jmp	0x672	; 0x672 <__bad_interrupt>
      2c:	0c 94 39 03 	jmp	0x672	; 0x672 <__bad_interrupt>
      30:	0c 94 39 03 	jmp	0x672	; 0x672 <__bad_interrupt>
      34:	0c 94 39 03 	jmp	0x672	; 0x672 <__bad_interrupt>
      38:	0c 94 39 03 	jmp	0x672	; 0x672 <__bad_interrupt>
      3c:	0c 94 82 09 	jmp	0x1304	; 0x1304 <__vector_15>
      40:	0c 94 39 03 	jmp	0x672	; 0x672 <__bad_interrupt>
      44:	0c 94 39 03 	jmp	0x672	; 0x672 <__bad_interrupt>
      48:	0c 94 39 03 	jmp	0x672	; 0x672 <__bad_interrupt>
      4c:	0c 94 66 03 	jmp	0x6cc	; 0x6cc <__vector_19>
      50:	0c 94 39 03 	jmp	0x672	; 0x672 <__bad_interrupt>
      54:	0c 94 39 03 	jmp	0x672	; 0x672 <__bad_interrupt>
      58:	0c 94 39 03 	jmp	0x672	; 0x672 <__bad_interrupt>
      5c:	0c 94 39 03 	jmp	0x672	; 0x672 <__bad_interrupt>
      60:	0c 94 39 03 	jmp	0x672	; 0x672 <__bad_interrupt>
      64:	0c 94 39 03 	jmp	0x672	; 0x672 <__bad_interrupt>
      68:	0c 94 39 03 	jmp	0x672	; 0x672 <__bad_interrupt>
      6c:	0c 94 39 03 	jmp	0x672	; 0x672 <__bad_interrupt>

00000070 <__trampolines_end>:
      70:	20 20       	and	r2, r0
      72:	5f 5f       	subi	r21, 0xFF	; 255
      74:	5f 5f       	subi	r21, 0xFF	; 255
      76:	5f 25       	eor	r21, r15
      78:	20 20       	and	r2, r0
      7a:	25 5f       	subi	r18, 0xF5	; 245
      7c:	5f 5f       	subi	r21, 0xFF	; 255
      7e:	5f 5f       	subi	r21, 0xFF	; 255
      80:	20 20       	and	r2, r0
      82:	2a 2a       	or	r2, r26
      84:	2a 2a       	or	r2, r26
      86:	2a 20       	and	r2, r10
      88:	20 20       	and	r2, r0
      8a:	2a 2a       	or	r2, r26
      8c:	2a 2a       	or	r2, r26
      8e:	2a 20       	and	r2, r10
      90:	20 2a       	or	r2, r16
      92:	20 20       	and	r2, r0
      94:	20 20       	and	r2, r0
      96:	20 2a       	or	r2, r16
      98:	20 2a       	or	r2, r16
      9a:	20 20       	and	r2, r0
      9c:	20 20       	and	r2, r0
      9e:	20 2a       	or	r2, r16
      a0:	20 2a       	or	r2, r16
      a2:	20 20       	and	r2, r0
      a4:	2a 2a       	or	r2, r26
      a6:	20 20       	and	r2, r0
      a8:	2a 20       	and	r2, r10
      aa:	20 2a       	or	r2, r16
      ac:	2a 20       	and	r2, r10
      ae:	20 2a       	or	r2, r16
      b0:	20 2a       	or	r2, r16
      b2:	20 20       	and	r2, r0
      b4:	20 20       	and	r2, r0
      b6:	20 20       	and	r2, r0
      b8:	2a 20       	and	r2, r10
      ba:	20 20       	and	r2, r0
      bc:	20 20       	and	r2, r0
      be:	20 2a       	or	r2, r16
      c0:	20 20       	and	r2, r0
      c2:	2a 20       	and	r2, r10
      c4:	20 20       	and	r2, r0
      c6:	20 2a       	or	r2, r16
      c8:	20 2a       	or	r2, r16
      ca:	20 20       	and	r2, r0
      cc:	20 20       	and	r2, r0
      ce:	2a 20       	and	r2, r10
      d0:	20 20       	and	r2, r0
      d2:	20 2a       	or	r2, r16
      d4:	2a 2a       	or	r2, r26
      d6:	2a 20       	and	r2, r10
      d8:	20 20       	and	r2, r0
      da:	2a 2a       	or	r2, r26
      dc:	2a 2a       	or	r2, r26
      de:	20 20       	and	r2, r0
      e0:	20 5c       	subi	r18, 0xC0	; 192
      e2:	5f 5f       	subi	r21, 0xFF	; 255
      e4:	5f 5f       	subi	r21, 0xFF	; 255
      e6:	5f 5f       	subi	r21, 0xFF	; 255
      e8:	5f 5f       	subi	r21, 0xFF	; 255
      ea:	5f 5f       	subi	r21, 0xFF	; 255
      ec:	5f 5f       	subi	r21, 0xFF	; 255
      ee:	5f 2f       	mov	r21, r31

000000f0 <solkors>:
      f0:	20 20 20 79 61 70 40 40 40 2a 20 20 20 20 20 20        yap@@@*      
     100:	20 20 20 23 40 40 40 23 20 20 20 2a 23 20 20 20        #@@@#   *#   
     110:	20 20 23 40 40 40 2a 20 20 2a 40 40 40 40 23 20       #@@@*  *@@@@# 
     120:	2a 20 20 2b 23 40 40 40 40 40 40 20 20 40 40 40     *  +#@@@@@@  @@@
     130:	40 40 20 20 20 2b 40 40 40 40 2a 20 20 20 40 40     @@   +@@@@*   @@
     140:	40 40 40 25 25 40 40 40 40 40 40 20 2b 20 20 2a     @@@%%@@@@@@ +  *
     150:	20 23 40 40 40 40 2a 20 20 2a 40 40 40 23 20 20      #@@@@*  *@@@#  
     160:	20 20 20 23 23 20 20 20 23 40 40 40 23 20 20 20        ##   #@@@#   

00000170 <font8x8_basic>:
	...
     178:	00 00 5f 00 00 00 00 00 00 07 00 07 00 00 00 00     .._.............
     188:	14 7f 14 7f 14 00 00 00 24 2a 7f 2a 12 00 00 00     ........$*.*....
     198:	23 13 08 64 62 00 00 00 36 49 56 20 50 00 00 00     #..db...6IV P...
     1a8:	00 08 07 03 00 00 00 00 00 1c 22 41 00 00 00 00     .........."A....
     1b8:	00 41 22 1c 00 00 00 00 14 08 3e 08 14 00 00 00     .A".......>.....
     1c8:	08 08 3e 08 08 00 00 00 00 50 30 00 00 00 00 00     ..>......P0.....
     1d8:	08 08 08 08 08 00 00 00 00 60 60 00 00 00 00 00     .........``.....
     1e8:	20 10 08 04 02 00 00 00 3e 51 49 45 3e 00 00 00      .......>QIE>...
     1f8:	00 42 7f 40 00 00 00 00 42 61 51 49 46 00 00 00     .B.@....BaQIF...
     208:	21 41 45 4b 31 00 00 00 18 14 12 7f 10 00 00 00     !AEK1...........
     218:	27 45 45 45 39 00 00 00 3c 4a 49 49 30 00 00 00     'EEE9...<JII0...
     228:	01 71 09 05 03 00 00 00 36 49 49 49 36 00 00 00     .q......6III6...
     238:	06 49 49 29 1e 00 00 00 00 36 36 00 00 00 00 00     .II).....66.....
     248:	00 56 36 00 00 00 00 00 08 14 22 41 00 00 00 00     .V6......."A....
     258:	14 14 14 14 14 14 00 00 41 22 14 08 00 00 00 00     ........A"......
     268:	02 01 51 09 06 00 00 00 3e 41 5d 5d 1e 00 00 00     ..Q.....>A]]....
     278:	7e 11 11 11 7e 00 00 00 7f 49 49 49 36 00 00 00     ~...~....III6...
     288:	3e 41 41 41 22 00 00 00 7f 41 41 22 1c 00 00 00     >AAA"....AA"....
     298:	7f 49 49 49 41 00 00 00 7f 09 09 09 01 00 00 00     .IIIA...........
     2a8:	3e 41 49 49 7a 00 00 00 7f 08 08 08 7f 00 00 00     >AIIz...........
     2b8:	00 41 7f 41 00 00 00 00 20 40 41 3f 01 00 00 00     .A.A.... @A?....
     2c8:	7f 08 14 22 41 00 00 00 7f 40 40 40 40 00 00 00     ..."A....@@@@...
     2d8:	7f 02 04 02 7f 00 00 00 7f 02 04 08 7f 00 00 00     ................
     2e8:	3e 41 41 41 3e 00 00 00 7f 09 09 09 06 00 00 00     >AAA>...........
     2f8:	3e 41 51 21 5e 00 00 00 7f 09 19 29 46 00 00 00     >AQ!^......)F...
     308:	46 49 49 49 31 00 00 00 01 01 7f 01 01 00 00 00     FIII1...........
     318:	3f 40 40 40 3f 00 00 00 1f 20 40 20 1f 00 00 00     ?@@@?.... @ ....
     328:	7f 20 18 20 7f 00 00 00 63 14 08 14 63 00 00 00     . . ....c...c...
     338:	03 04 78 04 03 00 00 00 61 51 49 45 43 00 00 00     ..x.....aQIEC...
     348:	00 3e 41 41 00 00 00 00 02 04 08 10 20 00 00 00     .>AA........ ...
     358:	00 41 41 3e 00 00 00 00 04 02 01 02 04 00 00 00     .AA>............
     368:	40 40 40 40 40 40 00 00 00 00 03 07 00 00 00 00     @@@@@@..........
     378:	20 54 54 54 78 00 00 00 7f 48 44 44 38 00 00 00      TTTx....HDD8...
     388:	38 44 44 44 20 00 00 00 38 44 44 48 7f 00 00 00     8DDD ...8DDH....
     398:	38 54 54 54 18 00 00 00 08 7e 09 01 02 00 00 00     8TTT.....~......
     3a8:	08 14 54 54 3c 00 00 00 7f 08 04 04 78 00 00 00     ..TT<.......x...
     3b8:	00 44 7d 40 00 00 00 00 20 40 44 3d 00 00 00 00     .D}@.... @D=....
     3c8:	00 7f 10 28 44 00 00 00 00 41 7f 40 00 00 00 00     ...(D....A.@....
     3d8:	7c 04 18 04 78 00 00 00 7c 08 04 04 78 00 00 00     |...x...|...x...
     3e8:	38 44 44 44 38 00 00 00 7c 14 14 14 08 00 00 00     8DDD8...|.......
     3f8:	08 14 14 18 7c 00 00 00 7c 08 04 04 08 00 00 00     ....|...|.......
     408:	48 54 54 54 20 00 00 00 04 3f 44 40 20 00 00 00     HTTT ....?D@ ...
     418:	3c 40 40 20 7c 00 00 00 1c 20 40 20 1c 00 00 00     <@@ |.... @ ....
     428:	3c 40 30 40 3c 00 00 00 44 28 10 28 44 00 00 00     <@0@<...D(.(D...
     438:	0c 50 50 50 3c 00 00 00 44 64 54 4c 44 00 00 00     .PPP<...DdTLD...
     448:	00 08 36 41 00 00 00 00 00 00 7f 00 00 00 00 00     ..6A............
     458:	00 41 36 08 00 00 00 00 08 04 08 10 08 00 00 00     .A6.............

00000468 <settingsMenuItems>:
     468:	20 53 6f 75 6e 64 20 20 20 20 20 20 20 20 00 00      Sound        ..
     478:	20 42 72 69 67 68 74 6e 65 73 73 20 20 20 00 00      Brightness   ..
     488:	20 43 6f 6e 74 72 6f 6c 73 20 20 20 20 20 00 00      Controls     ..
     498:	20 42 61 63 6b 20 20 20 20 20 20 20 20 20 00 00      Back         ..

000004a8 <scrollMenuItems>:
     4a8:	20 49 74 65 6d 20 31 20 20 42 41 43 4b 20 00 00      Item 1  BACK ..
     4b8:	20 49 74 65 6d 20 32 20 20 20 20 20 20 20 00 00      Item 2       ..
     4c8:	20 49 74 65 6d 20 33 20 20 20 20 20 20 20 00 00      Item 3       ..
     4d8:	20 49 74 65 6d 20 34 20 20 20 20 20 20 20 00 00      Item 4       ..
     4e8:	20 49 74 65 6d 20 35 20 20 20 20 20 20 20 00 00      Item 5       ..
     4f8:	20 49 74 65 6d 20 36 20 20 20 20 20 20 20 00 00      Item 6       ..
     508:	20 49 74 65 6d 20 37 20 20 20 20 20 20 20 00 00      Item 7       ..
     518:	20 49 74 65 6d 20 38 20 20 20 20 20 20 20 00 00      Item 8       ..
     528:	20 49 74 65 6d 20 39 20 20 20 20 20 20 20 00 00      Item 9       ..
     538:	20 49 74 65 6d 20 31 30 20 20 20 20 20 20 00 00      Item 10      ..
     548:	20 49 74 65 6d 20 31 31 20 20 20 20 20 20 00 00      Item 11      ..
     558:	20 49 74 65 6d 20 31 32 20 20 20 20 20 20 00 00      Item 12      ..
     568:	20 49 74 65 6d 20 31 33 20 20 20 20 20 20 00 00      Item 13      ..
     578:	20 49 74 65 6d 20 31 34 20 20 20 20 20 20 00 00      Item 14      ..
     588:	20 49 74 65 6d 20 31 35 20 20 20 20 20 20 00 00      Item 15      ..
     598:	20 49 74 65 6d 20 31 36 20 20 20 20 20 20 00 00      Item 16      ..
     5a8:	20 49 74 65 6d 20 31 37 20 20 20 20 20 20 00 00      Item 17      ..
     5b8:	20 49 74 65 6d 20 31 38 20 20 20 20 20 20 00 00      Item 18      ..
     5c8:	20 49 74 65 6d 20 31 39 20 20 20 20 20 20 00 00      Item 19      ..
     5d8:	20 49 74 65 6d 20 32 30 20 20 20 20 20 20 00 00      Item 20      ..

000005e8 <mainMenuItems>:
     5e8:	20 53 74 61 72 74 20 47 61 6d 65 20 20 20 00 00      Start Game   ..
     5f8:	20 53 65 74 74 69 6e 67 73 20 20 20 20 20 00 00      Settings     ..
     608:	20 48 69 67 68 20 53 63 6f 72 65 73 20 20 00 00      High Scores  ..
     618:	20 43 72 65 64 69 74 73 20 20 20 20 20 20 00 00      Credits      ..
     628:	20 45 78 69 74 20 20 20 20 20 20 20 20 20 00 00      Exit         ..

00000638 <__ctors_end>:
     638:	11 24       	eor	r1, r1
     63a:	1f be       	out	0x3f, r1	; 63
     63c:	cf ef       	ldi	r28, 0xFF	; 255
     63e:	d4 e0       	ldi	r29, 0x04	; 4
     640:	de bf       	out	0x3e, r29	; 62
     642:	cd bf       	out	0x3d, r28	; 61

00000644 <__do_copy_data>:
     644:	11 e0       	ldi	r17, 0x01	; 1
     646:	a0 e0       	ldi	r26, 0x00	; 0
     648:	b1 e0       	ldi	r27, 0x01	; 1
     64a:	e4 e2       	ldi	r30, 0x24	; 36
     64c:	f5 e1       	ldi	r31, 0x15	; 21
     64e:	02 c0       	rjmp	.+4      	; 0x654 <__do_copy_data+0x10>
     650:	05 90       	lpm	r0, Z+
     652:	0d 92       	st	X+, r0
     654:	aa 3b       	cpi	r26, 0xBA	; 186
     656:	b1 07       	cpc	r27, r17
     658:	d9 f7       	brne	.-10     	; 0x650 <__do_copy_data+0xc>

0000065a <__do_clear_bss>:
     65a:	21 e0       	ldi	r18, 0x01	; 1
     65c:	aa eb       	ldi	r26, 0xBA	; 186
     65e:	b1 e0       	ldi	r27, 0x01	; 1
     660:	01 c0       	rjmp	.+2      	; 0x664 <.do_clear_bss_start>

00000662 <.do_clear_bss_loop>:
     662:	1d 92       	st	X+, r1

00000664 <.do_clear_bss_start>:
     664:	a9 3d       	cpi	r26, 0xD9	; 217
     666:	b2 07       	cpc	r27, r18
     668:	e1 f7       	brne	.-8      	; 0x662 <.do_clear_bss_loop>
     66a:	0e 94 73 03 	call	0x6e6	; 0x6e6 <main>
     66e:	0c 94 90 0a 	jmp	0x1520	; 0x1520 <_exit>

00000672 <__bad_interrupt>:
     672:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000676 <UART_Init>:
	setBit(UCSR0B, RXCIE0);
}

// Deaktiver avbrot for når data blir mottatt
void UART_DisableReceiveInterrupt(void) {
	clearBit(UCSR0B, RXCIE0);
     676:	90 bd       	out	0x20, r25	; 32
     678:	89 b9       	out	0x09, r24	; 9
     67a:	54 9a       	sbi	0x0a, 4	; 10
     67c:	53 9a       	sbi	0x0a, 3	; 10
     67e:	8e e8       	ldi	r24, 0x8E	; 142
     680:	80 bd       	out	0x20, r24	; 32
     682:	08 95       	ret

00000684 <UART_SendChar>:
     684:	5d 9b       	sbis	0x0b, 5	; 11
     686:	fe cf       	rjmp	.-4      	; 0x684 <UART_SendChar>
     688:	8c b9       	out	0x0c, r24	; 12
     68a:	08 95       	ret

0000068c <UART_putChar>:
     68c:	0e 94 42 03 	call	0x684	; 0x684 <UART_SendChar>
     690:	80 e0       	ldi	r24, 0x00	; 0
     692:	90 e0       	ldi	r25, 0x00	; 0
     694:	08 95       	ret

00000696 <UART_ReceiveChar>:
     696:	5f 9b       	sbis	0x0b, 7	; 11
     698:	fe cf       	rjmp	.-4      	; 0x696 <UART_ReceiveChar>
     69a:	8c b1       	in	r24, 0x0c	; 12
     69c:	08 95       	ret

0000069e <UART_getChar>:
     69e:	cf 93       	push	r28
     6a0:	0e 94 4b 03 	call	0x696	; 0x696 <UART_ReceiveChar>
     6a4:	c8 2f       	mov	r28, r24
     6a6:	0e 94 42 03 	call	0x684	; 0x684 <UART_SendChar>
     6aa:	8c 2f       	mov	r24, r28
     6ac:	90 e0       	ldi	r25, 0x00	; 0
     6ae:	cf 91       	pop	r28
     6b0:	08 95       	ret

000006b2 <URAT_initStudio>:
     6b2:	e3 ed       	ldi	r30, 0xD3	; 211
     6b4:	f1 e0       	ldi	r31, 0x01	; 1
     6b6:	8e e0       	ldi	r24, 0x0E	; 14
     6b8:	91 e0       	ldi	r25, 0x01	; 1
     6ba:	93 83       	std	Z+3, r25	; 0x03
     6bc:	82 83       	std	Z+2, r24	; 0x02
     6be:	80 e0       	ldi	r24, 0x00	; 0
     6c0:	91 e0       	ldi	r25, 0x01	; 1
     6c2:	91 83       	std	Z+1, r25	; 0x01
     6c4:	80 83       	st	Z, r24
     6c6:	08 95       	ret

000006c8 <UART_EnableReceiveInterrupt>:
     6c8:	57 9a       	sbi	0x0a, 7	; 10
     6ca:	08 95       	ret

000006cc <__vector_19>:
}

// UART mottaksavbrotvektor USART0_RX_vect
ISR(USART0_RXC_vect) {
     6cc:	1f 92       	push	r1
     6ce:	0f 92       	push	r0
     6d0:	0f b6       	in	r0, 0x3f	; 63
     6d2:	0f 92       	push	r0
     6d4:	11 24       	eor	r1, r1
     6d6:	8f 93       	push	r24
	// Handter mottatt data
	char received = UDR0;
     6d8:	8c b1       	in	r24, 0x0c	; 12
}
     6da:	8f 91       	pop	r24
     6dc:	0f 90       	pop	r0
     6de:	0f be       	out	0x3f, r0	; 63
     6e0:	0f 90       	pop	r0
     6e2:	1f 90       	pop	r1
     6e4:	18 95       	reti

000006e6 <main>:

#include "DriverUART.h"
#include "SRAM.h"
#include "Menu_init.h"

int main(void) {
     6e6:	cf 93       	push	r28
     6e8:	df 93       	push	r29
     6ea:	cd b7       	in	r28, 0x3d	; 61
     6ec:	de b7       	in	r29, 0x3e	; 62
     6ee:	2f 97       	sbiw	r28, 0x0f	; 15
     6f0:	0f b6       	in	r0, 0x3f	; 63
     6f2:	f8 94       	cli
     6f4:	de bf       	out	0x3e, r29	; 62
     6f6:	0f be       	out	0x3f, r0	; 63
     6f8:	cd bf       	out	0x3d, r28	; 61
	/*_________________INITIALISERINGER START______________________*/
	// Initialiser UART med baudrate 9600
	UART_Init(MYUBBR);
     6fa:	8f e1       	ldi	r24, 0x1F	; 31
     6fc:	90 e0       	ldi	r25, 0x00	; 0
     6fe:	0e 94 3b 03 	call	0x676	; 0x676 <UART_Init>
	URAT_initStudio();
     702:	0e 94 59 03 	call	0x6b2	; 0x6b2 <URAT_initStudio>
	UART_EnableReceiveInterrupt();
     706:	0e 94 64 03 	call	0x6c8	; 0x6c8 <UART_EnableReceiveInterrupt>
    setup_timer();						// Start millisekundteljinga
     70a:	0e 94 c6 09 	call	0x138c	; 0x138c <setup_timer>
	sei();								// Aktiver globale avbrot
     70e:	78 94       	sei
	externalMemoryInit();				// Initialiser eksternt minne må vere etter sei
     710:	0e 94 d9 09 	call	0x13b2	; 0x13b2 <externalMemoryInit>
	initialize_menus();
     714:	0e 94 c0 04 	call	0x980	; 0x980 <initialize_menus>
	MultiBoard board;
	MultiBoard_Init(&board);			// Initialiser MultiBoard og kalibrer joystickens origo
     718:	ce 01       	movw	r24, r28
     71a:	01 96       	adiw	r24, 0x01	; 1
     71c:	0e 94 77 05 	call	0xaee	; 0xaee <MultiBoard_Init>
	oled_init();						// Initialiser OLED-skjermen
     720:	0e 94 8a 06 	call	0xd14	; 0xd14 <oled_init>
	//setup_printf_for_oled();			// Optional
	//SRAM_test();
	
	/*______MENY______*/
	current_menu = &mainMenu;
     724:	87 ec       	ldi	r24, 0xC7	; 199
     726:	91 e0       	ldi	r25, 0x01	; 1
     728:	90 93 bb 01 	sts	0x01BB, r25	; 0x8001bb <__data_end+0x1>
     72c:	80 93 ba 01 	sts	0x01BA, r24	; 0x8001ba <__data_end>
	

	/*_______TEST OLED______________________*/
	
	oled_home();
     730:	0e 94 83 06 	call	0xd06	; 0xd06 <oled_home>
	oled_write_screen_to_SRAM(smiley);
     734:	80 e7       	ldi	r24, 0x70	; 112
     736:	90 e0       	ldi	r25, 0x00	; 0
     738:	0e 94 1f 07 	call	0xe3e	; 0xe3e <oled_write_screen_to_SRAM>
	oled_data_from_SRAM();
     73c:	0e 94 cd 06 	call	0xd9a	; 0xd9a <oled_data_from_SRAM>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     740:	2f ef       	ldi	r18, 0xFF	; 255
     742:	8f ef       	ldi	r24, 0xFF	; 255
     744:	9e e0       	ldi	r25, 0x0E	; 14
     746:	21 50       	subi	r18, 0x01	; 1
     748:	80 40       	sbci	r24, 0x00	; 0
     74a:	90 40       	sbci	r25, 0x00	; 0
     74c:	e1 f7       	brne	.-8      	; 0x746 <main+0x60>
     74e:	00 c0       	rjmp	.+0      	; 0x750 <main+0x6a>
     750:	00 00       	nop
	_delay_ms(1000); //smile litt før start
	
	//linje og slikt
	oled_clear_screen();
     752:	0e 94 6c 08 	call	0x10d8	; 0x10d8 <oled_clear_screen>
	oled_draw_line(10, 10, 100, 50);
     756:	22 e3       	ldi	r18, 0x32	; 50
     758:	44 e6       	ldi	r20, 0x64	; 100
     75a:	6a e0       	ldi	r22, 0x0A	; 10
     75c:	8a e0       	ldi	r24, 0x0A	; 10
     75e:	0e 94 8a 08 	call	0x1114	; 0x1114 <oled_draw_line>
	oled_draw_circle(64, 32, 20);
     762:	44 e1       	ldi	r20, 0x14	; 20
     764:	50 e0       	ldi	r21, 0x00	; 0
     766:	60 e2       	ldi	r22, 0x20	; 32
     768:	70 e0       	ldi	r23, 0x00	; 0
     76a:	80 e4       	ldi	r24, 0x40	; 64
     76c:	90 e0       	ldi	r25, 0x00	; 0
     76e:	0e 94 ed 08 	call	0x11da	; 0x11da <oled_draw_circle>
	oled_draw_square(20, 20, 40, 30);
     772:	2e e1       	ldi	r18, 0x1E	; 30
     774:	48 e2       	ldi	r20, 0x28	; 40
     776:	64 e1       	ldi	r22, 0x14	; 20
     778:	84 e1       	ldi	r24, 0x14	; 20
     77a:	0e 94 5d 09 	call	0x12ba	; 0x12ba <oled_draw_square>
	oled_data_from_SRAM();
     77e:	0e 94 cd 06 	call	0xd9a	; 0xd9a <oled_data_from_SRAM>
     782:	2f ef       	ldi	r18, 0xFF	; 255
     784:	8f ef       	ldi	r24, 0xFF	; 255
     786:	95 e9       	ldi	r25, 0x95	; 149
     788:	21 50       	subi	r18, 0x01	; 1
     78a:	80 40       	sbci	r24, 0x00	; 0
     78c:	90 40       	sbci	r25, 0x00	; 0
     78e:	e1 f7       	brne	.-8      	; 0x788 <main+0xa2>
     790:	00 c0       	rjmp	.+0      	; 0x792 <main+0xac>
     792:	00 00       	nop
	_delay_ms(10000);
	
	/*_______HOVUDLØKKE______*/
	 while (1) {

        menu_navigate(&board, &current_menu);  // Kallar `menu_navigate` med referanse til gjeldande meny
     794:	6a eb       	ldi	r22, 0xBA	; 186
     796:	71 e0       	ldi	r23, 0x01	; 1
     798:	ce 01       	movw	r24, r28
     79a:	01 96       	adiw	r24, 0x01	; 1
     79c:	0e 94 96 04 	call	0x92c	; 0x92c <menu_navigate>
		
		/*Så lenge vi ikkje har noko delay gåandes og ditta står her tenker eg 
		at den oppdateres automatisk med det minnet vi har skreve til sramen?
		Det kunne vert fornuftig med eit flag her då
		*/
		if (get_time_in_ms() >= 16) {
     7a0:	0e 94 bb 09 	call	0x1376	; 0x1376 <get_time_in_ms>
     7a4:	60 31       	cpi	r22, 0x10	; 16
     7a6:	71 05       	cpc	r23, r1
     7a8:	81 05       	cpc	r24, r1
     7aa:	91 05       	cpc	r25, r1
     7ac:	98 f3       	brcs	.-26     	; 0x794 <main+0xae>
			restart_timer();
     7ae:	0e 94 ce 09 	call	0x139c	; 0x139c <restart_timer>
			oled_data_from_SRAM();
     7b2:	0e 94 cd 06 	call	0xd9a	; 0xd9a <oled_data_from_SRAM>
     7b6:	ee cf       	rjmp	.-36     	; 0x794 <main+0xae>

000007b8 <oled_display_menu>:
}

// Sjekker om joystick-knappen er trykt
uint8_t is_joystick_button_pressed(MultiBoard* board) {
	return (board->JoyBtn != 0);  // Anta at knappen er aktiv-høg (1 betyr trykt)
}
     7b8:	cf 92       	push	r12
     7ba:	df 92       	push	r13
     7bc:	ef 92       	push	r14
     7be:	ff 92       	push	r15
     7c0:	1f 93       	push	r17
     7c2:	cf 93       	push	r28
     7c4:	df 93       	push	r29
     7c6:	cd b7       	in	r28, 0x3d	; 61
     7c8:	de b7       	in	r29, 0x3e	; 62
     7ca:	c0 59       	subi	r28, 0x90	; 144
     7cc:	d1 09       	sbc	r29, r1
     7ce:	0f b6       	in	r0, 0x3f	; 63
     7d0:	f8 94       	cli
     7d2:	de bf       	out	0x3e, r29	; 62
     7d4:	0f be       	out	0x3f, r0	; 63
     7d6:	cd bf       	out	0x3d, r28	; 61
     7d8:	6c 01       	movw	r12, r24
     7da:	fe 01       	movw	r30, r28
     7dc:	71 96       	adiw	r30, 0x11	; 17
     7de:	80 e8       	ldi	r24, 0x80	; 128
     7e0:	df 01       	movw	r26, r30
     7e2:	1d 92       	st	X+, r1
     7e4:	8a 95       	dec	r24
     7e6:	e9 f7       	brne	.-6      	; 0x7e2 <oled_display_menu+0x2a>
     7e8:	7f 01       	movw	r14, r30
     7ea:	10 e0       	ldi	r17, 0x00	; 0
     7ec:	f6 01       	movw	r30, r12
     7ee:	84 81       	ldd	r24, Z+4	; 0x04
     7f0:	81 0f       	add	r24, r17
     7f2:	95 81       	ldd	r25, Z+5	; 0x05
     7f4:	89 17       	cp	r24, r25
     7f6:	a8 f4       	brcc	.+42     	; 0x822 <oled_display_menu+0x6a>
     7f8:	60 81       	ld	r22, Z
     7fa:	71 81       	ldd	r23, Z+1	; 0x01
     7fc:	f0 e1       	ldi	r31, 0x10	; 16
     7fe:	8f 9f       	mul	r24, r31
     800:	60 0d       	add	r22, r0
     802:	71 1d       	adc	r23, r1
     804:	11 24       	eor	r1, r1
     806:	40 e1       	ldi	r20, 0x10	; 16
     808:	50 e0       	ldi	r21, 0x00	; 0
     80a:	ce 01       	movw	r24, r28
     80c:	01 96       	adiw	r24, 0x01	; 1
     80e:	0e 94 72 0a 	call	0x14e4	; 0x14e4 <strncpy_P>
     812:	40 e1       	ldi	r20, 0x10	; 16
     814:	50 e0       	ldi	r21, 0x00	; 0
     816:	be 01       	movw	r22, r28
     818:	6f 5f       	subi	r22, 0xFF	; 255
     81a:	7f 4f       	sbci	r23, 0xFF	; 255
     81c:	c7 01       	movw	r24, r14
     81e:	0e 94 81 0a 	call	0x1502	; 0x1502 <strncpy>
     822:	1f 5f       	subi	r17, 0xFF	; 255
     824:	80 e1       	ldi	r24, 0x10	; 16
     826:	e8 0e       	add	r14, r24
     828:	f1 1c       	adc	r15, r1
     82a:	18 30       	cpi	r17, 0x08	; 8
     82c:	f9 f6       	brne	.-66     	; 0x7ec <oled_display_menu+0x34>
     82e:	ce 01       	movw	r24, r28
     830:	41 96       	adiw	r24, 0x11	; 17
     832:	0e 94 1f 07 	call	0xe3e	; 0xe3e <oled_write_screen_to_SRAM>
     836:	d6 01       	movw	r26, r12
     838:	12 96       	adiw	r26, 0x02	; 2
     83a:	8c 91       	ld	r24, X
     83c:	12 97       	sbiw	r26, 0x02	; 2
     83e:	14 96       	adiw	r26, 0x04	; 4
     840:	9c 91       	ld	r25, X
     842:	4e e3       	ldi	r20, 0x3E	; 62
     844:	60 e0       	ldi	r22, 0x00	; 0
     846:	89 1b       	sub	r24, r25
     848:	0e 94 fb 07 	call	0xff6	; 0xff6 <oled_write_char_to_SRAM>
     84c:	c0 57       	subi	r28, 0x70	; 112
     84e:	df 4f       	sbci	r29, 0xFF	; 255
     850:	0f b6       	in	r0, 0x3f	; 63
     852:	f8 94       	cli
     854:	de bf       	out	0x3e, r29	; 62
     856:	0f be       	out	0x3f, r0	; 63
     858:	cd bf       	out	0x3d, r28	; 61
     85a:	df 91       	pop	r29
     85c:	cf 91       	pop	r28
     85e:	1f 91       	pop	r17
     860:	ff 90       	pop	r15
     862:	ef 90       	pop	r14
     864:	df 90       	pop	r13
     866:	cf 90       	pop	r12
     868:	08 95       	ret

0000086a <update_menu_arrows>:
     86a:	cf 93       	push	r28
     86c:	c8 2f       	mov	r28, r24
     86e:	86 2f       	mov	r24, r22
     870:	40 e2       	ldi	r20, 0x20	; 32
     872:	60 e0       	ldi	r22, 0x00	; 0
     874:	0e 94 fb 07 	call	0xff6	; 0xff6 <oled_write_char_to_SRAM>
     878:	4e e3       	ldi	r20, 0x3E	; 62
     87a:	60 e0       	ldi	r22, 0x00	; 0
     87c:	8c 2f       	mov	r24, r28
     87e:	0e 94 fb 07 	call	0xff6	; 0xff6 <oled_write_char_to_SRAM>
     882:	cf 91       	pop	r28
     884:	08 95       	ret

00000886 <update_menu_position_from_joystick>:
     886:	fb 01       	movw	r30, r22
     888:	dc 01       	movw	r26, r24
     88a:	1b 96       	adiw	r26, 0x0b	; 11
     88c:	8d 91       	ld	r24, X+
     88e:	9c 91       	ld	r25, X
     890:	1c 97       	sbiw	r26, 0x0c	; 12
     892:	83 33       	cpi	r24, 0x33	; 51
     894:	91 05       	cpc	r25, r1
     896:	fc f0       	brlt	.+62     	; 0x8d6 <update_menu_position_from_joystick+0x50>
     898:	62 81       	ldd	r22, Z+2	; 0x02
     89a:	66 23       	and	r22, r22
     89c:	09 f4       	brne	.+2      	; 0x8a0 <update_menu_position_from_joystick+0x1a>
     89e:	45 c0       	rjmp	.+138    	; 0x92a <update_menu_position_from_joystick+0xa4>
     8a0:	63 83       	std	Z+3, r22	; 0x03
     8a2:	8f ef       	ldi	r24, 0xFF	; 255
     8a4:	86 0f       	add	r24, r22
     8a6:	82 83       	std	Z+2, r24	; 0x02
     8a8:	94 81       	ldd	r25, Z+4	; 0x04
     8aa:	89 17       	cp	r24, r25
     8ac:	30 f4       	brcc	.+12     	; 0x8ba <update_menu_position_from_joystick+0x34>
     8ae:	91 50       	subi	r25, 0x01	; 1
     8b0:	94 83       	std	Z+4, r25	; 0x04
     8b2:	cf 01       	movw	r24, r30
     8b4:	0e 94 dc 03 	call	0x7b8	; 0x7b8 <oled_display_menu>
     8b8:	04 c0       	rjmp	.+8      	; 0x8c2 <update_menu_position_from_joystick+0x3c>
     8ba:	69 1b       	sub	r22, r25
     8bc:	89 1b       	sub	r24, r25
     8be:	0e 94 35 04 	call	0x86a	; 0x86a <update_menu_arrows>
     8c2:	bf ef       	ldi	r27, 0xFF	; 255
     8c4:	2f ef       	ldi	r18, 0xFF	; 255
     8c6:	82 e0       	ldi	r24, 0x02	; 2
     8c8:	b1 50       	subi	r27, 0x01	; 1
     8ca:	20 40       	sbci	r18, 0x00	; 0
     8cc:	80 40       	sbci	r24, 0x00	; 0
     8ce:	e1 f7       	brne	.-8      	; 0x8c8 <update_menu_position_from_joystick+0x42>
     8d0:	00 c0       	rjmp	.+0      	; 0x8d2 <update_menu_position_from_joystick+0x4c>
     8d2:	00 c0       	rjmp	.+0      	; 0x8d4 <update_menu_position_from_joystick+0x4e>
     8d4:	08 95       	ret
     8d6:	8e 3c       	cpi	r24, 0xCE	; 206
     8d8:	9f 4f       	sbci	r25, 0xFF	; 255
     8da:	3c f5       	brge	.+78     	; 0x92a <update_menu_position_from_joystick+0xa4>
     8dc:	62 81       	ldd	r22, Z+2	; 0x02
     8de:	26 2f       	mov	r18, r22
     8e0:	30 e0       	ldi	r19, 0x00	; 0
     8e2:	85 81       	ldd	r24, Z+5	; 0x05
     8e4:	90 e0       	ldi	r25, 0x00	; 0
     8e6:	01 97       	sbiw	r24, 0x01	; 1
     8e8:	28 17       	cp	r18, r24
     8ea:	39 07       	cpc	r19, r25
     8ec:	f4 f4       	brge	.+60     	; 0x92a <update_menu_position_from_joystick+0xa4>
     8ee:	63 83       	std	Z+3, r22	; 0x03
     8f0:	81 e0       	ldi	r24, 0x01	; 1
     8f2:	86 0f       	add	r24, r22
     8f4:	82 83       	std	Z+2, r24	; 0x02
     8f6:	94 81       	ldd	r25, Z+4	; 0x04
     8f8:	48 2f       	mov	r20, r24
     8fa:	50 e0       	ldi	r21, 0x00	; 0
     8fc:	29 2f       	mov	r18, r25
     8fe:	30 e0       	ldi	r19, 0x00	; 0
     900:	28 5f       	subi	r18, 0xF8	; 248
     902:	3f 4f       	sbci	r19, 0xFF	; 255
     904:	42 17       	cp	r20, r18
     906:	53 07       	cpc	r21, r19
     908:	1c f0       	brlt	.+6      	; 0x910 <update_menu_position_from_joystick+0x8a>
     90a:	9f 5f       	subi	r25, 0xFF	; 255
     90c:	94 83       	std	Z+4, r25	; 0x04
     90e:	04 c0       	rjmp	.+8      	; 0x918 <update_menu_position_from_joystick+0x92>
     910:	69 1b       	sub	r22, r25
     912:	89 1b       	sub	r24, r25
     914:	0e 94 35 04 	call	0x86a	; 0x86a <update_menu_arrows>
     918:	bf ef       	ldi	r27, 0xFF	; 255
     91a:	2f ef       	ldi	r18, 0xFF	; 255
     91c:	82 e0       	ldi	r24, 0x02	; 2
     91e:	b1 50       	subi	r27, 0x01	; 1
     920:	20 40       	sbci	r18, 0x00	; 0
     922:	80 40       	sbci	r24, 0x00	; 0
     924:	e1 f7       	brne	.-8      	; 0x91e <update_menu_position_from_joystick+0x98>
     926:	00 c0       	rjmp	.+0      	; 0x928 <update_menu_position_from_joystick+0xa2>
     928:	00 c0       	rjmp	.+0      	; 0x92a <update_menu_position_from_joystick+0xa4>
     92a:	08 95       	ret

0000092c <menu_navigate>:

static uint8_t menu_changed = 1;  // Flag for å spore endringar i menyen
// Funksjon for å navigere i menyen uten blokkering
void menu_navigate(MultiBoard* board, Menu** menu) {
     92c:	0f 93       	push	r16
     92e:	1f 93       	push	r17
     930:	cf 93       	push	r28
     932:	df 93       	push	r29
     934:	ec 01       	movw	r28, r24
     936:	8b 01       	movw	r16, r22

	// Oppdater joystick- og menyposisjon
	MultiBoard_Update(board);
     938:	0e 94 0d 06 	call	0xc1a	; 0xc1a <MultiBoard_Update>
	update_menu_position_from_joystick(board, *menu);
     93c:	f8 01       	movw	r30, r16
     93e:	60 81       	ld	r22, Z
     940:	71 81       	ldd	r23, Z+1	; 0x01
     942:	ce 01       	movw	r24, r28
     944:	0e 94 43 04 	call	0x886	; 0x886 <update_menu_position_from_joystick>

	// Sjekk om menyen har endra seg
	if (menu_changed) {
     948:	80 91 1c 01 	lds	r24, 0x011C	; 0x80011c <menu_changed>
     94c:	88 23       	and	r24, r24
     94e:	39 f0       	breq	.+14     	; 0x95e <menu_navigate+0x32>
		oled_display_menu(*menu);  // Oppdater OLED med den nye menyen
     950:	f8 01       	movw	r30, r16
     952:	80 81       	ld	r24, Z
     954:	91 81       	ldd	r25, Z+1	; 0x01
     956:	0e 94 dc 03 	call	0x7b8	; 0x7b8 <oled_display_menu>
		menu_changed = 0;  // Nullstill flagget etter oppdatering
     95a:	10 92 1c 01 	sts	0x011C, r1	; 0x80011c <menu_changed>
	}

	// Sjekk om knappen er trykt for å bekrefte menyval
	if (is_joystick_button_pressed(board)) {
     95e:	8e 81       	ldd	r24, Y+6	; 0x06
     960:	88 23       	and	r24, r24
     962:	49 f0       	breq	.+18     	; 0x976 <menu_navigate+0x4a>
		oled_clear_screen();
     964:	0e 94 6c 08 	call	0x10d8	; 0x10d8 <oled_clear_screen>
		handleMenuSelection(board, menu);  // Behandlar menyvalet
     968:	b8 01       	movw	r22, r16
     96a:	ce 01       	movw	r24, r28
     96c:	0e 94 e2 04 	call	0x9c4	; 0x9c4 <handleMenuSelection>
		menu_changed = 1;  // Menyen vil endre seg etter valet
     970:	81 e0       	ldi	r24, 0x01	; 1
     972:	80 93 1c 01 	sts	0x011C, r24	; 0x80011c <menu_changed>
	}
}
     976:	df 91       	pop	r29
     978:	cf 91       	pop	r28
     97a:	1f 91       	pop	r17
     97c:	0f 91       	pop	r16
     97e:	08 95       	ret

00000980 <initialize_menus>:
Menu mainMenu;
Menu scrollMenu;
Menu settingsMenu;

void initialize_menus() {
	mainMenu.items = mainMenuItems;
     980:	e7 ec       	ldi	r30, 0xC7	; 199
     982:	f1 e0       	ldi	r31, 0x01	; 1
     984:	88 ee       	ldi	r24, 0xE8	; 232
     986:	95 e0       	ldi	r25, 0x05	; 5
     988:	91 83       	std	Z+1, r25	; 0x01
     98a:	80 83       	st	Z, r24
	mainMenu.num_items = 5;
     98c:	85 e0       	ldi	r24, 0x05	; 5
     98e:	85 83       	std	Z+5, r24	; 0x05
	mainMenu.current_position = 0;
     990:	12 82       	std	Z+2, r1	; 0x02
	mainMenu.prev_position = 0;
     992:	13 82       	std	Z+3, r1	; 0x03
	mainMenu.scroll_offset = 0;
     994:	14 82       	std	Z+4, r1	; 0x04

	scrollMenu.items = scrollMenuItems;
     996:	ed ec       	ldi	r30, 0xCD	; 205
     998:	f1 e0       	ldi	r31, 0x01	; 1
     99a:	88 ea       	ldi	r24, 0xA8	; 168
     99c:	94 e0       	ldi	r25, 0x04	; 4
     99e:	91 83       	std	Z+1, r25	; 0x01
     9a0:	80 83       	st	Z, r24
	scrollMenu.num_items = 20;
     9a2:	84 e1       	ldi	r24, 0x14	; 20
     9a4:	85 83       	std	Z+5, r24	; 0x05
	scrollMenu.current_position = 0;
     9a6:	12 82       	std	Z+2, r1	; 0x02
	scrollMenu.prev_position = 0;
     9a8:	13 82       	std	Z+3, r1	; 0x03
	scrollMenu.scroll_offset = 0;
     9aa:	14 82       	std	Z+4, r1	; 0x04

	settingsMenu.items = settingsMenuItems;
     9ac:	e1 ec       	ldi	r30, 0xC1	; 193
     9ae:	f1 e0       	ldi	r31, 0x01	; 1
     9b0:	88 e6       	ldi	r24, 0x68	; 104
     9b2:	94 e0       	ldi	r25, 0x04	; 4
     9b4:	91 83       	std	Z+1, r25	; 0x01
     9b6:	80 83       	st	Z, r24
	settingsMenu.num_items = 4;
     9b8:	84 e0       	ldi	r24, 0x04	; 4
     9ba:	85 83       	std	Z+5, r24	; 0x05
	settingsMenu.current_position = 0;
     9bc:	12 82       	std	Z+2, r1	; 0x02
	settingsMenu.prev_position = 0;
     9be:	13 82       	std	Z+3, r1	; 0x03
	settingsMenu.scroll_offset = 0;
     9c0:	14 82       	std	Z+4, r1	; 0x04
     9c2:	08 95       	ret

000009c4 <handleMenuSelection>:
}

void handleMenuSelection(MultiBoard* board, Menu* menu) {
	switch (currentMenuState) {
     9c4:	80 91 bc 01 	lds	r24, 0x01BC	; 0x8001bc <currentMenuState>
     9c8:	81 30       	cpi	r24, 0x01	; 1
     9ca:	09 f4       	brne	.+2      	; 0x9ce <handleMenuSelection+0xa>
     9cc:	6f c0       	rjmp	.+222    	; 0xaac <handleMenuSelection+0xe8>
     9ce:	20 f0       	brcs	.+8      	; 0x9d8 <handleMenuSelection+0x14>
     9d0:	82 30       	cpi	r24, 0x02	; 2
     9d2:	09 f4       	brne	.+2      	; 0x9d6 <handleMenuSelection+0x12>
     9d4:	40 c0       	rjmp	.+128    	; 0xa56 <handleMenuSelection+0x92>
     9d6:	08 95       	ret
		case MAIN_MENU:
		switch (menu->current_position) {
     9d8:	fb 01       	movw	r30, r22
     9da:	82 81       	ldd	r24, Z+2	; 0x02
     9dc:	82 30       	cpi	r24, 0x02	; 2
     9de:	d9 f0       	breq	.+54     	; 0xa16 <handleMenuSelection+0x52>
     9e0:	28 f4       	brcc	.+10     	; 0x9ec <handleMenuSelection+0x28>
     9e2:	88 23       	and	r24, r24
     9e4:	41 f0       	breq	.+16     	; 0x9f6 <handleMenuSelection+0x32>
     9e6:	81 30       	cpi	r24, 0x01	; 1
     9e8:	61 f0       	breq	.+24     	; 0xa02 <handleMenuSelection+0x3e>
     9ea:	2f c0       	rjmp	.+94     	; 0xa4a <handleMenuSelection+0x86>
     9ec:	83 30       	cpi	r24, 0x03	; 3
     9ee:	e9 f0       	breq	.+58     	; 0xa2a <handleMenuSelection+0x66>
     9f0:	84 30       	cpi	r24, 0x04	; 4
     9f2:	29 f1       	breq	.+74     	; 0xa3e <handleMenuSelection+0x7a>
     9f4:	2a c0       	rjmp	.+84     	; 0xa4a <handleMenuSelection+0x86>
			case 0:
			oled_write_line_to_SRAM(0, "Startar spelet...");
     9f6:	6d e1       	ldi	r22, 0x1D	; 29
     9f8:	71 e0       	ldi	r23, 0x01	; 1
     9fa:	80 e0       	ldi	r24, 0x00	; 0
     9fc:	0e 94 83 07 	call	0xf06	; 0xf06 <oled_write_line_to_SRAM>
			break;
     a00:	08 95       	ret
			case 1:
			// Gå til innstillingar
			currentMenuState = SETTINGS_MENU;
     a02:	82 e0       	ldi	r24, 0x02	; 2
     a04:	80 93 bc 01 	sts	0x01BC, r24	; 0x8001bc <currentMenuState>
			current_menu = &settingsMenu;  // Oppdater til innstillingsmeny
     a08:	81 ec       	ldi	r24, 0xC1	; 193
     a0a:	91 e0       	ldi	r25, 0x01	; 1
     a0c:	90 93 bb 01 	sts	0x01BB, r25	; 0x8001bb <__data_end+0x1>
     a10:	80 93 ba 01 	sts	0x01BA, r24	; 0x8001ba <__data_end>
			break;
     a14:	08 95       	ret
			case 2:
			// Gå til scrollemeny
			currentMenuState = SCROLL_MENU;
     a16:	81 e0       	ldi	r24, 0x01	; 1
     a18:	80 93 bc 01 	sts	0x01BC, r24	; 0x8001bc <currentMenuState>
			current_menu = &scrollMenu;  // Oppdater til scrollemeny
     a1c:	8d ec       	ldi	r24, 0xCD	; 205
     a1e:	91 e0       	ldi	r25, 0x01	; 1
     a20:	90 93 bb 01 	sts	0x01BB, r25	; 0x8001bb <__data_end+0x1>
     a24:	80 93 ba 01 	sts	0x01BA, r24	; 0x8001ba <__data_end>
			break;
     a28:	08 95       	ret
			case 3:
			oled_write_line_to_SRAM(0, "Viser kredittar...");
     a2a:	6f e2       	ldi	r22, 0x2F	; 47
     a2c:	71 e0       	ldi	r23, 0x01	; 1
     a2e:	80 e0       	ldi	r24, 0x00	; 0
     a30:	0e 94 83 07 	call	0xf06	; 0xf06 <oled_write_line_to_SRAM>
			oled_write_screen_to_SRAM(solkors);  // Vis kredittar på skjermen
     a34:	80 ef       	ldi	r24, 0xF0	; 240
     a36:	90 e0       	ldi	r25, 0x00	; 0
     a38:	0e 94 1f 07 	call	0xe3e	; 0xe3e <oled_write_screen_to_SRAM>
			break;
     a3c:	08 95       	ret
			case 4:
			oled_write_line_to_SRAM(0, "Avsluttar...");
     a3e:	62 e4       	ldi	r22, 0x42	; 66
     a40:	71 e0       	ldi	r23, 0x01	; 1
     a42:	80 e0       	ldi	r24, 0x00	; 0
     a44:	0e 94 83 07 	call	0xf06	; 0xf06 <oled_write_line_to_SRAM>
			// Legg eventuelt til funksjonalitet for å avslutte
			break;
     a48:	08 95       	ret
			default:
			oled_write_line_to_SRAM(0, "Ugyldig valg");
     a4a:	6f e4       	ldi	r22, 0x4F	; 79
     a4c:	71 e0       	ldi	r23, 0x01	; 1
     a4e:	80 e0       	ldi	r24, 0x00	; 0
     a50:	0e 94 83 07 	call	0xf06	; 0xf06 <oled_write_line_to_SRAM>
			break;
     a54:	08 95       	ret
		}
		break;

		case SETTINGS_MENU:
		// Håndter valg i innstillingsmenyen
		switch (menu->current_position) {
     a56:	fb 01       	movw	r30, r22
     a58:	82 81       	ldd	r24, Z+2	; 0x02
     a5a:	81 30       	cpi	r24, 0x01	; 1
     a5c:	61 f0       	breq	.+24     	; 0xa76 <handleMenuSelection+0xb2>
     a5e:	28 f0       	brcs	.+10     	; 0xa6a <handleMenuSelection+0xa6>
     a60:	82 30       	cpi	r24, 0x02	; 2
     a62:	79 f0       	breq	.+30     	; 0xa82 <handleMenuSelection+0xbe>
     a64:	83 30       	cpi	r24, 0x03	; 3
     a66:	99 f0       	breq	.+38     	; 0xa8e <handleMenuSelection+0xca>
     a68:	1b c0       	rjmp	.+54     	; 0xaa0 <handleMenuSelection+0xdc>
			case 0:
			oled_write_line_to_SRAM(0, "Endrer lydinnstillingar...");
     a6a:	6c e5       	ldi	r22, 0x5C	; 92
     a6c:	71 e0       	ldi	r23, 0x01	; 1
     a6e:	80 e0       	ldi	r24, 0x00	; 0
     a70:	0e 94 83 07 	call	0xf06	; 0xf06 <oled_write_line_to_SRAM>
			break;
     a74:	08 95       	ret
			case 1:
			oled_write_line_to_SRAM(0, "Endrer lysstyrke...");
     a76:	67 e7       	ldi	r22, 0x77	; 119
     a78:	71 e0       	ldi	r23, 0x01	; 1
     a7a:	80 e0       	ldi	r24, 0x00	; 0
     a7c:	0e 94 83 07 	call	0xf06	; 0xf06 <oled_write_line_to_SRAM>
			break;
     a80:	08 95       	ret
			case 2:
			oled_write_line_to_SRAM(0, "Endrer kontrollar...");
     a82:	6b e8       	ldi	r22, 0x8B	; 139
     a84:	71 e0       	ldi	r23, 0x01	; 1
     a86:	80 e0       	ldi	r24, 0x00	; 0
     a88:	0e 94 83 07 	call	0xf06	; 0xf06 <oled_write_line_to_SRAM>
			break;
     a8c:	08 95       	ret
			case 3:
			// Gå tilbake til hovudmenyen
			currentMenuState = MAIN_MENU;
     a8e:	10 92 bc 01 	sts	0x01BC, r1	; 0x8001bc <currentMenuState>
			current_menu = &mainMenu;
     a92:	87 ec       	ldi	r24, 0xC7	; 199
     a94:	91 e0       	ldi	r25, 0x01	; 1
     a96:	90 93 bb 01 	sts	0x01BB, r25	; 0x8001bb <__data_end+0x1>
     a9a:	80 93 ba 01 	sts	0x01BA, r24	; 0x8001ba <__data_end>
			break;
     a9e:	08 95       	ret
			default:
			oled_write_line_to_SRAM(0, "Ugyldig valg");
     aa0:	6f e4       	ldi	r22, 0x4F	; 79
     aa2:	71 e0       	ldi	r23, 0x01	; 1
     aa4:	80 e0       	ldi	r24, 0x00	; 0
     aa6:	0e 94 83 07 	call	0xf06	; 0xf06 <oled_write_line_to_SRAM>
			break;
     aaa:	08 95       	ret
		}
		break;

		case SCROLL_MENU:
		// Håndter valg i scrollemenyen
		switch (menu->current_position) {
     aac:	fb 01       	movw	r30, r22
     aae:	82 81       	ldd	r24, Z+2	; 0x02
     ab0:	88 23       	and	r24, r24
     ab2:	19 f0       	breq	.+6      	; 0xaba <handleMenuSelection+0xf6>
     ab4:	81 30       	cpi	r24, 0x01	; 1
     ab6:	79 f0       	breq	.+30     	; 0xad6 <handleMenuSelection+0x112>
     ab8:	14 c0       	rjmp	.+40     	; 0xae2 <handleMenuSelection+0x11e>
			case 0:
			oled_write_line_to_SRAM(0, "Item 1 valgt");
     aba:	60 ea       	ldi	r22, 0xA0	; 160
     abc:	71 e0       	ldi	r23, 0x01	; 1
     abe:	80 e0       	ldi	r24, 0x00	; 0
     ac0:	0e 94 83 07 	call	0xf06	; 0xf06 <oled_write_line_to_SRAM>
			currentMenuState = MAIN_MENU;
     ac4:	10 92 bc 01 	sts	0x01BC, r1	; 0x8001bc <currentMenuState>
			current_menu = &mainMenu;
     ac8:	87 ec       	ldi	r24, 0xC7	; 199
     aca:	91 e0       	ldi	r25, 0x01	; 1
     acc:	90 93 bb 01 	sts	0x01BB, r25	; 0x8001bb <__data_end+0x1>
     ad0:	80 93 ba 01 	sts	0x01BA, r24	; 0x8001ba <__data_end>
			break;
     ad4:	08 95       	ret
			case 1:
			oled_write_line_to_SRAM(0, "Item 2 valgt");
     ad6:	6d ea       	ldi	r22, 0xAD	; 173
     ad8:	71 e0       	ldi	r23, 0x01	; 1
     ada:	80 e0       	ldi	r24, 0x00	; 0
     adc:	0e 94 83 07 	call	0xf06	; 0xf06 <oled_write_line_to_SRAM>
			break;
     ae0:	08 95       	ret
			default:
			oled_write_line_to_SRAM(0, "Ugyldig valg");
     ae2:	6f e4       	ldi	r22, 0x4F	; 79
     ae4:	71 e0       	ldi	r23, 0x01	; 1
     ae6:	80 e0       	ldi	r24, 0x00	; 0
     ae8:	0e 94 83 07 	call	0xf06	; 0xf06 <oled_write_line_to_SRAM>
     aec:	08 95       	ret

00000aee <MultiBoard_Init>:
 * Created: 14.09.2024 11:00:59
 *  Author: ravneb
 */ 
#include "MultiBoard.h"

void MultiBoard_Init(MultiBoard* board) {
     aee:	cf 93       	push	r28
     af0:	df 93       	push	r29
     af2:	ec 01       	movw	r28, r24
	// Set pinner for knapper som input
	clearBit(DDRB, LEFT_BUTTON_PIN);  // Set Left button pin as input
     af4:	bc 98       	cbi	0x17, 4	; 23
	clearBit(DDRB, RIGHT_BUTTON_PIN); // Set Right button pin as input
     af6:	bb 98       	cbi	0x17, 3	; 23
	clearBit(DDRB, JOY_BUTTON_PIN);   // Set Joystick button pin as input
     af8:	ba 98       	cbi	0x17, 2	; 23
	clearBit(DDRB, BUSY_PIN);         // Set BUSY pin as input
     afa:	b9 98       	cbi	0x17, 1	; 23
	
	// Aktiver pullup
	setBit(PORTB, JOY_BUTTON_PIN);
     afc:	c2 9a       	sbi	0x18, 2	; 24
	

	// Kalibrer joysticken (finn origo)
	Universal_write(ADC_START, 0x80); // For Chip Enable til ADC, (data her er irrelevant)
     afe:	60 e8       	ldi	r22, 0x80	; 128
     b00:	80 e0       	ldi	r24, 0x00	; 0
     b02:	94 e1       	ldi	r25, 0x14	; 20
     b04:	0e 94 08 0a 	call	0x1410	; 0x1410 <Universal_write>
	loopUntilBitIsClear(PINB, BUSY_PIN);    // Vent til BUSY gï¿½r lav
     b08:	b1 99       	sbic	0x16, 1	; 22
     b0a:	fe cf       	rjmp	.-4      	; 0xb08 <MultiBoard_Init+0x1a>
	board->JoyYOrigo = Universal_read(ADC_START); //CH0
     b0c:	80 e0       	ldi	r24, 0x00	; 0
     b0e:	94 e1       	ldi	r25, 0x14	; 20
     b10:	0e 94 18 0a 	call	0x1430	; 0x1430 <Universal_read>
     b14:	88 87       	std	Y+8, r24	; 0x08
	board->JoyXOrigo = Universal_read(ADC_START); //CH1
     b16:	80 e0       	ldi	r24, 0x00	; 0
     b18:	94 e1       	ldi	r25, 0x14	; 20
     b1a:	0e 94 18 0a 	call	0x1430	; 0x1430 <Universal_read>
     b1e:	8f 83       	std	Y+7, r24	; 0x07
	
	// Initialiser alle andre verdier
	board->LSpos = 0;
     b20:	1a 82       	std	Y+2, r1	; 0x02
	board->RSpos = 0;
     b22:	1b 82       	std	Y+3, r1	; 0x03
	board->LBtn = 0;
     b24:	1c 82       	std	Y+4, r1	; 0x04
	board->RBtn = 0;
     b26:	1d 82       	std	Y+5, r1	; 0x05
	board->JoyXpos = 0;
     b28:	19 82       	std	Y+1, r1	; 0x01
	board->JoyYpos = 0;
     b2a:	18 82       	st	Y, r1
	board->JoyXposCal = 0;
     b2c:	1a 86       	std	Y+10, r1	; 0x0a
     b2e:	19 86       	std	Y+9, r1	; 0x09
	board->JoyYposCal = 0;
     b30:	1c 86       	std	Y+12, r1	; 0x0c
     b32:	1b 86       	std	Y+11, r1	; 0x0b
	board->JoyAngle = 0;
     b34:	1e 86       	std	Y+14, r1	; 0x0e
     b36:	1d 86       	std	Y+13, r1	; 0x0d
	board->JoyBtn = 0;  // Endra fra en, vi bruker fortsatt 0 for av basert pÃ¥ logikk i MB_Update()
     b38:	1e 82       	std	Y+6, r1	; 0x06
}
     b3a:	df 91       	pop	r29
     b3c:	cf 91       	pop	r28
     b3e:	08 95       	ret

00000b40 <MultiBoard_UpdateJoystickAngle>:
	///IKKJE TESTA
	MultiBoard_UpdateJoystickAngle(board);
}

/// IKKJE TESTA 
void MultiBoard_UpdateJoystickAngle(MultiBoard* board) {
     b40:	fc 01       	movw	r30, r24
	int16_t x = board->JoyXposCal;
     b42:	61 85       	ldd	r22, Z+9	; 0x09
     b44:	72 85       	ldd	r23, Z+10	; 0x0a
	int16_t y = board->JoyYposCal;
     b46:	43 85       	ldd	r20, Z+11	; 0x0b
     b48:	54 85       	ldd	r21, Z+12	; 0x0c

	// Unngï¿½ divisjon med 0 (nï¿½r senterpunkt) + hysterese
	if (!(abs(x) > JOY_ANGLE_HYSTERESIS || abs(y) >  JOY_ANGLE_HYSTERESIS)) {
     b4a:	cb 01       	movw	r24, r22
     b4c:	05 96       	adiw	r24, 0x05	; 5
     b4e:	0b 97       	sbiw	r24, 0x0b	; 11
     b50:	38 f4       	brcc	.+14     	; 0xb60 <MultiBoard_UpdateJoystickAngle+0x20>
     b52:	ca 01       	movw	r24, r20
     b54:	05 96       	adiw	r24, 0x05	; 5
     b56:	0b 97       	sbiw	r24, 0x0b	; 11
     b58:	18 f4       	brcc	.+6      	; 0xb60 <MultiBoard_UpdateJoystickAngle+0x20>
		board->JoyAngle = 0;  // Midtpunkt, sett vinkelen til 0
     b5a:	16 86       	std	Z+14, r1	; 0x0e
     b5c:	15 86       	std	Z+13, r1	; 0x0d
     b5e:	08 95       	ret
		} else {
		// Bestem kvadrant basert pï¿½ verdiane til x og y
		switch ((x >= 0) << 1 | (y >= 0)) {
     b60:	87 2f       	mov	r24, r23
     b62:	80 95       	com	r24
     b64:	88 1f       	adc	r24, r24
     b66:	88 27       	eor	r24, r24
     b68:	88 1f       	adc	r24, r24
     b6a:	90 e0       	ldi	r25, 0x00	; 0
     b6c:	88 0f       	add	r24, r24
     b6e:	99 1f       	adc	r25, r25
     b70:	25 2f       	mov	r18, r21
     b72:	20 95       	com	r18
     b74:	22 1f       	adc	r18, r18
     b76:	22 27       	eor	r18, r18
     b78:	22 1f       	adc	r18, r18
     b7a:	82 2b       	or	r24, r18
     b7c:	81 30       	cpi	r24, 0x01	; 1
     b7e:	91 05       	cpc	r25, r1
     b80:	b9 f0       	breq	.+46     	; 0xbb0 <MultiBoard_UpdateJoystickAngle+0x70>
     b82:	1c f4       	brge	.+6      	; 0xb8a <MultiBoard_UpdateJoystickAngle+0x4a>
     b84:	89 2b       	or	r24, r25
     b86:	29 f1       	breq	.+74     	; 0xbd2 <MultiBoard_UpdateJoystickAngle+0x92>
     b88:	45 c0       	rjmp	.+138    	; 0xc14 <MultiBoard_UpdateJoystickAngle+0xd4>
     b8a:	82 30       	cpi	r24, 0x02	; 2
     b8c:	91 05       	cpc	r25, r1
     b8e:	99 f1       	breq	.+102    	; 0xbf6 <MultiBoard_UpdateJoystickAngle+0xb6>
     b90:	03 97       	sbiw	r24, 0x03	; 3
     b92:	09 f0       	breq	.+2      	; 0xb96 <MultiBoard_UpdateJoystickAngle+0x56>
     b94:	3f c0       	rjmp	.+126    	; 0xc14 <MultiBoard_UpdateJoystickAngle+0xd4>
			case 0b11:  // Fï¿½rste kvadrant (x >= 0, y >= 0)
			board->JoyAngle = (y * 90) / (x + y);
     b96:	2a e5       	ldi	r18, 0x5A	; 90
     b98:	24 9f       	mul	r18, r20
     b9a:	c0 01       	movw	r24, r0
     b9c:	25 9f       	mul	r18, r21
     b9e:	90 0d       	add	r25, r0
     ba0:	11 24       	eor	r1, r1
     ba2:	64 0f       	add	r22, r20
     ba4:	75 1f       	adc	r23, r21
     ba6:	0e 94 28 0a 	call	0x1450	; 0x1450 <__divmodhi4>
     baa:	76 87       	std	Z+14, r23	; 0x0e
     bac:	65 87       	std	Z+13, r22	; 0x0d
			break;
     bae:	08 95       	ret
			case 0b01:  // Andre kvadrant (x < 0, y >= 0)
			board->JoyAngle = 90 + ((-x * 90) / (-x + y));
     bb0:	26 ea       	ldi	r18, 0xA6	; 166
     bb2:	26 03       	mulsu	r18, r22
     bb4:	c0 01       	movw	r24, r0
     bb6:	27 9f       	mul	r18, r23
     bb8:	90 0d       	add	r25, r0
     bba:	11 24       	eor	r1, r1
     bbc:	9a 01       	movw	r18, r20
     bbe:	26 1b       	sub	r18, r22
     bc0:	37 0b       	sbc	r19, r23
     bc2:	b9 01       	movw	r22, r18
     bc4:	0e 94 28 0a 	call	0x1450	; 0x1450 <__divmodhi4>
     bc8:	66 5a       	subi	r22, 0xA6	; 166
     bca:	7f 4f       	sbci	r23, 0xFF	; 255
     bcc:	76 87       	std	Z+14, r23	; 0x0e
     bce:	65 87       	std	Z+13, r22	; 0x0d
			break;
     bd0:	08 95       	ret
			case 0b00:  // Tredje kvadrant (x < 0, y < 0)
			board->JoyAngle = 180 + ((-y * 90) / (-x - y));
     bd2:	26 ea       	ldi	r18, 0xA6	; 166
     bd4:	24 03       	mulsu	r18, r20
     bd6:	c0 01       	movw	r24, r0
     bd8:	25 9f       	mul	r18, r21
     bda:	90 0d       	add	r25, r0
     bdc:	11 24       	eor	r1, r1
     bde:	71 95       	neg	r23
     be0:	61 95       	neg	r22
     be2:	71 09       	sbc	r23, r1
     be4:	64 1b       	sub	r22, r20
     be6:	75 0b       	sbc	r23, r21
     be8:	0e 94 28 0a 	call	0x1450	; 0x1450 <__divmodhi4>
     bec:	6c 54       	subi	r22, 0x4C	; 76
     bee:	7f 4f       	sbci	r23, 0xFF	; 255
     bf0:	76 87       	std	Z+14, r23	; 0x0e
     bf2:	65 87       	std	Z+13, r22	; 0x0d
			break;
     bf4:	08 95       	ret
			case 0b10:  // Fjerde kvadrant (x >= 0, y < 0)
			board->JoyAngle = 270 + ((x * 90) / (x - y));
     bf6:	2a e5       	ldi	r18, 0x5A	; 90
     bf8:	26 9f       	mul	r18, r22
     bfa:	c0 01       	movw	r24, r0
     bfc:	27 9f       	mul	r18, r23
     bfe:	90 0d       	add	r25, r0
     c00:	11 24       	eor	r1, r1
     c02:	64 1b       	sub	r22, r20
     c04:	75 0b       	sbc	r23, r21
     c06:	0e 94 28 0a 	call	0x1450	; 0x1450 <__divmodhi4>
     c0a:	62 5f       	subi	r22, 0xF2	; 242
     c0c:	7e 4f       	sbci	r23, 0xFE	; 254
     c0e:	76 87       	std	Z+14, r23	; 0x0e
     c10:	65 87       	std	Z+13, r22	; 0x0d
			break;
     c12:	08 95       	ret
			default:
			board->JoyAngle = 0;  // Feiltilfelle, skal ikkje skje
     c14:	16 86       	std	Z+14, r1	; 0x0e
     c16:	15 86       	std	Z+13, r1	; 0x0d
     c18:	08 95       	ret

00000c1a <MultiBoard_Update>:
	board->JoyAngle = 0;
	board->JoyBtn = 0;  // Endra fra en, vi bruker fortsatt 0 for av basert pÃ¥ logikk i MB_Update()
}


void MultiBoard_Update(MultiBoard* board) {
     c1a:	cf 93       	push	r28
     c1c:	df 93       	push	r29
     c1e:	ec 01       	movw	r28, r24
	// Velg kanal for venstre skyvebryter (LSpos)
	Universal_write(ADC_START, 0x00);
     c20:	60 e0       	ldi	r22, 0x00	; 0
     c22:	80 e0       	ldi	r24, 0x00	; 0
     c24:	94 e1       	ldi	r25, 0x14	; 20
     c26:	0e 94 08 0a 	call	0x1410	; 0x1410 <Universal_write>
	loopUntilBitIsClear(PINB, BUSY_PIN);		// Vent til BUSY gï¿½r lav - klar for ï¿½ sende pï¿½ ny
     c2a:	b1 99       	sbic	0x16, 1	; 22
     c2c:	fe cf       	rjmp	.-4      	; 0xc2a <MultiBoard_Update+0x10>
	board->JoyYpos = Universal_read(ADC_START); //  - CH0 fï¿½rste RD low gir channel 0
     c2e:	80 e0       	ldi	r24, 0x00	; 0
     c30:	94 e1       	ldi	r25, 0x14	; 20
     c32:	0e 94 18 0a 	call	0x1430	; 0x1430 <Universal_read>
     c36:	88 83       	st	Y, r24
	board->JoyXpos = Universal_read(ADC_START); //	- CH1 andre RD low gir channel 1
     c38:	80 e0       	ldi	r24, 0x00	; 0
     c3a:	94 e1       	ldi	r25, 0x14	; 20
     c3c:	0e 94 18 0a 	call	0x1430	; 0x1430 <Universal_read>
     c40:	89 83       	std	Y+1, r24	; 0x01
	board->RSpos = Universal_read(ADC_START);	//	- CH2
     c42:	80 e0       	ldi	r24, 0x00	; 0
     c44:	94 e1       	ldi	r25, 0x14	; 20
     c46:	0e 94 18 0a 	call	0x1430	; 0x1430 <Universal_read>
     c4a:	8b 83       	std	Y+3, r24	; 0x03
	board->LSpos = Universal_read(ADC_START);	//	- CH3
     c4c:	80 e0       	ldi	r24, 0x00	; 0
     c4e:	94 e1       	ldi	r25, 0x14	; 20
     c50:	0e 94 18 0a 	call	0x1430	; 0x1430 <Universal_read>
     c54:	8a 83       	std	Y+2, r24	; 0x02
	// Les knappestatus
	board->LBtn = 0<testBit(PINB, LEFT_BUTTON_PIN);
     c56:	81 e0       	ldi	r24, 0x01	; 1
     c58:	b4 9b       	sbis	0x16, 4	; 22
     c5a:	80 e0       	ldi	r24, 0x00	; 0
     c5c:	8c 83       	std	Y+4, r24	; 0x04
	board->RBtn = 0<testBit(PINB, RIGHT_BUTTON_PIN);
     c5e:	81 e0       	ldi	r24, 0x01	; 1
     c60:	b3 9b       	sbis	0x16, 3	; 22
     c62:	80 e0       	ldi	r24, 0x00	; 0
     c64:	8d 83       	std	Y+5, r24	; 0x05
	board->JoyBtn = !(0<testBit(PINB, JOY_BUTTON_PIN));
     c66:	81 e0       	ldi	r24, 0x01	; 1
     c68:	b2 99       	sbic	0x16, 2	; 22
     c6a:	80 e0       	ldi	r24, 0x00	; 0
     c6c:	8e 83       	std	Y+6, r24	; 0x06
	// Opretter ein int med pluss og minus slik at vi kan finne riktig vinkel med _UpdateJoystickAngel
	board->JoyYposCal = (int16_t)(board->JoyYpos) - (int16_t)(board->JoyYOrigo);
     c6e:	88 81       	ld	r24, Y
     c70:	90 e0       	ldi	r25, 0x00	; 0
     c72:	28 85       	ldd	r18, Y+8	; 0x08
     c74:	82 1b       	sub	r24, r18
     c76:	91 09       	sbc	r25, r1
     c78:	9c 87       	std	Y+12, r25	; 0x0c
     c7a:	8b 87       	std	Y+11, r24	; 0x0b
	board->JoyXposCal = (int16_t)(board->JoyXpos) - (int16_t)(board->JoyXOrigo);
     c7c:	89 81       	ldd	r24, Y+1	; 0x01
     c7e:	90 e0       	ldi	r25, 0x00	; 0
     c80:	2f 81       	ldd	r18, Y+7	; 0x07
     c82:	82 1b       	sub	r24, r18
     c84:	91 09       	sbc	r25, r1
     c86:	9a 87       	std	Y+10, r25	; 0x0a
     c88:	89 87       	std	Y+9, r24	; 0x09
	///IKKJE TESTA
	MultiBoard_UpdateJoystickAngle(board);
     c8a:	ce 01       	movw	r24, r28
     c8c:	0e 94 a0 05 	call	0xb40	; 0xb40 <MultiBoard_UpdateJoystickAngle>
}
     c90:	df 91       	pop	r29
     c92:	cf 91       	pop	r28
     c94:	08 95       	ret

00000c96 <oled_write_command>:
	for (uint16_t i = 0; i < 1024; i++) {
		// Les byte direkte frå Flash og skriv til SRAM
		uint8_t byte_from_flash = pgm_read_byte(&screen_1024[i]);
		SRAM_write(i, byte_from_flash);
	}
}
     c96:	68 2f       	mov	r22, r24
     c98:	80 e0       	ldi	r24, 0x00	; 0
     c9a:	90 e0       	ldi	r25, 0x00	; 0
     c9c:	0e 94 08 0a 	call	0x1410	; 0x1410 <Universal_write>
     ca0:	08 95       	ret

00000ca2 <oled_write_data>:
     ca2:	ef 92       	push	r14
     ca4:	ff 92       	push	r15
     ca6:	0f 93       	push	r16
     ca8:	1f 93       	push	r17
     caa:	cf 93       	push	r28
     cac:	df 93       	push	r29
     cae:	61 15       	cp	r22, r1
     cb0:	71 05       	cpc	r23, r1
     cb2:	81 f0       	breq	.+32     	; 0xcd4 <oled_write_data+0x32>
     cb4:	7c 01       	movw	r14, r24
     cb6:	8c 01       	movw	r16, r24
     cb8:	e6 0e       	add	r14, r22
     cba:	f7 1e       	adc	r15, r23
     cbc:	c0 e0       	ldi	r28, 0x00	; 0
     cbe:	d2 e0       	ldi	r29, 0x02	; 2
     cc0:	f8 01       	movw	r30, r16
     cc2:	61 91       	ld	r22, Z+
     cc4:	8f 01       	movw	r16, r30
     cc6:	ce 01       	movw	r24, r28
     cc8:	0e 94 08 0a 	call	0x1410	; 0x1410 <Universal_write>
     ccc:	21 96       	adiw	r28, 0x01	; 1
     cce:	0e 15       	cp	r16, r14
     cd0:	1f 05       	cpc	r17, r15
     cd2:	b1 f7       	brne	.-20     	; 0xcc0 <oled_write_data+0x1e>
     cd4:	df 91       	pop	r29
     cd6:	cf 91       	pop	r28
     cd8:	1f 91       	pop	r17
     cda:	0f 91       	pop	r16
     cdc:	ff 90       	pop	r15
     cde:	ef 90       	pop	r14
     ce0:	08 95       	ret

00000ce2 <oled_set_page>:
     ce2:	87 70       	andi	r24, 0x07	; 7
     ce4:	80 6b       	ori	r24, 0xB0	; 176
     ce6:	0e 94 4b 06 	call	0xc96	; 0xc96 <oled_write_command>
     cea:	08 95       	ret

00000cec <oled_set_column>:
     cec:	cf 93       	push	r28
     cee:	c8 2f       	mov	r28, r24
     cf0:	82 95       	swap	r24
     cf2:	8f 70       	andi	r24, 0x0F	; 15
     cf4:	80 61       	ori	r24, 0x10	; 16
     cf6:	0e 94 4b 06 	call	0xc96	; 0xc96 <oled_write_command>
     cfa:	8c 2f       	mov	r24, r28
     cfc:	8f 70       	andi	r24, 0x0F	; 15
     cfe:	0e 94 4b 06 	call	0xc96	; 0xc96 <oled_write_command>
     d02:	cf 91       	pop	r28
     d04:	08 95       	ret

00000d06 <oled_home>:
     d06:	80 e0       	ldi	r24, 0x00	; 0
     d08:	0e 94 71 06 	call	0xce2	; 0xce2 <oled_set_page>
     d0c:	80 e0       	ldi	r24, 0x00	; 0
     d0e:	0e 94 76 06 	call	0xcec	; 0xcec <oled_set_column>
     d12:	08 95       	ret

00000d14 <oled_init>:
     d14:	8e ea       	ldi	r24, 0xAE	; 174
     d16:	0e 94 4b 06 	call	0xc96	; 0xc96 <oled_write_command>
     d1a:	81 ea       	ldi	r24, 0xA1	; 161
     d1c:	0e 94 4b 06 	call	0xc96	; 0xc96 <oled_write_command>
     d20:	8a ed       	ldi	r24, 0xDA	; 218
     d22:	0e 94 4b 06 	call	0xc96	; 0xc96 <oled_write_command>
     d26:	82 e1       	ldi	r24, 0x12	; 18
     d28:	0e 94 4b 06 	call	0xc96	; 0xc96 <oled_write_command>
     d2c:	88 ec       	ldi	r24, 0xC8	; 200
     d2e:	0e 94 4b 06 	call	0xc96	; 0xc96 <oled_write_command>
     d32:	88 ea       	ldi	r24, 0xA8	; 168
     d34:	0e 94 4b 06 	call	0xc96	; 0xc96 <oled_write_command>
     d38:	8f e3       	ldi	r24, 0x3F	; 63
     d3a:	0e 94 4b 06 	call	0xc96	; 0xc96 <oled_write_command>
     d3e:	85 ed       	ldi	r24, 0xD5	; 213
     d40:	0e 94 4b 06 	call	0xc96	; 0xc96 <oled_write_command>
     d44:	80 e8       	ldi	r24, 0x80	; 128
     d46:	0e 94 4b 06 	call	0xc96	; 0xc96 <oled_write_command>
     d4a:	81 e8       	ldi	r24, 0x81	; 129
     d4c:	0e 94 4b 06 	call	0xc96	; 0xc96 <oled_write_command>
     d50:	80 e5       	ldi	r24, 0x50	; 80
     d52:	0e 94 4b 06 	call	0xc96	; 0xc96 <oled_write_command>
     d56:	89 ed       	ldi	r24, 0xD9	; 217
     d58:	0e 94 4b 06 	call	0xc96	; 0xc96 <oled_write_command>
     d5c:	81 e2       	ldi	r24, 0x21	; 33
     d5e:	0e 94 4b 06 	call	0xc96	; 0xc96 <oled_write_command>
     d62:	80 e2       	ldi	r24, 0x20	; 32
     d64:	0e 94 4b 06 	call	0xc96	; 0xc96 <oled_write_command>
     d68:	82 e0       	ldi	r24, 0x02	; 2
     d6a:	0e 94 4b 06 	call	0xc96	; 0xc96 <oled_write_command>
     d6e:	8b ed       	ldi	r24, 0xDB	; 219
     d70:	0e 94 4b 06 	call	0xc96	; 0xc96 <oled_write_command>
     d74:	80 e3       	ldi	r24, 0x30	; 48
     d76:	0e 94 4b 06 	call	0xc96	; 0xc96 <oled_write_command>
     d7a:	8d ea       	ldi	r24, 0xAD	; 173
     d7c:	0e 94 4b 06 	call	0xc96	; 0xc96 <oled_write_command>
     d80:	80 e0       	ldi	r24, 0x00	; 0
     d82:	0e 94 4b 06 	call	0xc96	; 0xc96 <oled_write_command>
     d86:	84 ea       	ldi	r24, 0xA4	; 164
     d88:	0e 94 4b 06 	call	0xc96	; 0xc96 <oled_write_command>
     d8c:	86 ea       	ldi	r24, 0xA6	; 166
     d8e:	0e 94 4b 06 	call	0xc96	; 0xc96 <oled_write_command>
     d92:	8f ea       	ldi	r24, 0xAF	; 175
     d94:	0e 94 4b 06 	call	0xc96	; 0xc96 <oled_write_command>
     d98:	08 95       	ret

00000d9a <oled_data_from_SRAM>:
     d9a:	8f 92       	push	r8
     d9c:	9f 92       	push	r9
     d9e:	bf 92       	push	r11
     da0:	cf 92       	push	r12
     da2:	df 92       	push	r13
     da4:	ef 92       	push	r14
     da6:	ff 92       	push	r15
     da8:	0f 93       	push	r16
     daa:	1f 93       	push	r17
     dac:	cf 93       	push	r28
     dae:	df 93       	push	r29
     db0:	cd b7       	in	r28, 0x3d	; 61
     db2:	de b7       	in	r29, 0x3e	; 62
     db4:	c0 58       	subi	r28, 0x80	; 128
     db6:	d1 09       	sbc	r29, r1
     db8:	0f b6       	in	r0, 0x3f	; 63
     dba:	f8 94       	cli
     dbc:	de bf       	out	0x3e, r29	; 62
     dbe:	0f be       	out	0x3f, r0	; 63
     dc0:	cd bf       	out	0x3d, r28	; 61
     dc2:	ce 01       	movw	r24, r28
     dc4:	01 96       	adiw	r24, 0x01	; 1
     dc6:	4c 01       	movw	r8, r24
     dc8:	ee 24       	eor	r14, r14
     dca:	ff 24       	eor	r15, r15
     dcc:	e8 1a       	sub	r14, r24
     dce:	f9 0a       	sbc	r15, r25
     dd0:	b1 2c       	mov	r11, r1
     dd2:	6e 01       	movw	r12, r28
     dd4:	91 e8       	ldi	r25, 0x81	; 129
     dd6:	c9 0e       	add	r12, r25
     dd8:	d1 1c       	adc	r13, r1
     dda:	8b 2d       	mov	r24, r11
     ddc:	0e 94 71 06 	call	0xce2	; 0xce2 <oled_set_page>
     de0:	80 e0       	ldi	r24, 0x00	; 0
     de2:	0e 94 76 06 	call	0xcec	; 0xcec <oled_set_column>
     de6:	84 01       	movw	r16, r8
     de8:	c8 01       	movw	r24, r16
     dea:	8e 0d       	add	r24, r14
     dec:	9f 1d       	adc	r25, r15
     dee:	0e 94 f8 09 	call	0x13f0	; 0x13f0 <SRAM_read>
     df2:	f8 01       	movw	r30, r16
     df4:	81 93       	st	Z+, r24
     df6:	8f 01       	movw	r16, r30
     df8:	ec 15       	cp	r30, r12
     dfa:	fd 05       	cpc	r31, r13
     dfc:	a9 f7       	brne	.-22     	; 0xde8 <oled_data_from_SRAM+0x4e>
     dfe:	60 e8       	ldi	r22, 0x80	; 128
     e00:	70 e0       	ldi	r23, 0x00	; 0
     e02:	ce 01       	movw	r24, r28
     e04:	01 96       	adiw	r24, 0x01	; 1
     e06:	0e 94 51 06 	call	0xca2	; 0xca2 <oled_write_data>
     e0a:	b3 94       	inc	r11
     e0c:	f0 e8       	ldi	r31, 0x80	; 128
     e0e:	ef 0e       	add	r14, r31
     e10:	f1 1c       	adc	r15, r1
     e12:	88 e0       	ldi	r24, 0x08	; 8
     e14:	b8 12       	cpse	r11, r24
     e16:	e1 cf       	rjmp	.-62     	; 0xdda <oled_data_from_SRAM+0x40>
     e18:	c0 58       	subi	r28, 0x80	; 128
     e1a:	df 4f       	sbci	r29, 0xFF	; 255
     e1c:	0f b6       	in	r0, 0x3f	; 63
     e1e:	f8 94       	cli
     e20:	de bf       	out	0x3e, r29	; 62
     e22:	0f be       	out	0x3f, r0	; 63
     e24:	cd bf       	out	0x3d, r28	; 61
     e26:	df 91       	pop	r29
     e28:	cf 91       	pop	r28
     e2a:	1f 91       	pop	r17
     e2c:	0f 91       	pop	r16
     e2e:	ff 90       	pop	r15
     e30:	ef 90       	pop	r14
     e32:	df 90       	pop	r13
     e34:	cf 90       	pop	r12
     e36:	bf 90       	pop	r11
     e38:	9f 90       	pop	r9
     e3a:	8f 90       	pop	r8
     e3c:	08 95       	ret

00000e3e <oled_write_screen_to_SRAM>:
     e3e:	8f 92       	push	r8
     e40:	9f 92       	push	r9
     e42:	af 92       	push	r10
     e44:	bf 92       	push	r11
     e46:	cf 92       	push	r12
     e48:	df 92       	push	r13
     e4a:	ef 92       	push	r14
     e4c:	ff 92       	push	r15
     e4e:	0f 93       	push	r16
     e50:	1f 93       	push	r17
     e52:	cf 93       	push	r28
     e54:	df 93       	push	r29
     e56:	5c 01       	movw	r10, r24
     e58:	00 e0       	ldi	r16, 0x00	; 0
     e5a:	10 e0       	ldi	r17, 0x00	; 0
     e5c:	0f 2e       	mov	r0, r31
     e5e:	f0 e7       	ldi	r31, 0x70	; 112
     e60:	8f 2e       	mov	r8, r31
     e62:	f1 e0       	ldi	r31, 0x01	; 1
     e64:	9f 2e       	mov	r9, r31
     e66:	f0 2d       	mov	r31, r0
     e68:	0f 2e       	mov	r0, r31
     e6a:	f8 e7       	ldi	r31, 0x78	; 120
     e6c:	cf 2e       	mov	r12, r31
     e6e:	f1 e0       	ldi	r31, 0x01	; 1
     e70:	df 2e       	mov	r13, r31
     e72:	f0 2d       	mov	r31, r0
     e74:	d5 01       	movw	r26, r10
     e76:	8d 91       	ld	r24, X+
     e78:	5d 01       	movw	r10, r26
     e7a:	80 52       	subi	r24, 0x20	; 32
     e7c:	80 36       	cpi	r24, 0x60	; 96
     e7e:	f8 f4       	brcc	.+62     	; 0xebe <oled_write_screen_to_SRAM+0x80>
     e80:	c0 e0       	ldi	r28, 0x00	; 0
     e82:	d0 e0       	ldi	r29, 0x00	; 0
     e84:	7d 01       	movw	r14, r26
     e86:	b1 e0       	ldi	r27, 0x01	; 1
     e88:	eb 1a       	sub	r14, r27
     e8a:	f1 08       	sbc	r15, r1
     e8c:	d7 01       	movw	r26, r14
     e8e:	ec 91       	ld	r30, X
     e90:	f0 e0       	ldi	r31, 0x00	; 0
     e92:	b0 97       	sbiw	r30, 0x20	; 32
     e94:	ee 0f       	add	r30, r30
     e96:	ff 1f       	adc	r31, r31
     e98:	ee 0f       	add	r30, r30
     e9a:	ff 1f       	adc	r31, r31
     e9c:	ee 0f       	add	r30, r30
     e9e:	ff 1f       	adc	r31, r31
     ea0:	ec 0f       	add	r30, r28
     ea2:	fd 1f       	adc	r31, r29
     ea4:	e0 59       	subi	r30, 0x90	; 144
     ea6:	fe 4f       	sbci	r31, 0xFE	; 254
     ea8:	64 91       	lpm	r22, Z
     eaa:	ce 01       	movw	r24, r28
     eac:	80 0f       	add	r24, r16
     eae:	91 1f       	adc	r25, r17
     eb0:	0e 94 e8 09 	call	0x13d0	; 0x13d0 <SRAM_write>
     eb4:	21 96       	adiw	r28, 0x01	; 1
     eb6:	c8 30       	cpi	r28, 0x08	; 8
     eb8:	d1 05       	cpc	r29, r1
     eba:	41 f7       	brne	.-48     	; 0xe8c <oled_write_screen_to_SRAM+0x4e>
     ebc:	10 c0       	rjmp	.+32     	; 0xede <oled_write_screen_to_SRAM+0xa0>
     ebe:	c0 e7       	ldi	r28, 0x70	; 112
     ec0:	d1 e0       	ldi	r29, 0x01	; 1
     ec2:	78 01       	movw	r14, r16
     ec4:	e8 18       	sub	r14, r8
     ec6:	f9 08       	sbc	r15, r9
     ec8:	fe 01       	movw	r30, r28
     eca:	64 91       	lpm	r22, Z
     ecc:	c7 01       	movw	r24, r14
     ece:	8c 0f       	add	r24, r28
     ed0:	9d 1f       	adc	r25, r29
     ed2:	0e 94 e8 09 	call	0x13d0	; 0x13d0 <SRAM_write>
     ed6:	21 96       	adiw	r28, 0x01	; 1
     ed8:	cc 16       	cp	r12, r28
     eda:	dd 06       	cpc	r13, r29
     edc:	a9 f7       	brne	.-22     	; 0xec8 <oled_write_screen_to_SRAM+0x8a>
     ede:	08 5f       	subi	r16, 0xF8	; 248
     ee0:	1f 4f       	sbci	r17, 0xFF	; 255
     ee2:	01 15       	cp	r16, r1
     ee4:	f4 e0       	ldi	r31, 0x04	; 4
     ee6:	1f 07       	cpc	r17, r31
     ee8:	09 f0       	breq	.+2      	; 0xeec <oled_write_screen_to_SRAM+0xae>
     eea:	c4 cf       	rjmp	.-120    	; 0xe74 <oled_write_screen_to_SRAM+0x36>
     eec:	df 91       	pop	r29
     eee:	cf 91       	pop	r28
     ef0:	1f 91       	pop	r17
     ef2:	0f 91       	pop	r16
     ef4:	ff 90       	pop	r15
     ef6:	ef 90       	pop	r14
     ef8:	df 90       	pop	r13
     efa:	cf 90       	pop	r12
     efc:	bf 90       	pop	r11
     efe:	af 90       	pop	r10
     f00:	9f 90       	pop	r9
     f02:	8f 90       	pop	r8
     f04:	08 95       	ret

00000f06 <oled_write_line_to_SRAM>:


void oled_write_line_to_SRAM(uint8_t line, const char* data) {
     f06:	8f 92       	push	r8
     f08:	9f 92       	push	r9
     f0a:	bf 92       	push	r11
     f0c:	cf 92       	push	r12
     f0e:	df 92       	push	r13
     f10:	ef 92       	push	r14
     f12:	ff 92       	push	r15
     f14:	0f 93       	push	r16
     f16:	1f 93       	push	r17
     f18:	cf 93       	push	r28
     f1a:	df 93       	push	r29
	if (line >= 8) {
     f1c:	88 30       	cpi	r24, 0x08	; 8
     f1e:	08 f0       	brcs	.+2      	; 0xf22 <oled_write_line_to_SRAM+0x1c>
     f20:	5e c0       	rjmp	.+188    	; 0xfde <oled_write_line_to_SRAM+0xd8>
     f22:	fb 01       	movw	r30, r22
		return; 
	}
	uint8_t max_chars_per_line = 16;
	uint16_t sram_address = line * 128;  // Hver linje er 128 bytes, 16 karakterer à 8 pixels
     f24:	90 e8       	ldi	r25, 0x80	; 128
     f26:	89 9f       	mul	r24, r25
     f28:	60 01       	movw	r12, r0
     f2a:	11 24       	eor	r1, r1
	uint8_t i = 0; // så den ikkje døyr når vi går ut av forloopen (brukast igjen)
	// Skriv karakterene til SRAM, men ikke mer enn 16
	for (; i < max_chars_per_line; i++) {
		if (data[i] == '\0') {
     f2c:	80 81       	ld	r24, Z
     f2e:	88 23       	and	r24, r24
     f30:	09 f4       	brne	.+2      	; 0xf34 <oled_write_line_to_SRAM+0x2e>
     f32:	47 c0       	rjmp	.+142    	; 0xfc2 <oled_write_line_to_SRAM+0xbc>
     f34:	76 01       	movw	r14, r12
     f36:	8b 01       	movw	r16, r22
     f38:	b1 2c       	mov	r11, r1
     f3a:	0a c0       	rjmp	.+20     	; 0xf50 <oled_write_line_to_SRAM+0x4a>
     f3c:	0f 5f       	subi	r16, 0xFF	; 255
     f3e:	1f 4f       	sbci	r17, 0xFF	; 255
     f40:	a8 e0       	ldi	r26, 0x08	; 8
     f42:	ea 0e       	add	r14, r26
     f44:	f1 1c       	adc	r15, r1
     f46:	f8 01       	movw	r30, r16
     f48:	80 81       	ld	r24, Z
     f4a:	88 23       	and	r24, r24
     f4c:	09 f4       	brne	.+2      	; 0xf50 <oled_write_line_to_SRAM+0x4a>
     f4e:	3a c0       	rjmp	.+116    	; 0xfc4 <oled_write_line_to_SRAM+0xbe>
     f50:	c0 e0       	ldi	r28, 0x00	; 0
     f52:	d0 e0       	ldi	r29, 0x00	; 0
			break;  // Avslutt hvis vi når slutten av data
		}
		for (uint8_t j = 0; j < 8; j++) {
			SRAM_write(sram_address + (i * 8) + j, pgm_read_byte(&font8x8_basic[(data[i] - 32) * 8 + j]));
     f54:	d8 01       	movw	r26, r16
     f56:	ec 91       	ld	r30, X
     f58:	f0 e0       	ldi	r31, 0x00	; 0
     f5a:	b0 97       	sbiw	r30, 0x20	; 32
     f5c:	ee 0f       	add	r30, r30
     f5e:	ff 1f       	adc	r31, r31
     f60:	ee 0f       	add	r30, r30
     f62:	ff 1f       	adc	r31, r31
     f64:	ee 0f       	add	r30, r30
     f66:	ff 1f       	adc	r31, r31
     f68:	ec 0f       	add	r30, r28
     f6a:	fd 1f       	adc	r31, r29
     f6c:	e0 59       	subi	r30, 0x90	; 144
     f6e:	fe 4f       	sbci	r31, 0xFE	; 254
     f70:	64 91       	lpm	r22, Z
     f72:	c7 01       	movw	r24, r14
     f74:	8c 0f       	add	r24, r28
     f76:	9d 1f       	adc	r25, r29
     f78:	0e 94 e8 09 	call	0x13d0	; 0x13d0 <SRAM_write>
     f7c:	21 96       	adiw	r28, 0x01	; 1
	// Skriv karakterene til SRAM, men ikke mer enn 16
	for (; i < max_chars_per_line; i++) {
		if (data[i] == '\0') {
			break;  // Avslutt hvis vi når slutten av data
		}
		for (uint8_t j = 0; j < 8; j++) {
     f7e:	c8 30       	cpi	r28, 0x08	; 8
     f80:	d1 05       	cpc	r29, r1
     f82:	41 f7       	brne	.-48     	; 0xf54 <oled_write_line_to_SRAM+0x4e>
	}
	uint8_t max_chars_per_line = 16;
	uint16_t sram_address = line * 128;  // Hver linje er 128 bytes, 16 karakterer à 8 pixels
	uint8_t i = 0; // så den ikkje døyr når vi går ut av forloopen (brukast igjen)
	// Skriv karakterene til SRAM, men ikke mer enn 16
	for (; i < max_chars_per_line; i++) {
     f84:	b3 94       	inc	r11
     f86:	b0 e1       	ldi	r27, 0x10	; 16
     f88:	bb 12       	cpse	r11, r27
     f8a:	d8 cf       	rjmp	.-80     	; 0xf3c <oled_write_line_to_SRAM+0x36>
     f8c:	28 c0       	rjmp	.+80     	; 0xfde <oled_write_line_to_SRAM+0xd8>
		}
	}
	// Fyll resten av linjen med tomrom (mellomrom) etter slutten av data
	for (; i < max_chars_per_line; i++) {
		for (uint8_t j = 0; j < 8; j++) {
			SRAM_write(sram_address + (i * 8) + j, pgm_read_byte(&font8x8_basic[(' ' - 32) * 8 + j]));
     f8e:	fe 01       	movw	r30, r28
     f90:	64 91       	lpm	r22, Z
     f92:	c8 01       	movw	r24, r16
     f94:	8c 0f       	add	r24, r28
     f96:	9d 1f       	adc	r25, r29
     f98:	0e 94 e8 09 	call	0x13d0	; 0x13d0 <SRAM_write>
     f9c:	21 96       	adiw	r28, 0x01	; 1
			SRAM_write(sram_address + (i * 8) + j, pgm_read_byte(&font8x8_basic[(data[i] - 32) * 8 + j]));
		}
	}
	// Fyll resten av linjen med tomrom (mellomrom) etter slutten av data
	for (; i < max_chars_per_line; i++) {
		for (uint8_t j = 0; j < 8; j++) {
     f9e:	ce 15       	cp	r28, r14
     fa0:	df 05       	cpc	r29, r15
     fa2:	a9 f7       	brne	.-22     	; 0xf8e <oled_write_line_to_SRAM+0x88>
		for (uint8_t j = 0; j < 8; j++) {
			SRAM_write(sram_address + (i * 8) + j, pgm_read_byte(&font8x8_basic[(data[i] - 32) * 8 + j]));
		}
	}
	// Fyll resten av linjen med tomrom (mellomrom) etter slutten av data
	for (; i < max_chars_per_line; i++) {
     fa4:	b3 94       	inc	r11
     fa6:	ff e0       	ldi	r31, 0x0F	; 15
     fa8:	fb 15       	cp	r31, r11
     faa:	c8 f0       	brcs	.+50     	; 0xfde <oled_write_line_to_SRAM+0xd8>
		for (uint8_t j = 0; j < 8; j++) {
			SRAM_write(sram_address + (i * 8) + j, pgm_read_byte(&font8x8_basic[(' ' - 32) * 8 + j]));
     fac:	c0 e7       	ldi	r28, 0x70	; 112
     fae:	d1 e0       	ldi	r29, 0x01	; 1
     fb0:	86 01       	movw	r16, r12
     fb2:	88 e0       	ldi	r24, 0x08	; 8
     fb4:	b8 9e       	mul	r11, r24
     fb6:	00 0d       	add	r16, r0
     fb8:	11 1d       	adc	r17, r1
     fba:	11 24       	eor	r1, r1
     fbc:	08 19       	sub	r16, r8
     fbe:	19 09       	sbc	r17, r9
     fc0:	e6 cf       	rjmp	.-52     	; 0xf8e <oled_write_line_to_SRAM+0x88>
	if (line >= 8) {
		return; 
	}
	uint8_t max_chars_per_line = 16;
	uint16_t sram_address = line * 128;  // Hver linje er 128 bytes, 16 karakterer à 8 pixels
	uint8_t i = 0; // så den ikkje døyr når vi går ut av forloopen (brukast igjen)
     fc2:	b1 2c       	mov	r11, r1
     fc4:	0f 2e       	mov	r0, r31
     fc6:	f0 e7       	ldi	r31, 0x70	; 112
     fc8:	8f 2e       	mov	r8, r31
     fca:	f1 e0       	ldi	r31, 0x01	; 1
     fcc:	9f 2e       	mov	r9, r31
     fce:	f0 2d       	mov	r31, r0
     fd0:	0f 2e       	mov	r0, r31
     fd2:	f8 e7       	ldi	r31, 0x78	; 120
     fd4:	ef 2e       	mov	r14, r31
     fd6:	f1 e0       	ldi	r31, 0x01	; 1
     fd8:	ff 2e       	mov	r15, r31
     fda:	f0 2d       	mov	r31, r0
     fdc:	e7 cf       	rjmp	.-50     	; 0xfac <oled_write_line_to_SRAM+0xa6>
	for (; i < max_chars_per_line; i++) {
		for (uint8_t j = 0; j < 8; j++) {
			SRAM_write(sram_address + (i * 8) + j, pgm_read_byte(&font8x8_basic[(' ' - 32) * 8 + j]));
		}
	}
}
     fde:	df 91       	pop	r29
     fe0:	cf 91       	pop	r28
     fe2:	1f 91       	pop	r17
     fe4:	0f 91       	pop	r16
     fe6:	ff 90       	pop	r15
     fe8:	ef 90       	pop	r14
     fea:	df 90       	pop	r13
     fec:	cf 90       	pop	r12
     fee:	bf 90       	pop	r11
     ff0:	9f 90       	pop	r9
     ff2:	8f 90       	pop	r8
     ff4:	08 95       	ret

00000ff6 <oled_write_char_to_SRAM>:
//Nyttig for menyen trur eg, lar deg spesifisere nøyaktig kor på skjermen du vil overskrive
void oled_write_char_to_SRAM(uint8_t row, uint8_t col, char c) {
     ff6:	ef 92       	push	r14
     ff8:	ff 92       	push	r15
     ffa:	0f 93       	push	r16
     ffc:	1f 93       	push	r17
     ffe:	cf 93       	push	r28
    1000:	df 93       	push	r29
	if (row >= 8 || col >= 16) {
    1002:	88 30       	cpi	r24, 0x08	; 8
    1004:	70 f5       	brcc	.+92     	; 0x1062 <oled_write_char_to_SRAM+0x6c>
    1006:	60 31       	cpi	r22, 0x10	; 16
    1008:	60 f5       	brcc	.+88     	; 0x1062 <oled_write_char_to_SRAM+0x6c>
    100a:	28 2f       	mov	r18, r24
		return; 
	}
	uint16_t sram_address = row * 128 + (col * 8); 
    100c:	86 2f       	mov	r24, r22
    100e:	90 e0       	ldi	r25, 0x00	; 0
    1010:	30 e1       	ldi	r19, 0x10	; 16
    1012:	23 9f       	mul	r18, r19
    1014:	80 0d       	add	r24, r0
    1016:	91 1d       	adc	r25, r1
    1018:	11 24       	eor	r1, r1
    101a:	88 0f       	add	r24, r24
    101c:	99 1f       	adc	r25, r25
    101e:	88 0f       	add	r24, r24
    1020:	99 1f       	adc	r25, r25
    1022:	88 0f       	add	r24, r24
    1024:	99 1f       	adc	r25, r25
	for (uint8_t i = 0; i < 8; i++) {
		SRAM_write(sram_address + i, pgm_read_byte(&font8x8_basic[(c - 32) * 8 + i]));
    1026:	04 2f       	mov	r16, r20
    1028:	10 e0       	ldi	r17, 0x00	; 0
    102a:	00 52       	subi	r16, 0x20	; 32
    102c:	11 09       	sbc	r17, r1
    102e:	00 0f       	add	r16, r16
    1030:	11 1f       	adc	r17, r17
    1032:	00 0f       	add	r16, r16
    1034:	11 1f       	adc	r17, r17
    1036:	00 0f       	add	r16, r16
    1038:	11 1f       	adc	r17, r17
    103a:	7c 01       	movw	r14, r24
    103c:	28 e0       	ldi	r18, 0x08	; 8
    103e:	e2 0e       	add	r14, r18
    1040:	f1 1c       	adc	r15, r1
    1042:	ec 01       	movw	r28, r24
    1044:	08 1b       	sub	r16, r24
    1046:	19 0b       	sbc	r17, r25
    1048:	f8 01       	movw	r30, r16
    104a:	ec 0f       	add	r30, r28
    104c:	fd 1f       	adc	r31, r29
    104e:	e0 59       	subi	r30, 0x90	; 144
    1050:	fe 4f       	sbci	r31, 0xFE	; 254
    1052:	64 91       	lpm	r22, Z
    1054:	ce 01       	movw	r24, r28
    1056:	0e 94 e8 09 	call	0x13d0	; 0x13d0 <SRAM_write>
    105a:	21 96       	adiw	r28, 0x01	; 1
void oled_write_char_to_SRAM(uint8_t row, uint8_t col, char c) {
	if (row >= 8 || col >= 16) {
		return; 
	}
	uint16_t sram_address = row * 128 + (col * 8); 
	for (uint8_t i = 0; i < 8; i++) {
    105c:	ce 15       	cp	r28, r14
    105e:	df 05       	cpc	r29, r15
    1060:	99 f7       	brne	.-26     	; 0x1048 <oled_write_char_to_SRAM+0x52>
		SRAM_write(sram_address + i, pgm_read_byte(&font8x8_basic[(c - 32) * 8 + i]));
	}
}
    1062:	df 91       	pop	r29
    1064:	cf 91       	pop	r28
    1066:	1f 91       	pop	r17
    1068:	0f 91       	pop	r16
    106a:	ff 90       	pop	r15
    106c:	ef 90       	pop	r14
    106e:	08 95       	ret

00001070 <oled_write_pixel_to_SRAM>:

void oled_write_pixel_to_SRAM(uint8_t row, uint8_t col, uint8_t value) {
    1070:	0f 93       	push	r16
    1072:	1f 93       	push	r17
    1074:	cf 93       	push	r28
    1076:	df 93       	push	r29
	if (row >= 64 || col >= 128) {
    1078:	80 34       	cpi	r24, 0x40	; 64
    107a:	48 f5       	brcc	.+82     	; 0x10ce <oled_write_pixel_to_SRAM+0x5e>
    107c:	66 23       	and	r22, r22
    107e:	3c f1       	brlt	.+78     	; 0x10ce <oled_write_pixel_to_SRAM+0x5e>
    1080:	04 2f       	mov	r16, r20
    1082:	18 2f       	mov	r17, r24
		return;
	}
	
	// Finn korrekt byte i SRAM for å justere pikslen
	uint16_t sram_address = (row / 8) * 128 + col;
    1084:	86 95       	lsr	r24
    1086:	86 95       	lsr	r24
    1088:	86 95       	lsr	r24
    108a:	c6 2f       	mov	r28, r22
    108c:	d0 e0       	ldi	r29, 0x00	; 0
    108e:	90 e8       	ldi	r25, 0x80	; 128
    1090:	89 9f       	mul	r24, r25
    1092:	c0 0d       	add	r28, r0
    1094:	d1 1d       	adc	r29, r1
    1096:	11 24       	eor	r1, r1
	uint8_t current_byte = SRAM_read(sram_address);
    1098:	ce 01       	movw	r24, r28
    109a:	0e 94 f8 09 	call	0x13f0	; 0x13f0 <SRAM_read>
	uint8_t bit_position = row % 8;
    109e:	17 70       	andi	r17, 0x07	; 7

	// Sett eller nullstill den ønskede biten
	if (value) {
    10a0:	00 23       	and	r16, r16
    10a2:	49 f0       	breq	.+18     	; 0x10b6 <oled_write_pixel_to_SRAM+0x46>
		current_byte |= (1 << bit_position);  // Sett bit til 1
    10a4:	61 e0       	ldi	r22, 0x01	; 1
    10a6:	70 e0       	ldi	r23, 0x00	; 0
    10a8:	02 c0       	rjmp	.+4      	; 0x10ae <oled_write_pixel_to_SRAM+0x3e>
    10aa:	66 0f       	add	r22, r22
    10ac:	77 1f       	adc	r23, r23
    10ae:	1a 95       	dec	r17
    10b0:	e2 f7       	brpl	.-8      	; 0x10aa <oled_write_pixel_to_SRAM+0x3a>
    10b2:	68 2b       	or	r22, r24
    10b4:	09 c0       	rjmp	.+18     	; 0x10c8 <oled_write_pixel_to_SRAM+0x58>
		} else {
		current_byte &= ~(1 << bit_position);  // Nullstill bit til 0
    10b6:	61 e0       	ldi	r22, 0x01	; 1
    10b8:	70 e0       	ldi	r23, 0x00	; 0
    10ba:	02 c0       	rjmp	.+4      	; 0x10c0 <oled_write_pixel_to_SRAM+0x50>
    10bc:	66 0f       	add	r22, r22
    10be:	77 1f       	adc	r23, r23
    10c0:	1a 95       	dec	r17
    10c2:	e2 f7       	brpl	.-8      	; 0x10bc <oled_write_pixel_to_SRAM+0x4c>
    10c4:	60 95       	com	r22
    10c6:	68 23       	and	r22, r24
	}
	
	SRAM_write(sram_address, current_byte);
    10c8:	ce 01       	movw	r24, r28
    10ca:	0e 94 e8 09 	call	0x13d0	; 0x13d0 <SRAM_write>
}
    10ce:	df 91       	pop	r29
    10d0:	cf 91       	pop	r28
    10d2:	1f 91       	pop	r17
    10d4:	0f 91       	pop	r16
    10d6:	08 95       	ret

000010d8 <oled_clear_screen>:

void oled_clear_screen(void) {
    10d8:	cf 93       	push	r28
    10da:	df 93       	push	r29
    10dc:	cd b7       	in	r28, 0x3d	; 61
    10de:	de b7       	in	r29, 0x3e	; 62
    10e0:	c0 58       	subi	r28, 0x80	; 128
    10e2:	d1 09       	sbc	r29, r1
    10e4:	0f b6       	in	r0, 0x3f	; 63
    10e6:	f8 94       	cli
    10e8:	de bf       	out	0x3e, r29	; 62
    10ea:	0f be       	out	0x3f, r0	; 63
    10ec:	cd bf       	out	0x3d, r28	; 61
	// Lag en tom buffer fylt med nuller eller mellomrom (0 er nok, fordi funksjonen oversetter til ' ')
	char empty_buffer[128] = {0};  // Heile skjermen, 128 tegn
    10ee:	ce 01       	movw	r24, r28
    10f0:	01 96       	adiw	r24, 0x01	; 1
    10f2:	20 e8       	ldi	r18, 0x80	; 128
    10f4:	fc 01       	movw	r30, r24
    10f6:	11 92       	st	Z+, r1
    10f8:	2a 95       	dec	r18
    10fa:	e9 f7       	brne	.-6      	; 0x10f6 <oled_clear_screen+0x1e>

	// Skriv den tomme bufferen til SRAM, som vil tømme skjermen
	oled_write_screen_to_SRAM(empty_buffer);
    10fc:	0e 94 1f 07 	call	0xe3e	; 0xe3e <oled_write_screen_to_SRAM>
}
    1100:	c0 58       	subi	r28, 0x80	; 128
    1102:	df 4f       	sbci	r29, 0xFF	; 255
    1104:	0f b6       	in	r0, 0x3f	; 63
    1106:	f8 94       	cli
    1108:	de bf       	out	0x3e, r29	; 62
    110a:	0f be       	out	0x3f, r0	; 63
    110c:	cd bf       	out	0x3d, r28	; 61
    110e:	df 91       	pop	r29
    1110:	cf 91       	pop	r28
    1112:	08 95       	ret

00001114 <oled_draw_line>:

void oled_draw_line(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1) {
    1114:	6f 92       	push	r6
    1116:	7f 92       	push	r7
    1118:	8f 92       	push	r8
    111a:	9f 92       	push	r9
    111c:	af 92       	push	r10
    111e:	bf 92       	push	r11
    1120:	cf 92       	push	r12
    1122:	df 92       	push	r13
    1124:	ef 92       	push	r14
    1126:	ff 92       	push	r15
    1128:	0f 93       	push	r16
    112a:	1f 93       	push	r17
    112c:	cf 93       	push	r28
    112e:	df 93       	push	r29
    1130:	c8 2f       	mov	r28, r24
    1132:	d6 2f       	mov	r29, r22
    1134:	94 2e       	mov	r9, r20
    1136:	62 2e       	mov	r6, r18
	int dx = abs(x1 - x0);
    1138:	84 2f       	mov	r24, r20
    113a:	90 e0       	ldi	r25, 0x00	; 0
    113c:	8c 1b       	sub	r24, r28
    113e:	91 09       	sbc	r25, r1
    1140:	7c 01       	movw	r14, r24
    1142:	22 f4       	brpl	.+8      	; 0x114c <oled_draw_line+0x38>
    1144:	ee 24       	eor	r14, r14
    1146:	ff 24       	eor	r15, r15
    1148:	e8 1a       	sub	r14, r24
    114a:	f9 0a       	sbc	r15, r25
	int dy = abs(y1 - y0);
    114c:	86 2d       	mov	r24, r6
    114e:	90 e0       	ldi	r25, 0x00	; 0
    1150:	8d 1b       	sub	r24, r29
    1152:	91 09       	sbc	r25, r1
    1154:	5c 01       	movw	r10, r24
    1156:	22 f4       	brpl	.+8      	; 0x1160 <oled_draw_line+0x4c>
    1158:	aa 24       	eor	r10, r10
    115a:	bb 24       	eor	r11, r11
    115c:	a8 1a       	sub	r10, r24
    115e:	b9 0a       	sbc	r11, r25
	int sx = (x0 < x1) ? 1 : -1;
    1160:	c9 15       	cp	r28, r9
    1162:	18 f0       	brcs	.+6      	; 0x116a <oled_draw_line+0x56>
    1164:	88 24       	eor	r8, r8
    1166:	8a 94       	dec	r8
    1168:	02 c0       	rjmp	.+4      	; 0x116e <oled_draw_line+0x5a>
    116a:	88 24       	eor	r8, r8
    116c:	83 94       	inc	r8
	int sy = (y0 < y1) ? 1 : -1;
    116e:	d6 15       	cp	r29, r6
    1170:	18 f0       	brcs	.+6      	; 0x1178 <oled_draw_line+0x64>
    1172:	77 24       	eor	r7, r7
    1174:	7a 94       	dec	r7
    1176:	02 c0       	rjmp	.+4      	; 0x117c <oled_draw_line+0x68>
    1178:	77 24       	eor	r7, r7
    117a:	73 94       	inc	r7
	int err = dx - dy;
    117c:	87 01       	movw	r16, r14
    117e:	0a 19       	sub	r16, r10
    1180:	1b 09       	sbc	r17, r11
	while (1) {
		oled_write_pixel_to_SRAM(y0, x0, 1);  // Tegn piksel

		if (x0 == x1 && y0 == y1) break;
		int e2 = 2 * err;
		if (e2 > -dy) {
    1182:	cc 24       	eor	r12, r12
    1184:	dd 24       	eor	r13, r13
    1186:	ca 18       	sub	r12, r10
    1188:	db 08       	sbc	r13, r11
	int sx = (x0 < x1) ? 1 : -1;
	int sy = (y0 < y1) ? 1 : -1;
	int err = dx - dy;

	while (1) {
		oled_write_pixel_to_SRAM(y0, x0, 1);  // Tegn piksel
    118a:	41 e0       	ldi	r20, 0x01	; 1
    118c:	6c 2f       	mov	r22, r28
    118e:	8d 2f       	mov	r24, r29
    1190:	0e 94 38 08 	call	0x1070	; 0x1070 <oled_write_pixel_to_SRAM>

		if (x0 == x1 && y0 == y1) break;
    1194:	c9 11       	cpse	r28, r9
    1196:	02 c0       	rjmp	.+4      	; 0x119c <oled_draw_line+0x88>
    1198:	d6 15       	cp	r29, r6
    119a:	81 f0       	breq	.+32     	; 0x11bc <oled_draw_line+0xa8>
		int e2 = 2 * err;
    119c:	c8 01       	movw	r24, r16
    119e:	88 0f       	add	r24, r24
    11a0:	99 1f       	adc	r25, r25
		if (e2 > -dy) {
    11a2:	c8 16       	cp	r12, r24
    11a4:	d9 06       	cpc	r13, r25
    11a6:	1c f4       	brge	.+6      	; 0x11ae <oled_draw_line+0x9a>
			err -= dy;
    11a8:	0a 19       	sub	r16, r10
    11aa:	1b 09       	sbc	r17, r11
			x0 += sx;
    11ac:	c8 0d       	add	r28, r8
		}
		if (e2 < dx) {
    11ae:	8e 15       	cp	r24, r14
    11b0:	9f 05       	cpc	r25, r15
    11b2:	5c f7       	brge	.-42     	; 0x118a <oled_draw_line+0x76>
			err += dx;
    11b4:	0e 0d       	add	r16, r14
    11b6:	1f 1d       	adc	r17, r15
			y0 += sy;
    11b8:	d7 0d       	add	r29, r7
    11ba:	e7 cf       	rjmp	.-50     	; 0x118a <oled_draw_line+0x76>
		}
	}
}
    11bc:	df 91       	pop	r29
    11be:	cf 91       	pop	r28
    11c0:	1f 91       	pop	r17
    11c2:	0f 91       	pop	r16
    11c4:	ff 90       	pop	r15
    11c6:	ef 90       	pop	r14
    11c8:	df 90       	pop	r13
    11ca:	cf 90       	pop	r12
    11cc:	bf 90       	pop	r11
    11ce:	af 90       	pop	r10
    11d0:	9f 90       	pop	r9
    11d2:	8f 90       	pop	r8
    11d4:	7f 90       	pop	r7
    11d6:	6f 90       	pop	r6
    11d8:	08 95       	ret

000011da <oled_draw_circle>:

void oled_draw_circle(uint8_t x0, uint8_t y0, uint8_t radius) {
    11da:	9f 92       	push	r9
    11dc:	af 92       	push	r10
    11de:	bf 92       	push	r11
    11e0:	cf 92       	push	r12
    11e2:	df 92       	push	r13
    11e4:	ef 92       	push	r14
    11e6:	ff 92       	push	r15
    11e8:	0f 93       	push	r16
    11ea:	1f 93       	push	r17
    11ec:	cf 93       	push	r28
    11ee:	df 93       	push	r29
    11f0:	98 2e       	mov	r9, r24
    11f2:	c6 2e       	mov	r12, r22
	int x = radius;
    11f4:	c4 2f       	mov	r28, r20
    11f6:	d0 e0       	ldi	r29, 0x00	; 0
    11f8:	a1 2c       	mov	r10, r1
    11fa:	b1 2c       	mov	r11, r1
    11fc:	00 e0       	ldi	r16, 0x00	; 0
    11fe:	10 e0       	ldi	r17, 0x00	; 0
	int y = 0;
	int err = 0;

	while (x >= y) {
		oled_write_pixel_to_SRAM(y0 + y, x0 + x, 1);
    1200:	41 e0       	ldi	r20, 0x01	; 1
    1202:	fc 2e       	mov	r15, r28
    1204:	f9 0c       	add	r15, r9
    1206:	6f 2d       	mov	r22, r15
    1208:	dc 2c       	mov	r13, r12
    120a:	d0 0e       	add	r13, r16
    120c:	8d 2d       	mov	r24, r13
    120e:	0e 94 38 08 	call	0x1070	; 0x1070 <oled_write_pixel_to_SRAM>
		oled_write_pixel_to_SRAM(y0 + y, x0 - x, 1);
    1212:	41 e0       	ldi	r20, 0x01	; 1
    1214:	e9 2c       	mov	r14, r9
    1216:	ec 1a       	sub	r14, r28
    1218:	6e 2d       	mov	r22, r14
    121a:	8d 2d       	mov	r24, r13
    121c:	0e 94 38 08 	call	0x1070	; 0x1070 <oled_write_pixel_to_SRAM>
		oled_write_pixel_to_SRAM(y0 - y, x0 + x, 1);
    1220:	41 e0       	ldi	r20, 0x01	; 1
    1222:	6f 2d       	mov	r22, r15
    1224:	fc 2c       	mov	r15, r12
    1226:	f0 1a       	sub	r15, r16
    1228:	8f 2d       	mov	r24, r15
    122a:	0e 94 38 08 	call	0x1070	; 0x1070 <oled_write_pixel_to_SRAM>
		oled_write_pixel_to_SRAM(y0 - y, x0 - x, 1);
    122e:	41 e0       	ldi	r20, 0x01	; 1
    1230:	6e 2d       	mov	r22, r14
    1232:	8f 2d       	mov	r24, r15
    1234:	0e 94 38 08 	call	0x1070	; 0x1070 <oled_write_pixel_to_SRAM>
		oled_write_pixel_to_SRAM(y0 + x, x0 + y, 1);
    1238:	41 e0       	ldi	r20, 0x01	; 1
    123a:	f9 2c       	mov	r15, r9
    123c:	f0 0e       	add	r15, r16
    123e:	6f 2d       	mov	r22, r15
    1240:	dc 2e       	mov	r13, r28
    1242:	dc 0c       	add	r13, r12
    1244:	8d 2d       	mov	r24, r13
    1246:	0e 94 38 08 	call	0x1070	; 0x1070 <oled_write_pixel_to_SRAM>
		oled_write_pixel_to_SRAM(y0 + x, x0 - y, 1);
    124a:	41 e0       	ldi	r20, 0x01	; 1
    124c:	e9 2c       	mov	r14, r9
    124e:	e0 1a       	sub	r14, r16
    1250:	6e 2d       	mov	r22, r14
    1252:	8d 2d       	mov	r24, r13
    1254:	0e 94 38 08 	call	0x1070	; 0x1070 <oled_write_pixel_to_SRAM>
		oled_write_pixel_to_SRAM(y0 - x, x0 + y, 1);
    1258:	41 e0       	ldi	r20, 0x01	; 1
    125a:	6f 2d       	mov	r22, r15
    125c:	fc 2c       	mov	r15, r12
    125e:	fc 1a       	sub	r15, r28
    1260:	8f 2d       	mov	r24, r15
    1262:	0e 94 38 08 	call	0x1070	; 0x1070 <oled_write_pixel_to_SRAM>
		oled_write_pixel_to_SRAM(y0 - x, x0 - y, 1);
    1266:	41 e0       	ldi	r20, 0x01	; 1
    1268:	6e 2d       	mov	r22, r14
    126a:	8f 2d       	mov	r24, r15
    126c:	0e 94 38 08 	call	0x1070	; 0x1070 <oled_write_pixel_to_SRAM>

		if (err <= 0) {
    1270:	1a 14       	cp	r1, r10
    1272:	1b 04       	cpc	r1, r11
    1274:	5c f0       	brlt	.+22     	; 0x128c <oled_draw_circle+0xb2>
			y += 1;
    1276:	0f 5f       	subi	r16, 0xFF	; 255
    1278:	1f 4f       	sbci	r17, 0xFF	; 255
			err += 2 * y + 1;
    127a:	c8 01       	movw	r24, r16
    127c:	88 0f       	add	r24, r24
    127e:	99 1f       	adc	r25, r25
    1280:	01 96       	adiw	r24, 0x01	; 1
    1282:	a8 0e       	add	r10, r24
    1284:	b9 1e       	adc	r11, r25
		}
		if (err > 0) {
    1286:	1a 14       	cp	r1, r10
    1288:	1b 04       	cpc	r1, r11
    128a:	3c f4       	brge	.+14     	; 0x129a <oled_draw_circle+0xc0>
			x -= 1;
    128c:	21 97       	sbiw	r28, 0x01	; 1
			err -= 2 * x + 1;
    128e:	ce 01       	movw	r24, r28
    1290:	88 0f       	add	r24, r24
    1292:	99 1f       	adc	r25, r25
    1294:	01 96       	adiw	r24, 0x01	; 1
    1296:	a8 1a       	sub	r10, r24
    1298:	b9 0a       	sbc	r11, r25
void oled_draw_circle(uint8_t x0, uint8_t y0, uint8_t radius) {
	int x = radius;
	int y = 0;
	int err = 0;

	while (x >= y) {
    129a:	c0 17       	cp	r28, r16
    129c:	d1 07       	cpc	r29, r17
    129e:	0c f0       	brlt	.+2      	; 0x12a2 <oled_draw_circle+0xc8>
    12a0:	af cf       	rjmp	.-162    	; 0x1200 <oled_draw_circle+0x26>
		if (err > 0) {
			x -= 1;
			err -= 2 * x + 1;
		}
	}
}
    12a2:	df 91       	pop	r29
    12a4:	cf 91       	pop	r28
    12a6:	1f 91       	pop	r17
    12a8:	0f 91       	pop	r16
    12aa:	ff 90       	pop	r15
    12ac:	ef 90       	pop	r14
    12ae:	df 90       	pop	r13
    12b0:	cf 90       	pop	r12
    12b2:	bf 90       	pop	r11
    12b4:	af 90       	pop	r10
    12b6:	9f 90       	pop	r9
    12b8:	08 95       	ret

000012ba <oled_draw_square>:

void oled_draw_square(uint8_t x0, uint8_t y0, uint8_t width, uint8_t height) {
    12ba:	0f 93       	push	r16
    12bc:	1f 93       	push	r17
    12be:	cf 93       	push	r28
    12c0:	df 93       	push	r29
    12c2:	08 2f       	mov	r16, r24
    12c4:	16 2f       	mov	r17, r22
    12c6:	d2 2f       	mov	r29, r18
	oled_draw_line(x0, y0, x0 + width, y0);           // Øvre linje
    12c8:	c8 2f       	mov	r28, r24
    12ca:	c4 0f       	add	r28, r20
    12cc:	26 2f       	mov	r18, r22
    12ce:	4c 2f       	mov	r20, r28
    12d0:	0e 94 8a 08 	call	0x1114	; 0x1114 <oled_draw_line>
	oled_draw_line(x0, y0 + height, x0 + width, y0 + height);  // Nedre linje
    12d4:	d1 0f       	add	r29, r17
    12d6:	2d 2f       	mov	r18, r29
    12d8:	4c 2f       	mov	r20, r28
    12da:	6d 2f       	mov	r22, r29
    12dc:	80 2f       	mov	r24, r16
    12de:	0e 94 8a 08 	call	0x1114	; 0x1114 <oled_draw_line>
	oled_draw_line(x0, y0, x0, y0 + height);           // Venstre linje
    12e2:	2d 2f       	mov	r18, r29
    12e4:	40 2f       	mov	r20, r16
    12e6:	61 2f       	mov	r22, r17
    12e8:	80 2f       	mov	r24, r16
    12ea:	0e 94 8a 08 	call	0x1114	; 0x1114 <oled_draw_line>
	oled_draw_line(x0 + width, y0, x0 + width, y0 + height);   // Høyre linje
    12ee:	2d 2f       	mov	r18, r29
    12f0:	4c 2f       	mov	r20, r28
    12f2:	61 2f       	mov	r22, r17
    12f4:	8c 2f       	mov	r24, r28
    12f6:	0e 94 8a 08 	call	0x1114	; 0x1114 <oled_draw_line>
}
    12fa:	df 91       	pop	r29
    12fc:	cf 91       	pop	r28
    12fe:	1f 91       	pop	r17
    1300:	0f 91       	pop	r16
    1302:	08 95       	ret

00001304 <__vector_15>:

// Definer den globale variabelen for å telje millisekund
volatile uint32_t overflow_count = 0;

// Timer-overflyt interrupt service rutine
ISR(TIMER1_OVF_vect) {
    1304:	1f 92       	push	r1
    1306:	0f 92       	push	r0
    1308:	0f b6       	in	r0, 0x3f	; 63
    130a:	0f 92       	push	r0
    130c:	11 24       	eor	r1, r1
    130e:	8f 93       	push	r24
    1310:	9f 93       	push	r25
    1312:	af 93       	push	r26
    1314:	bf 93       	push	r27
	overflow_count++;
    1316:	80 91 bd 01 	lds	r24, 0x01BD	; 0x8001bd <overflow_count>
    131a:	90 91 be 01 	lds	r25, 0x01BE	; 0x8001be <overflow_count+0x1>
    131e:	a0 91 bf 01 	lds	r26, 0x01BF	; 0x8001bf <overflow_count+0x2>
    1322:	b0 91 c0 01 	lds	r27, 0x01C0	; 0x8001c0 <overflow_count+0x3>
    1326:	01 96       	adiw	r24, 0x01	; 1
    1328:	a1 1d       	adc	r26, r1
    132a:	b1 1d       	adc	r27, r1
    132c:	80 93 bd 01 	sts	0x01BD, r24	; 0x8001bd <overflow_count>
    1330:	90 93 be 01 	sts	0x01BE, r25	; 0x8001be <overflow_count+0x1>
    1334:	a0 93 bf 01 	sts	0x01BF, r26	; 0x8001bf <overflow_count+0x2>
    1338:	b0 93 c0 01 	sts	0x01C0, r27	; 0x8001c0 <overflow_count+0x3>
}
    133c:	bf 91       	pop	r27
    133e:	af 91       	pop	r26
    1340:	9f 91       	pop	r25
    1342:	8f 91       	pop	r24
    1344:	0f 90       	pop	r0
    1346:	0f be       	out	0x3f, r0	; 63
    1348:	0f 90       	pop	r0
    134a:	1f 90       	pop	r1
    134c:	18 95       	reti

0000134e <get_time_in_cycles>:
}

uint32_t get_time_in_cycles(void) {
	// Returner tiden i klokkesykluser
	// Hver gang timeren overflyter, har vi telt 65536 klokkesykluser
	return (overflow_count * 65536UL) + TCNT1;
    134e:	80 91 bd 01 	lds	r24, 0x01BD	; 0x8001bd <overflow_count>
    1352:	90 91 be 01 	lds	r25, 0x01BE	; 0x8001be <overflow_count+0x1>
    1356:	a0 91 bf 01 	lds	r26, 0x01BF	; 0x8001bf <overflow_count+0x2>
    135a:	b0 91 c0 01 	lds	r27, 0x01C0	; 0x8001c0 <overflow_count+0x3>
    135e:	2c b5       	in	r18, 0x2c	; 44
    1360:	3d b5       	in	r19, 0x2d	; 45
    1362:	dc 01       	movw	r26, r24
    1364:	99 27       	eor	r25, r25
    1366:	88 27       	eor	r24, r24
    1368:	bc 01       	movw	r22, r24
    136a:	cd 01       	movw	r24, r26
    136c:	62 0f       	add	r22, r18
    136e:	73 1f       	adc	r23, r19
    1370:	81 1d       	adc	r24, r1
    1372:	91 1d       	adc	r25, r1
}
    1374:	08 95       	ret

00001376 <get_time_in_ms>:
	overflow_count++;
}

// Funksjon som returnerer tida i millisekund sidan programstart
uint32_t get_time_in_ms(void){
	return get_time_in_cycles()/(4915200UL/1000);
    1376:	0e 94 a7 09 	call	0x134e	; 0x134e <get_time_in_cycles>
    137a:	23 e3       	ldi	r18, 0x33	; 51
    137c:	33 e1       	ldi	r19, 0x13	; 19
    137e:	40 e0       	ldi	r20, 0x00	; 0
    1380:	50 e0       	ldi	r21, 0x00	; 0
    1382:	0e 94 3c 0a 	call	0x1478	; 0x1478 <__udivmodsi4>
}
    1386:	ca 01       	movw	r24, r20
    1388:	b9 01       	movw	r22, r18
    138a:	08 95       	ret

0000138c <setup_timer>:
}

// Funksjon for å setje opp Timer1 til å generere 1 ms avbrot
void setup_timer() {
	// Sett normal modus (WGM12 = 0)
	TCCR1A = 0;      // Normal mode
    138c:	1f bc       	out	0x2f, r1	; 47
	TCCR1B = (1 << CS10); // Prescaler = 1 (ingen prescaling, f_CPU direkte)
    138e:	81 e0       	ldi	r24, 0x01	; 1
    1390:	8e bd       	out	0x2e, r24	; 46

	// Aktiver Timer1 overflow interrupt
	TIMSK = (1 << TOIE1);
    1392:	80 e8       	ldi	r24, 0x80	; 128
    1394:	89 bf       	out	0x39, r24	; 57

	// Nullstill Timer/Counter1
	TCNT1 = 0;
    1396:	1d bc       	out	0x2d, r1	; 45
    1398:	1c bc       	out	0x2c, r1	; 44
    139a:	08 95       	ret

0000139c <restart_timer>:
}
void restart_timer(){
	// Nullstill Timer/Counter1
	TCNT1 = 0;
    139c:	1d bc       	out	0x2d, r1	; 45
    139e:	1c bc       	out	0x2c, r1	; 44
	overflow_count = 0;
    13a0:	10 92 bd 01 	sts	0x01BD, r1	; 0x8001bd <overflow_count>
    13a4:	10 92 be 01 	sts	0x01BE, r1	; 0x8001be <overflow_count+0x1>
    13a8:	10 92 bf 01 	sts	0x01BF, r1	; 0x8001bf <overflow_count+0x2>
    13ac:	10 92 c0 01 	sts	0x01C0, r1	; 0x8001c0 <overflow_count+0x3>
    13b0:	08 95       	ret

000013b2 <externalMemoryInit>:
 */ 
#include "XMEM_Decode.h"
// Funksjon for ï¿½ initialisere det eksterne minnet (SRAM + latch)
void externalMemoryInit(void) {
	// Set Port A (AD0-AD7) og Port C (A8-A15) som utgang for adresse- og databuss
	DDRA = 0xFF;  // PA0-PA7 som utgang
    13b2:	8f ef       	ldi	r24, 0xFF	; 255
    13b4:	8a bb       	out	0x1a, r24	; 26
	DDRC = 0x0F ;  // PC0-PC3 som utgang
    13b6:	8f e0       	ldi	r24, 0x0F	; 15
    13b8:	84 bb       	out	0x14, r24	; 20
	
	// Set Port D (PD6 og PD7) som utgang for WR og RD signal
	setBit(DDRD, PD6);  // WR
    13ba:	8e 9a       	sbi	0x11, 6	; 17
	setBit(DDRD, PD7);  // RD
    13bc:	8f 9a       	sbi	0x11, 7	; 17

	// Set Port E (PE1) som utgang for ALE
	setBit(DDRE, PE1);  // ALE
    13be:	31 9a       	sbi	0x06, 1	; 6

	// Aktivere ekstern minnegrensesnitt
	setBit(MCUCR, SRE);   // Enable external SRAM interface
    13c0:	85 b7       	in	r24, 0x35	; 53
    13c2:	80 68       	ori	r24, 0x80	; 128
    13c4:	85 bf       	out	0x35, r24	; 53
	SFIOR = 0x00;         // No wait state
    13c6:	10 be       	out	0x30, r1	; 48
	
	//Maskes pc4-pc7 (disables as output) (s32 ATmega datasheet)
	setBit(SFIOR, XMM2);
    13c8:	80 b7       	in	r24, 0x30	; 48
    13ca:	80 62       	ori	r24, 0x20	; 32
    13cc:	80 bf       	out	0x30, r24	; 48
    13ce:	08 95       	ret

000013d0 <SRAM_write>:
}


// Funksjon for ï¿½ skrive data til SRAM
void SRAM_write(volatile uint16_t addr, uint8_t data) {
    13d0:	cf 93       	push	r28
    13d2:	df 93       	push	r29
    13d4:	00 d0       	rcall	.+0      	; 0x13d6 <SRAM_write+0x6>
    13d6:	cd b7       	in	r28, 0x3d	; 61
    13d8:	de b7       	in	r29, 0x3e	; 62
    13da:	9a 83       	std	Y+2, r25	; 0x02
    13dc:	89 83       	std	Y+1, r24	; 0x01
	volatile char *ext_ram = (char *) SRAM_START; // Startadresse for SRAM
	uint16_t ext_ram_size = SRAM_SIZE; // Stï¿½rrelsen pï¿½ SRAM (2 KB)
	ext_ram[addr] = data;
    13de:	e9 81       	ldd	r30, Y+1	; 0x01
    13e0:	fa 81       	ldd	r31, Y+2	; 0x02
    13e2:	f8 5e       	subi	r31, 0xE8	; 232
    13e4:	60 83       	st	Z, r22
}
    13e6:	0f 90       	pop	r0
    13e8:	0f 90       	pop	r0
    13ea:	df 91       	pop	r29
    13ec:	cf 91       	pop	r28
    13ee:	08 95       	ret

000013f0 <SRAM_read>:

// Funksjon for ï¿½ lese data frï¿½ SRAM
uint8_t SRAM_read(volatile uint16_t addr) {
    13f0:	cf 93       	push	r28
    13f2:	df 93       	push	r29
    13f4:	00 d0       	rcall	.+0      	; 0x13f6 <SRAM_read+0x6>
    13f6:	cd b7       	in	r28, 0x3d	; 61
    13f8:	de b7       	in	r29, 0x3e	; 62
    13fa:	9a 83       	std	Y+2, r25	; 0x02
    13fc:	89 83       	std	Y+1, r24	; 0x01
	volatile char *ext_ram = (char *) SRAM_START; // Startadresse for SRAM
	uint16_t ext_ram_size = SRAM_SIZE; // Stï¿½rrelsen pï¿½ SRAM (2 KB)
	uint8_t data = ext_ram[addr];
    13fe:	e9 81       	ldd	r30, Y+1	; 0x01
    1400:	fa 81       	ldd	r31, Y+2	; 0x02
    1402:	f8 5e       	subi	r31, 0xE8	; 232
    1404:	80 81       	ld	r24, Z
	
	return data;
}
    1406:	0f 90       	pop	r0
    1408:	0f 90       	pop	r0
    140a:	df 91       	pop	r29
    140c:	cf 91       	pop	r28
    140e:	08 95       	ret

00001410 <Universal_write>:

// Funksjon for ï¿½ skrive data til SRAM
void Universal_write(volatile uint16_t addr, uint8_t data) {
    1410:	cf 93       	push	r28
    1412:	df 93       	push	r29
    1414:	00 d0       	rcall	.+0      	; 0x1416 <Universal_write+0x6>
    1416:	cd b7       	in	r28, 0x3d	; 61
    1418:	de b7       	in	r29, 0x3e	; 62
    141a:	9a 83       	std	Y+2, r25	; 0x02
    141c:	89 83       	std	Y+1, r24	; 0x01
	volatile char *ext_ram = (char *) OLED_START; // Startadresse for SRAM
	ext_ram[addr] = data;
    141e:	e9 81       	ldd	r30, Y+1	; 0x01
    1420:	fa 81       	ldd	r31, Y+2	; 0x02
    1422:	f0 5f       	subi	r31, 0xF0	; 240
    1424:	60 83       	st	Z, r22
		
}
    1426:	0f 90       	pop	r0
    1428:	0f 90       	pop	r0
    142a:	df 91       	pop	r29
    142c:	cf 91       	pop	r28
    142e:	08 95       	ret

00001430 <Universal_read>:

// Funksjon for ï¿½ lese data frï¿½ SRAM
uint8_t Universal_read(volatile uint16_t addr) {
    1430:	cf 93       	push	r28
    1432:	df 93       	push	r29
    1434:	00 d0       	rcall	.+0      	; 0x1436 <Universal_read+0x6>
    1436:	cd b7       	in	r28, 0x3d	; 61
    1438:	de b7       	in	r29, 0x3e	; 62
    143a:	9a 83       	std	Y+2, r25	; 0x02
    143c:	89 83       	std	Y+1, r24	; 0x01
	volatile char *ext_ram = (char *) OLED_START; // Startadresse for SRAM
	uint8_t data = ext_ram[addr];
    143e:	e9 81       	ldd	r30, Y+1	; 0x01
    1440:	fa 81       	ldd	r31, Y+2	; 0x02
    1442:	f0 5f       	subi	r31, 0xF0	; 240
    1444:	80 81       	ld	r24, Z
	
	return data;
}
    1446:	0f 90       	pop	r0
    1448:	0f 90       	pop	r0
    144a:	df 91       	pop	r29
    144c:	cf 91       	pop	r28
    144e:	08 95       	ret

00001450 <__divmodhi4>:
    1450:	97 fb       	bst	r25, 7
    1452:	07 2e       	mov	r0, r23
    1454:	16 f4       	brtc	.+4      	; 0x145a <__divmodhi4+0xa>
    1456:	00 94       	com	r0
    1458:	07 d0       	rcall	.+14     	; 0x1468 <__divmodhi4_neg1>
    145a:	77 fd       	sbrc	r23, 7
    145c:	09 d0       	rcall	.+18     	; 0x1470 <__divmodhi4_neg2>
    145e:	0e 94 5e 0a 	call	0x14bc	; 0x14bc <__udivmodhi4>
    1462:	07 fc       	sbrc	r0, 7
    1464:	05 d0       	rcall	.+10     	; 0x1470 <__divmodhi4_neg2>
    1466:	3e f4       	brtc	.+14     	; 0x1476 <__divmodhi4_exit>

00001468 <__divmodhi4_neg1>:
    1468:	90 95       	com	r25
    146a:	81 95       	neg	r24
    146c:	9f 4f       	sbci	r25, 0xFF	; 255
    146e:	08 95       	ret

00001470 <__divmodhi4_neg2>:
    1470:	70 95       	com	r23
    1472:	61 95       	neg	r22
    1474:	7f 4f       	sbci	r23, 0xFF	; 255

00001476 <__divmodhi4_exit>:
    1476:	08 95       	ret

00001478 <__udivmodsi4>:
    1478:	a1 e2       	ldi	r26, 0x21	; 33
    147a:	1a 2e       	mov	r1, r26
    147c:	aa 1b       	sub	r26, r26
    147e:	bb 1b       	sub	r27, r27
    1480:	fd 01       	movw	r30, r26
    1482:	0d c0       	rjmp	.+26     	; 0x149e <__udivmodsi4_ep>

00001484 <__udivmodsi4_loop>:
    1484:	aa 1f       	adc	r26, r26
    1486:	bb 1f       	adc	r27, r27
    1488:	ee 1f       	adc	r30, r30
    148a:	ff 1f       	adc	r31, r31
    148c:	a2 17       	cp	r26, r18
    148e:	b3 07       	cpc	r27, r19
    1490:	e4 07       	cpc	r30, r20
    1492:	f5 07       	cpc	r31, r21
    1494:	20 f0       	brcs	.+8      	; 0x149e <__udivmodsi4_ep>
    1496:	a2 1b       	sub	r26, r18
    1498:	b3 0b       	sbc	r27, r19
    149a:	e4 0b       	sbc	r30, r20
    149c:	f5 0b       	sbc	r31, r21

0000149e <__udivmodsi4_ep>:
    149e:	66 1f       	adc	r22, r22
    14a0:	77 1f       	adc	r23, r23
    14a2:	88 1f       	adc	r24, r24
    14a4:	99 1f       	adc	r25, r25
    14a6:	1a 94       	dec	r1
    14a8:	69 f7       	brne	.-38     	; 0x1484 <__udivmodsi4_loop>
    14aa:	60 95       	com	r22
    14ac:	70 95       	com	r23
    14ae:	80 95       	com	r24
    14b0:	90 95       	com	r25
    14b2:	9b 01       	movw	r18, r22
    14b4:	ac 01       	movw	r20, r24
    14b6:	bd 01       	movw	r22, r26
    14b8:	cf 01       	movw	r24, r30
    14ba:	08 95       	ret

000014bc <__udivmodhi4>:
    14bc:	aa 1b       	sub	r26, r26
    14be:	bb 1b       	sub	r27, r27
    14c0:	51 e1       	ldi	r21, 0x11	; 17
    14c2:	07 c0       	rjmp	.+14     	; 0x14d2 <__udivmodhi4_ep>

000014c4 <__udivmodhi4_loop>:
    14c4:	aa 1f       	adc	r26, r26
    14c6:	bb 1f       	adc	r27, r27
    14c8:	a6 17       	cp	r26, r22
    14ca:	b7 07       	cpc	r27, r23
    14cc:	10 f0       	brcs	.+4      	; 0x14d2 <__udivmodhi4_ep>
    14ce:	a6 1b       	sub	r26, r22
    14d0:	b7 0b       	sbc	r27, r23

000014d2 <__udivmodhi4_ep>:
    14d2:	88 1f       	adc	r24, r24
    14d4:	99 1f       	adc	r25, r25
    14d6:	5a 95       	dec	r21
    14d8:	a9 f7       	brne	.-22     	; 0x14c4 <__udivmodhi4_loop>
    14da:	80 95       	com	r24
    14dc:	90 95       	com	r25
    14de:	bc 01       	movw	r22, r24
    14e0:	cd 01       	movw	r24, r26
    14e2:	08 95       	ret

000014e4 <strncpy_P>:
    14e4:	fb 01       	movw	r30, r22
    14e6:	dc 01       	movw	r26, r24
    14e8:	41 50       	subi	r20, 0x01	; 1
    14ea:	50 40       	sbci	r21, 0x00	; 0
    14ec:	48 f0       	brcs	.+18     	; 0x1500 <strncpy_P+0x1c>
    14ee:	05 90       	lpm	r0, Z+
    14f0:	0d 92       	st	X+, r0
    14f2:	00 20       	and	r0, r0
    14f4:	c9 f7       	brne	.-14     	; 0x14e8 <strncpy_P+0x4>
    14f6:	01 c0       	rjmp	.+2      	; 0x14fa <strncpy_P+0x16>
    14f8:	1d 92       	st	X+, r1
    14fa:	41 50       	subi	r20, 0x01	; 1
    14fc:	50 40       	sbci	r21, 0x00	; 0
    14fe:	e0 f7       	brcc	.-8      	; 0x14f8 <strncpy_P+0x14>
    1500:	08 95       	ret

00001502 <strncpy>:
    1502:	fb 01       	movw	r30, r22
    1504:	dc 01       	movw	r26, r24
    1506:	41 50       	subi	r20, 0x01	; 1
    1508:	50 40       	sbci	r21, 0x00	; 0
    150a:	48 f0       	brcs	.+18     	; 0x151e <strncpy+0x1c>
    150c:	01 90       	ld	r0, Z+
    150e:	0d 92       	st	X+, r0
    1510:	00 20       	and	r0, r0
    1512:	c9 f7       	brne	.-14     	; 0x1506 <strncpy+0x4>
    1514:	01 c0       	rjmp	.+2      	; 0x1518 <strncpy+0x16>
    1516:	1d 92       	st	X+, r1
    1518:	41 50       	subi	r20, 0x01	; 1
    151a:	50 40       	sbci	r21, 0x00	; 0
    151c:	e0 f7       	brcc	.-8      	; 0x1516 <strncpy+0x14>
    151e:	08 95       	ret

00001520 <_exit>:
    1520:	f8 94       	cli

00001522 <__stop_program>:
    1522:	ff cf       	rjmp	.-2      	; 0x1522 <__stop_program>
